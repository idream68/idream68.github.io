<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo支持uml</title>
    <url>/2022/05/10/hexo/uml/</url>
    <content><![CDATA[<ol>
<li>添加依赖</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-plantuml --save</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在_config.yml中开启支持</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mermaid:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/05/10/spring/springmvccarding/index/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/05/10/spring/springmvc/index/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/05/10/spring/springcloud/index/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/05/10/spring/springbootcarding/index/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/05/10/messagequeue/rabbitmq/index/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/05/10/messagequeue/kafka/index/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Hexo 快速入门</title>
    <url>/2022/05/10/hexo/hexo-quick-start/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>help</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/05/10/elasticsearch/index/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/05/10/database/redis/index/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/05/10/database/mongodb/index/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>QLExpress</title>
    <url>/2021/07/19/java/QLExpress/</url>
    <content><![CDATA[<p>由阿里的电商业务规则、表达式（布尔组合）、特殊数学公式计算（高精度）、语法分析、脚本二次定制等强需求而设计的一门动态脚本引擎解析工具。 在阿里集团有很强的影响力，同时为了自身不断优化、发扬开源贡献精神，于2012年开源。</p>
<p>QLExpress脚本引擎被广泛应用在阿里的电商业务场景，具有以下的一些特性:</p>
<ul>
<li>1、线程安全，引擎运算过程中的产生的临时变量都是threadlocal类型。</li>
<li>2、高效执行，比较耗时的脚本编译过程可以缓存在本地机器，运行时的临时变量创建采用了缓冲池的技术，和groovy性能相当。</li>
<li>3、弱类型脚本语言，和groovy，javascript语法类似，虽然比强类型脚本语言要慢一些，但是使业务的灵活度大大增强。</li>
<li>4、安全控制,可以通过设置相关运行参数，预防死循环、高危系统api调用等情况。</li>
<li>5、代码精简，依赖最小，250k的jar包适合所有java的运行环境，在android系统的低端pos机也得到广泛运用。</li>
</ul>
<p>QLExpressRunner如下图所示，从语法树分析、上下文、执行过程三个方面提供二次定制的功能扩展。<br><img src="/images/qlexpress.jpg" alt="image"></p>
<p>git 地址：<a href="https://github.com/alibaba/QLExpress">https://github.com/alibaba/QLExpress</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro 自定义加密方法</title>
    <url>/2021/06/15/spring/springboot/shiro/shiro-customer-encryption/</url>
    <content><![CDATA[<ol>
<li><p>自定义 filter</p>
<p>根据自定义条件筛选访问是否被允许，允许访问则进行后续的授权或者认证流程，不允许则直接返回相应。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomFilter</span> <span class="keyword">extends</span> <span class="title class_">BasicHttpAuthenticationFilter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">httpServletRequest</span> <span class="operator">=</span> WebUtils.toHttp(request);</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">httpServletResponse</span> <span class="operator">=</span> WebUtils.toHttp(response);</span><br><span class="line">        <span class="comment">// 跨域时会首先发送一个option请求，这里我们给option请求直接返回正常状态</span></span><br><span class="line">        <span class="keyword">if</span> (httpServletRequest.getMethod().equals(RequestMethod.OPTIONS.name())) &#123;</span><br><span class="line">            httpServletResponse.setStatus(HttpStatus.OK.value());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.preHandle(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(ServletRequest request, ServletResponse response)</span> &#123;</span><br><span class="line">        <span class="comment">// 添加跨域支持</span></span><br><span class="line">        <span class="built_in">this</span>.fillCorsHeader(WebUtils.toHttp(request), WebUtils.toHttp(response));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤器拦截请求的入口方法</span></span><br><span class="line"><span class="comment">     * 返回 true 则允许访问</span></span><br><span class="line"><span class="comment">     * 返回false 则禁止访问，会进入 onAccessDenied()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isAccessAllowed</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> &#123;</span><br><span class="line">        <span class="comment">// 原用来判断是否是登录请求，在本例中不会拦截登录请求，用来检测Header中是否包含 JWT token 字段</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isLoginRequest(request, response))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">allowed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 检测Header里的 JWT token内容是否正确，尝试使用 token进行登录</span></span><br><span class="line">            allowed = executeLogin(request, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123; <span class="comment">// not found any token</span></span><br><span class="line">            log.error(<span class="string">&quot;Not found any token&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Error occurs when login&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allowed || <span class="built_in">super</span>.isPermissive(mappedValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检测Header中是否包含 JWT token 字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isLoginAttempt</span><span class="params">(ServletRequest request, ServletResponse response)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((HttpServletRequest) request).getHeader(<span class="string">&quot;Authorization&quot;</span>) == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 身份验证,检查 JWT token 是否合法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">executeLogin</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">AuthenticationToken</span> <span class="variable">token</span> <span class="operator">=</span> createToken(request, response);</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;createToken method implementation returned null. A valid non-null AuthenticationToken &quot;</span></span><br><span class="line">                    + <span class="string">&quot;must be created in order to execute a login attempt.&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> getSubject(request, response);</span><br><span class="line">            subject.login(token); <span class="comment">// 交给 Shiro 去进行登录验证</span></span><br><span class="line">            <span class="keyword">return</span> onLoginSuccess(token, subject, request, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> onLoginFailure(token, e, request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从 Header 里提取 JWT token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationToken <span class="title function_">createToken</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">httpServletRequest</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">        <span class="type">String</span> <span class="variable">authorization</span> <span class="operator">=</span> httpServletRequest.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="type">CustomToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomToken</span>(authorization);</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * isAccessAllowed()方法返回false，会进入该方法，表示拒绝访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">onAccessDenied</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">httpResponse</span> <span class="operator">=</span> WebUtils.toHttp(servletResponse);</span><br><span class="line">        httpResponse.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        httpResponse.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">        httpResponse.setStatus(HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> httpResponse.getWriter();</span><br><span class="line">        writer.write(<span class="string">&quot;&#123;\&quot;errCode\&quot;: 401, \&quot;msg\&quot;: \&quot;UNAUTHORIZED\&quot;&#125;&quot;</span>);</span><br><span class="line">        fillCorsHeader(WebUtils.toHttp(servletRequest), httpResponse);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shiro 利用 JWT token 登录成功，会进入该方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">onLoginSuccess</span><span class="params">(AuthenticationToken token, Subject subject, ServletRequest request,</span></span><br><span class="line"><span class="params">                                     ServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">httpResponse</span> <span class="operator">=</span> WebUtils.toHttp(response);</span><br><span class="line">        <span class="type">String</span> <span class="variable">newToken</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (token <span class="keyword">instanceof</span> CustomToken) &#123;</span><br><span class="line">            newToken = ((CustomToken) token).getToken();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newToken != <span class="literal">null</span>)</span><br><span class="line">            httpResponse.setHeader(<span class="string">&quot;Authorization&quot;</span>, newToken);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shiro 利用 JWT token 登录失败，会进入该方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">onLoginFailure</span><span class="params">(AuthenticationToken token, AuthenticationException e, ServletRequest request,</span></span><br><span class="line"><span class="params">                                     ServletResponse response)</span> &#123;</span><br><span class="line">        <span class="comment">// 此处直接返回 false ，交给后面的  onAccessDenied()方法进行处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加跨域支持</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">fillCorsHeader</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> &#123;</span><br><span class="line">        httpServletResponse.setHeader(<span class="string">&quot;Access-control-Allow-Origin&quot;</span>, httpServletRequest.getHeader(<span class="string">&quot;Origin&quot;</span>));</span><br><span class="line">        httpServletResponse.setHeader(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;GET,POST,OPTIONS,HEAD&quot;</span>);</span><br><span class="line">        httpServletResponse.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>,</span><br><span class="line">                httpServletRequest.getHeader(<span class="string">&quot;Access-Control-Request-Headers&quot;</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>自定义 realm</p>
<p>自定义认证和授权方法，认证方法处理用户是否存在和用户状态，判断是否可以登录；授权方法结构化用户所属的用户组和所拥有的权限。每次授权流程操作之前都会有认证流程， 认证不通过，则直接返回，不会进行授权流程。认证密码（token）状态需要自定义 credentialsMatcher 流程进行判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomRealm</span> <span class="keyword">extends</span> <span class="title class_">AuthorizingRealm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤自定义token类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(AuthenticationToken token)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> token <span class="keyword">instanceof</span> CustomToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权，权限和用户组都为 &#123;xx,yy&#125;；根据具体情况修改，此处仅为示例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> principals</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthorizationInfo <span class="title function_">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> &#123;</span><br><span class="line">        <span class="type">SimpleAuthorizationInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthorizationInfo</span>();</span><br><span class="line">        Set&lt;String&gt; roles = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        roles.add(<span class="string">&quot;xx&quot;</span>);</span><br><span class="line">        roles.add(<span class="string">&quot;yy&quot;</span>);</span><br><span class="line">        info.setRoles(roles);</span><br><span class="line">        info.setStringPermissions(roles);</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证，只有token是ss时才能通过认证，进行下一步验证，根据具体情况修改，此处仅为示例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> AuthenticationException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> token.getPrincipal().toString();</span><br><span class="line">        <span class="keyword">if</span> (t.equals(<span class="string">&quot;ss&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthenticationInfo</span>(t, t, getName());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AuthenticationException</span>(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>自定义 credentialsMatcher</p>
<p>判断用户密码、token等是否和所需的一致（经过自定以加密之后）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomCredentialsMatcher</span> <span class="keyword">implements</span> <span class="title class_">CredentialsMatcher</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义认证方法（密码，token等自定义验证方法），登录，和其他方法都需要验证；根据具体情况修改，此处仅为示例，全部通过验证</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> info</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 验证成功，false 验证失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doCredentialsMatch</span><span class="params">(AuthenticationToken token, AuthenticationInfo info)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>将自定义的filter,realm,creadentialsMatcher配置到shiro配置中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiroConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交由 Spring 来自动地管理 Shiro-Bean 的生命周期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LifecycleBeanPostProcessor <span class="title function_">getLifecycleBeanPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LifecycleBeanPostProcessor</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为 Spring-Bean 开启对 Shiro 注解的支持</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthorizationAttributeSourceAdvisor <span class="title function_">authorizationAttributeSourceAdvisor</span><span class="params">(SecurityManager securityManager)</span> &#123;</span><br><span class="line">        <span class="type">AuthorizationAttributeSourceAdvisor</span> <span class="variable">authorizationAttributeSourceAdvisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthorizationAttributeSourceAdvisor</span>();</span><br><span class="line">        authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);</span><br><span class="line">        <span class="keyword">return</span> authorizationAttributeSourceAdvisor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DefaultAdvisorAutoProxyCreator <span class="title function_">defaultAdvisorAutoProxyCreator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DefaultAdvisorAutoProxyCreator</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultAdvisorAutoProxyCreator</span>();</span><br><span class="line">        app.setProxyTargetClass(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> app;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置访问资源需要的权限</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    ShiroFilterFactoryBean <span class="title function_">shiroFilterFactoryBean</span><span class="params">(SecurityManager securityManager)</span> &#123;</span><br><span class="line">        <span class="type">ShiroFilterFactoryBean</span> <span class="variable">shiroFilterFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShiroFilterFactoryBean</span>();</span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line">        shiroFilterFactoryBean.setLoginUrl(<span class="string">&quot;/login&quot;</span>);</span><br><span class="line">        shiroFilterFactoryBean.setSuccessUrl(<span class="string">&quot;/authorized&quot;</span>);</span><br><span class="line">        shiroFilterFactoryBean.setUnauthorizedUrl(<span class="string">&quot;/unauthorized&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Filter&gt; filterMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">CustomFilter</span> <span class="variable">customFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomFilter</span>();</span><br><span class="line">        filterMap.put(<span class="string">&quot;custom&quot;</span>, customFilter);</span><br><span class="line">        shiroFilterFactoryBean.setFilters(filterMap);</span><br><span class="line"></span><br><span class="line">        LinkedHashMap&lt;String, String&gt; filterChainDefinitionMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String, String&gt;();</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/login&quot;</span>, <span class="string">&quot;custom&quot;</span>); <span class="comment">// 自定义</span></span><br><span class="line"><span class="comment">//        filterChainDefinitionMap.put(&quot;/logout&quot;, &quot;logout&quot;); // 退出登录</span></span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/**&quot;</span>, <span class="string">&quot;custom&quot;</span>); <span class="comment">// 自定义</span></span><br><span class="line">        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);</span><br><span class="line">        <span class="keyword">return</span> shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    CustomRealm <span class="title function_">customRealm</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CustomRealm</span> <span class="variable">customRealm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomRealm</span>();</span><br><span class="line">        <span class="type">CustomCredentialsMatcher</span> <span class="variable">customCredentialsMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomCredentialsMatcher</span>();</span><br><span class="line">        customRealm.setCredentialsMatcher(customCredentialsMatcher);</span><br><span class="line">        <span class="keyword">return</span> customRealm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置 SecurityManager</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityManager <span class="title function_">securityManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DefaultWebSecurityManager</span> <span class="variable">securityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultWebSecurityManager</span>();</span><br><span class="line">        List&lt;Realm&gt; realms = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        realms.add(customRealm());</span><br><span class="line">        securityManager.setRealms(realms);</span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><a href="https://github.com/idream68/spring-demo/tree/master/shiro_custom_encryption">完整示例代码</a></p>
]]></content>
      <categories>
        <category>spring</category>
        <category>springboot</category>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>shiro</tag>
        <tag>encryption</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro + redis + jwt 基础</title>
    <url>/2021/06/15/spring/springboot/shiro/shiro-redis-jwt/</url>
    <content><![CDATA[<p>shiro-redis 和 shiro-jwt 的结合版，可以附加功能</p>
<ol>
<li>在线人数统计</li>
<li>会话管理</li>
<li>并发控制</li>
<li>…</li>
</ol>
<p>附加功能建议使用 session+redis</p>
<p><a href="https://github.com/idream68/spring-demo/tree/master/shiro_redis_token">完整代码示例</a></p>
]]></content>
      <categories>
        <category>spring</category>
        <category>springboot</category>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>shiro</tag>
        <tag>jwt</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro + redis 基础</title>
    <url>/2021/06/15/spring/springboot/shiro/shiro-redis-session/</url>
    <content><![CDATA[<p>将 session 保存到 redis 中</p>
<ol>
<li>导入依赖（gradle版）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">implementation group: &#x27;org.crazycake&#x27;, name: &#x27;shiro-redis&#x27;, version: &#x27;3.3.1&#x27;</span><br></pre></td></tr></table></figure>

<p>使用shiro-redis作为将session保存到redis的插件</p>
<ol start="2">
<li><p>修改配置文件，将session管理设置成redis</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiroConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="keyword">private</span> ResourcesService resourcesService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.timeout&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.redis.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LifecycleBeanPostProcessor <span class="title function_">getLifecycleBeanPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LifecycleBeanPostProcessor</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ShiroFilterFactoryBean 处理拦截资源文件问题。</span></span><br><span class="line"><span class="comment">     * 注意：单独一个ShiroFilterFactoryBean配置是或报错的，因为在</span></span><br><span class="line"><span class="comment">     * 初始化ShiroFilterFactoryBean的时候需要注入：SecurityManager</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     Filter Chain定义说明</span></span><br><span class="line"><span class="comment">     1、一个URL可以配置多个Filter，使用逗号分隔</span></span><br><span class="line"><span class="comment">     2、当设置多个过滤器时，全部验证通过，才视为通过</span></span><br><span class="line"><span class="comment">     3、部分过滤器可指定参数，如perms，roles</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ShiroFilterFactoryBean <span class="title function_">shirFilter</span><span class="params">(SecurityManager securityManager)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ShiroConfiguration.shirFilter()&quot;</span>);</span><br><span class="line">        <span class="type">ShiroFilterFactoryBean</span> <span class="variable">shiroFilterFactoryBean</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShiroFilterFactoryBean</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必须设置 SecurityManager</span></span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line">        <span class="comment">// 如果不设置默认会自动寻找Web工程根目录下的&quot;/login.jsp&quot;页面</span></span><br><span class="line">        shiroFilterFactoryBean.setLoginUrl(<span class="string">&quot;/login&quot;</span>);</span><br><span class="line">        <span class="comment">// 登录成功后要跳转的链接</span></span><br><span class="line">        shiroFilterFactoryBean.setSuccessUrl(<span class="string">&quot;/users&quot;</span>);</span><br><span class="line">        <span class="comment">//未授权界面;</span></span><br><span class="line">        shiroFilterFactoryBean.setUnauthorizedUrl(<span class="string">&quot;/403&quot;</span>);</span><br><span class="line">        <span class="comment">//拦截器.</span></span><br><span class="line">        Map&lt;String,String&gt; filterChainDefinitionMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String,String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//配置退出 过滤器,其中的具体的退出代码Shiro已经替我们实现了</span></span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/logout&quot;</span>, <span class="string">&quot;logout&quot;</span>);</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/css/**&quot;</span>,<span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/js/**&quot;</span>,<span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/img/**&quot;</span>,<span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/font-awesome/**&quot;</span>,<span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        <span class="comment">//&lt;!-- 过滤链定义，从上向下顺序执行，一般将 /**放在最为下边 --&gt;:这是一个坑呢，一不小心代码就不好使了;</span></span><br><span class="line">        <span class="comment">//&lt;!-- authc:所有url都必须认证通过才可以访问; anon:所有url都都可以匿名访问--&gt;</span></span><br><span class="line">        <span class="comment">//自定义加载权限资源关系</span></span><br><span class="line">        List&lt;Resources&gt; resourcesList = resourcesService.list();</span><br><span class="line">        <span class="keyword">for</span>(Resources resources:resourcesList)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(resources.getResUrl())) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">permission</span> <span class="operator">=</span> <span class="string">&quot;perms[&quot;</span> + resources.getResUrl()+ <span class="string">&quot;]&quot;</span>;</span><br><span class="line">                filterChainDefinitionMap.put(resources.getResUrl(),permission);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/**&quot;</span>, <span class="string">&quot;authc&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);</span><br><span class="line">        <span class="keyword">return</span> shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityManager <span class="title function_">securityManager</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DefaultWebSecurityManager</span> <span class="variable">securityManager</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">DefaultWebSecurityManager</span>();</span><br><span class="line">        <span class="comment">//设置realm.</span></span><br><span class="line">        securityManager.setRealm(myShiroRealm());</span><br><span class="line">        <span class="comment">// 自定义缓存实现 使用redis</span></span><br><span class="line">        securityManager.setCacheManager(cacheManager());</span><br><span class="line">        <span class="comment">// 自定义session管理 使用redis</span></span><br><span class="line">        securityManager.setSessionManager(sessionManager());</span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyShiroRealm <span class="title function_">myShiroRealm</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MyShiroRealm</span> <span class="variable">myShiroRealm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyShiroRealm</span>();</span><br><span class="line">        myShiroRealm.setCredentialsMatcher(hashedCredentialsMatcher());</span><br><span class="line">        <span class="keyword">return</span> myShiroRealm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 凭证匹配器</span></span><br><span class="line"><span class="comment">     * （由于我们的密码校验交给Shiro的SimpleAuthenticationInfo进行处理了</span></span><br><span class="line"><span class="comment">     *  所以我们需要修改下doGetAuthenticationInfo中的代码;</span></span><br><span class="line"><span class="comment">     * ）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HashedCredentialsMatcher <span class="title function_">hashedCredentialsMatcher</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">HashedCredentialsMatcher</span> <span class="variable">hashedCredentialsMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashedCredentialsMatcher</span>();</span><br><span class="line"></span><br><span class="line">        hashedCredentialsMatcher.setHashAlgorithmName(<span class="string">&quot;SHA-1&quot;</span>);</span><br><span class="line">        hashedCredentialsMatcher.setHashIterations(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hashedCredentialsMatcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  开启shiro aop注解支持.</span></span><br><span class="line"><span class="comment">     *  使用代理方式;所以需要开启代码支持;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> securityManager</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthorizationAttributeSourceAdvisor <span class="title function_">authorizationAttributeSourceAdvisor</span><span class="params">(SecurityManager securityManager)</span>&#123;</span><br><span class="line">        <span class="type">AuthorizationAttributeSourceAdvisor</span> <span class="variable">authorizationAttributeSourceAdvisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthorizationAttributeSourceAdvisor</span>();</span><br><span class="line">        authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);</span><br><span class="line">        <span class="keyword">return</span> authorizationAttributeSourceAdvisor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置shiro redisManager</span></span><br><span class="line"><span class="comment">     * 使用的是shiro-redis开源插件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> RedisManager <span class="title function_">redisManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RedisManager</span> <span class="variable">redisManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisManager</span>();</span><br><span class="line">        redisManager.setHost(host);</span><br><span class="line">        redisManager.setTimeout(timeout);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(password))&#123;</span><br><span class="line">            redisManager.setPassword(password);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cacheManager 缓存 redis实现</span></span><br><span class="line"><span class="comment">     * 使用的是shiro-redis开源插件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> RedisCacheManager <span class="title function_">cacheManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RedisCacheManager</span> <span class="variable">redisCacheManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisCacheManager</span>();</span><br><span class="line">        redisCacheManager.setRedisManager(redisManager());</span><br><span class="line">        <span class="keyword">return</span> redisCacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RedisSessionDAO shiro sessionDao层的实现 通过redis</span></span><br><span class="line"><span class="comment">     * 使用的是shiro-redis开源插件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisSessionDAO <span class="title function_">redisSessionDAO</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RedisSessionDAO</span> <span class="variable">redisSessionDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisSessionDAO</span>();</span><br><span class="line">        redisSessionDAO.setRedisManager(redisManager());</span><br><span class="line">        <span class="keyword">return</span> redisSessionDAO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * shiro session的管理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DefaultWebSessionManager <span class="title function_">sessionManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DefaultWebSessionManager</span> <span class="variable">sessionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultWebSessionManager</span>();</span><br><span class="line">        sessionManager.setSessionDAO(redisSessionDAO());</span><br><span class="line">        <span class="keyword">return</span> sessionManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/idream68/spring-demo/tree/master/shiro_redis">完整代码示例</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>spring</category>
        <category>springboot</category>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>shiro</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro + jwt 基础</title>
    <url>/2021/06/15/spring/springboot/shiro/shiro-jwt/</url>
    <content><![CDATA[<h3 id="jwt-简介"><a href="#jwt-简介" class="headerlink" title="jwt 简介"></a>jwt 简介</h3><blockquote>
<p>JSON Web Token (JWT)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。</p>
</blockquote>
<p>JSON Web Token由三部分组成，它们之间用圆点(.)连接。这三部分分别是：</p>
<ul>
<li>Header</li>
<li>Payload</li>
<li>Signature</li>
</ul>
<p>因此，一个典型的JWT看起来是这个样子的：</p>
<blockquote>
<p>xxxxx.yyyyy.zzzzz</p>
</blockquote>
<h3 id="shiro中集成JWT"><a href="#shiro中集成JWT" class="headerlink" title="shiro中集成JWT"></a>shiro中集成JWT</h3><ol>
<li><p>定义 JWT filter</p>
<p>在shiro配置中定义哪些 url 使用 JWT 验证，jwt根据自定义条件判断是否可以进行访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtFilter</span> <span class="keyword">extends</span> <span class="title class_">BasicHttpAuthenticationFilter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">httpServletRequest</span> <span class="operator">=</span> WebUtils.toHttp(request);</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">httpServletResponse</span> <span class="operator">=</span> WebUtils.toHttp(response);</span><br><span class="line">        <span class="comment">// 跨域时会首先发送一个option请求，这里我们给option请求直接返回正常状态</span></span><br><span class="line">        <span class="keyword">if</span> (httpServletRequest.getMethod().equals(RequestMethod.OPTIONS.name())) &#123;</span><br><span class="line">            httpServletResponse.setStatus(HttpStatus.OK.value());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.preHandle(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(ServletRequest request, ServletResponse response)</span> &#123;</span><br><span class="line">        <span class="comment">// 添加跨域支持</span></span><br><span class="line">        <span class="built_in">this</span>.fillCorsHeader(WebUtils.toHttp(request), WebUtils.toHttp(response));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤器拦截请求的入口方法</span></span><br><span class="line"><span class="comment">     * 返回 true 则允许访问</span></span><br><span class="line"><span class="comment">     * 返回false 则禁止访问，会进入 onAccessDenied()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isAccessAllowed</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> &#123;</span><br><span class="line">        <span class="comment">// 原用来判断是否是登录请求，在本例中不会拦截登录请求，用来检测Header中是否包含 JWT token 字段</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isLoginRequest(request, response))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">allowed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 检测Header里的 JWT token内容是否正确，尝试使用 token进行登录</span></span><br><span class="line">            allowed = executeLogin(request, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123; <span class="comment">// not found any token</span></span><br><span class="line">            log.error(<span class="string">&quot;Not found any token&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Error occurs when login&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allowed || <span class="built_in">super</span>.isPermissive(mappedValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检测Header中是否包含 JWT token 字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isLoginAttempt</span><span class="params">(ServletRequest request, ServletResponse response)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((HttpServletRequest) request).getHeader(JwtUtils.AUTH_HEADER) == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 身份验证,检查 JWT token 是否合法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">executeLogin</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">AuthenticationToken</span> <span class="variable">token</span> <span class="operator">=</span> createToken(request, response);</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;createToken method implementation returned null. A valid non-null AuthenticationToken &quot;</span></span><br><span class="line">                    + <span class="string">&quot;must be created in order to execute a login attempt.&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> getSubject(request, response);</span><br><span class="line">            subject.login(token); <span class="comment">// 交给 Shiro 去进行登录验证</span></span><br><span class="line">            <span class="keyword">return</span> onLoginSuccess(token, subject, request, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> onLoginFailure(token, e, request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从 Header 里提取 JWT token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationToken <span class="title function_">createToken</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">httpServletRequest</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">        <span class="type">String</span> <span class="variable">authorization</span> <span class="operator">=</span> httpServletRequest.getHeader(JwtUtils.AUTH_HEADER);</span><br><span class="line">        <span class="type">JwtToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JwtToken</span>(authorization);</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * isAccessAllowed()方法返回false，会进入该方法，表示拒绝访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">onAccessDenied</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">httpResponse</span> <span class="operator">=</span> WebUtils.toHttp(servletResponse);</span><br><span class="line">        httpResponse.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        httpResponse.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">        httpResponse.setStatus(HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> httpResponse.getWriter();</span><br><span class="line">        writer.write(<span class="string">&quot;&#123;\&quot;errCode\&quot;: 401, \&quot;msg\&quot;: \&quot;UNAUTHORIZED\&quot;&#125;&quot;</span>);</span><br><span class="line">        fillCorsHeader(WebUtils.toHttp(servletRequest), httpResponse);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shiro 利用 JWT token 登录成功，会进入该方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">onLoginSuccess</span><span class="params">(AuthenticationToken token, Subject subject, ServletRequest request,</span></span><br><span class="line"><span class="params">                                     ServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">httpResponse</span> <span class="operator">=</span> WebUtils.toHttp(response);</span><br><span class="line">        <span class="type">String</span> <span class="variable">newToken</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (token <span class="keyword">instanceof</span> JwtToken) &#123;</span><br><span class="line">            newToken = JwtUtils.refreshTokenExpired(token.getCredentials().toString(), JwtUtils.SECRET);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newToken != <span class="literal">null</span>)</span><br><span class="line">            httpResponse.setHeader(JwtUtils.AUTH_HEADER, newToken);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shiro 利用 JWT token 登录失败，会进入该方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">onLoginFailure</span><span class="params">(AuthenticationToken token, AuthenticationException e, ServletRequest request,</span></span><br><span class="line"><span class="params">                                     ServletResponse response)</span> &#123;</span><br><span class="line">        <span class="comment">// 此处直接返回 false ，交给后面的  onAccessDenied()方法进行处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加跨域支持</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">fillCorsHeader</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> &#123;</span><br><span class="line">        httpServletResponse.setHeader(<span class="string">&quot;Access-control-Allow-Origin&quot;</span>, httpServletRequest.getHeader(<span class="string">&quot;Origin&quot;</span>));</span><br><span class="line">        httpServletResponse.setHeader(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;GET,POST,OPTIONS,HEAD&quot;</span>);</span><br><span class="line">        httpServletResponse.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>,</span><br><span class="line">                httpServletRequest.getHeader(<span class="string">&quot;Access-Control-Request-Headers&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>定义 JWT token</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtToken</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationToken</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加密后的 JWT token串</span></span><br><span class="line">    <span class="keyword">private</span> String token;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JwtToken</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.token = token;</span><br><span class="line">        <span class="built_in">this</span>.userName = JwtUtils.getClaimFiled(token, <span class="string">&quot;username&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getPrincipal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getCredentials</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>定义 JWT Realm</p>
<p>定义认证方法和授权方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtRealm</span>  <span class="keyword">extends</span> <span class="title class_">AuthorizingRealm</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 限定这个 Realm 只处理我们自定义的 JwtToken</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(AuthenticationToken token)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> token <span class="keyword">instanceof</span> JwtToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此处的 SimpleAuthenticationInfo 可返回任意值，密码校验时不会用到它</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authcToken)</span></span><br><span class="line">            <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        <span class="type">JwtToken</span> <span class="variable">jwtToken</span> <span class="operator">=</span> (JwtToken) authcToken;</span><br><span class="line">        <span class="keyword">if</span> (jwtToken.getPrincipal() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AccountException</span>(<span class="string">&quot;JWT token参数异常！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从 JwtToken 中获取当前用户</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> jwtToken.getPrincipal().toString();</span><br><span class="line">        <span class="comment">// 查询数据库获取用户信息，此处使用 Map 来模拟数据库</span></span><br><span class="line">        <span class="type">UserEntity</span> <span class="variable">user</span> <span class="operator">=</span> ShiroRealm.userMap.get(username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用户不存在</span></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnknownAccountException</span>(<span class="string">&quot;用户不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用户被锁定</span></span><br><span class="line">        <span class="keyword">if</span> (user.getLocked()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LockedAccountException</span>(<span class="string">&quot;该用户已被锁定,暂时无法登录！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">SimpleAuthenticationInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthenticationInfo</span>(user, username, getName());</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthorizationInfo <span class="title function_">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前用户</span></span><br><span class="line">        <span class="type">UserEntity</span> <span class="variable">currentUser</span> <span class="operator">=</span> (UserEntity) SecurityUtils.getSubject().getPrincipal();</span><br><span class="line">        <span class="comment">// UserEntity currentUser = (UserEntity) principals.getPrimaryPrincipal();</span></span><br><span class="line">        <span class="comment">// 查询数据库，获取用户的角色信息</span></span><br><span class="line">        Set&lt;String&gt; roles = ShiroRealm.roleMap.get(currentUser.getName());</span><br><span class="line">        <span class="comment">// 查询数据库，获取用户的权限信息</span></span><br><span class="line">        Set&lt;String&gt; perms = ShiroRealm.permMap.get(currentUser.getName());</span><br><span class="line">        <span class="type">SimpleAuthorizationInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthorizationInfo</span>();</span><br><span class="line">        info.setRoles(roles);</span><br><span class="line">        info.setStringPermissions(perms);</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>定义 JWT creadentialsMatcher</p>
<p>验证 token 是否合法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtCredentialsMatcher</span>  <span class="keyword">implements</span> <span class="title class_">CredentialsMatcher</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JwtCredentialsMatcher只需验证JwtToken内容是否合法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doCredentialsMatch</span><span class="params">(AuthenticationToken authenticationToken, AuthenticationInfo authenticationInfo)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> authenticationToken.getCredentials().toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> authenticationToken.getPrincipal().toString();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Algorithm</span> <span class="variable">algorithm</span> <span class="operator">=</span> Algorithm.HMAC256(JwtUtils.SECRET);</span><br><span class="line">            <span class="type">JWTVerifier</span> <span class="variable">verifier</span> <span class="operator">=</span> JWT.require(algorithm).withClaim(<span class="string">&quot;username&quot;</span>, username).build();</span><br><span class="line">            verifier.verify(token);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JWTVerificationException e) &#123;</span><br><span class="line">            log.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>将 JWT 配置到 shiro 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiroConfig</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交由 Spring 来自动地管理 Shiro-Bean 的生命周期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LifecycleBeanPostProcessor <span class="title function_">getLifecycleBeanPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LifecycleBeanPostProcessor</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为 Spring-Bean 开启对 Shiro 注解的支持</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthorizationAttributeSourceAdvisor <span class="title function_">authorizationAttributeSourceAdvisor</span><span class="params">(SecurityManager securityManager)</span> &#123;</span><br><span class="line">        <span class="type">AuthorizationAttributeSourceAdvisor</span> <span class="variable">authorizationAttributeSourceAdvisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthorizationAttributeSourceAdvisor</span>();</span><br><span class="line">        authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);</span><br><span class="line">        <span class="keyword">return</span> authorizationAttributeSourceAdvisor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DefaultAdvisorAutoProxyCreator <span class="title function_">defaultAdvisorAutoProxyCreator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DefaultAdvisorAutoProxyCreator</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultAdvisorAutoProxyCreator</span>();</span><br><span class="line">        app.setProxyTargetClass(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> app;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不向 Spring容器中注册 JwtFilter Bean，防止 Spring 将 JwtFilter 注册为全局过滤器</span></span><br><span class="line"><span class="comment">     * 全局过滤器会对所有请求进行拦截，而本例中只需要拦截除 /login 和 /logout 外的请求</span></span><br><span class="line"><span class="comment">     * 另一种简单做法是：直接去掉 jwtFilter()上的 <span class="doctag">@Bean</span> 注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FilterRegistrationBean&lt;Filter&gt; <span class="title function_">registration</span><span class="params">(JwtFilter filter)</span> &#123;</span><br><span class="line">        FilterRegistrationBean&lt;Filter&gt; registration = <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>&lt;Filter&gt;(filter);</span><br><span class="line">        registration.setEnabled(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> registration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JwtFilter <span class="title function_">jwtFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JwtFilter</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置访问资源需要的权限</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    ShiroFilterFactoryBean <span class="title function_">shiroFilterFactoryBean</span><span class="params">(SecurityManager securityManager)</span> &#123;</span><br><span class="line">        <span class="type">ShiroFilterFactoryBean</span> <span class="variable">shiroFilterFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShiroFilterFactoryBean</span>();</span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line">        shiroFilterFactoryBean.setLoginUrl(<span class="string">&quot;/login&quot;</span>);</span><br><span class="line">        shiroFilterFactoryBean.setSuccessUrl(<span class="string">&quot;/authorized&quot;</span>);</span><br><span class="line">        shiroFilterFactoryBean.setUnauthorizedUrl(<span class="string">&quot;/unauthorized&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加 jwt 专用过滤器，拦截除 /login 和 /logout 外的请求</span></span><br><span class="line">        Map&lt;String, Filter&gt; filterMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        filterMap.put(<span class="string">&quot;jwtFilter&quot;</span>, jwtFilter());</span><br><span class="line">        shiroFilterFactoryBean.setFilters(filterMap);</span><br><span class="line"></span><br><span class="line">        LinkedHashMap&lt;String, String&gt; filterChainDefinitionMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String, String&gt;();</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/login&quot;</span>, <span class="string">&quot;anon&quot;</span>); <span class="comment">// 可匿名访问</span></span><br><span class="line"><span class="comment">//        filterChainDefinitionMap.put(&quot;/logout&quot;, &quot;logout&quot;); // 退出登录</span></span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/**&quot;</span>, <span class="string">&quot;jwtFilter,authc&quot;</span>); <span class="comment">// 需登录才能访问</span></span><br><span class="line">        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);</span><br><span class="line">        <span class="keyword">return</span> shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置 ModularRealmAuthenticator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ModularRealmAuthenticator <span class="title function_">authenticator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ModularRealmAuthenticator</span> <span class="variable">authenticator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MultiRealmAuthenticator</span>();</span><br><span class="line">        <span class="comment">// 设置多 Realm的认证策略，默认 AtLeastOneSuccessfulStrategy</span></span><br><span class="line">        <span class="type">AuthenticationStrategy</span> <span class="variable">strategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FirstSuccessfulStrategy</span>();</span><br><span class="line">        authenticator.setAuthenticationStrategy(strategy);</span><br><span class="line">        <span class="keyword">return</span> authenticator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 禁用session, 不保存用户登录状态。保证每次请求都重新认证</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">protected</span> SessionStorageEvaluator <span class="title function_">sessionStorageEvaluator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DefaultSessionStorageEvaluator</span> <span class="variable">sessionStorageEvaluator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultSessionStorageEvaluator</span>();</span><br><span class="line">        sessionStorageEvaluator.setSessionStorageEnabled(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> sessionStorageEvaluator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JwtRealm 配置，需实现 Realm 接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    JwtRealm <span class="title function_">jwtRealm</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">JwtRealm</span> <span class="variable">jwtRealm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JwtRealm</span>();</span><br><span class="line">        <span class="comment">// 设置加密算法</span></span><br><span class="line">        <span class="type">CredentialsMatcher</span> <span class="variable">credentialsMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JwtCredentialsMatcher</span>();</span><br><span class="line">        <span class="comment">// 设置加密次数</span></span><br><span class="line">        jwtRealm.setCredentialsMatcher(credentialsMatcher);</span><br><span class="line">        <span class="keyword">return</span> jwtRealm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ShiroRealm 配置，需实现 Realm 接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    ShiroRealm <span class="title function_">shiroRealm</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ShiroRealm</span> <span class="variable">shiroRealm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShiroRealm</span>();</span><br><span class="line">        <span class="comment">// 设置加密算法</span></span><br><span class="line">        <span class="type">HashedCredentialsMatcher</span> <span class="variable">credentialsMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashedCredentialsMatcher</span>(<span class="string">&quot;SHA-1&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置加密次数</span></span><br><span class="line">        credentialsMatcher.setHashIterations(<span class="number">16</span>);</span><br><span class="line">        shiroRealm.setCredentialsMatcher(credentialsMatcher);</span><br><span class="line">        <span class="keyword">return</span> shiroRealm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置 SecurityManager</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityManager <span class="title function_">securityManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DefaultWebSecurityManager</span> <span class="variable">securityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultWebSecurityManager</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.Authenticator</span></span><br><span class="line">        securityManager.setAuthenticator(authenticator());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.Realm</span></span><br><span class="line">        List&lt;Realm&gt; realms = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Realm&gt;(<span class="number">16</span>);</span><br><span class="line">        realms.add(jwtRealm());</span><br><span class="line">        realms.add(shiroRealm());</span><br><span class="line">        securityManager.setRealms(realms);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.关闭shiro自带的session</span></span><br><span class="line">        <span class="type">DefaultSubjectDAO</span> <span class="variable">subjectDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultSubjectDAO</span>();</span><br><span class="line">        subjectDAO.setSessionStorageEvaluator(sessionStorageEvaluator());</span><br><span class="line">        securityManager.setSubjectDAO(subjectDAO);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="JWT-注意事项"><a href="#JWT-注意事项" class="headerlink" title="JWT 注意事项"></a>JWT 注意事项</h3><ol>
<li><p>JWT token 一次签发，永久有效，退出token依然有效，失效只能等到超过有效期，使用subject.logout 只会执行删除session之类的操作，并没有进行token的销毁，使用token依然可以正常访问</p>
<p>解决思路</p>
<ol>
<li>退出时将退出的token保存到redis中，作为黑名单</li>
<li>在token中保存生成时间，并将生成时间保存到redis中，两个生成时间相同则表示登录，否则表示退出</li>
</ol>
<p>都破坏了无状态，相当于在redis中保存了sessionId</p>
</li>
</ol>
<p><a href="https://github.com/idream68/spring-demo/tree/master/shiro_jwt">完整代码示例</a></p>
]]></content>
      <categories>
        <category>spring</category>
        <category>springboot</category>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>shiro</tag>
        <tag>jwt</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro 基础</title>
    <url>/2021/06/15/spring/springboot/shiro/shiro-base/</url>
    <content><![CDATA[<p>三个核心组件：Subject, SecurityManager 和 Realms.</p>
<p>Subject：即“当前操作用户”。但是，在Shiro中，Subject这一概念并不仅仅指人，也可以是第三方进程、后台帐户（Daemon Account）或其他类似事物。它仅仅意味着“当前跟软件交互的东西”。但考虑到大多数目的和用途，你可以把它认为是Shiro的“用户”概念。 Subject代表了当前用户的安全操作，SecurityManager则管理所有用户的安全操作。</p>
<p>SecurityManager：它是Shiro框架的核心，典型的Facade模式，Shiro通过SecurityManager来管理内部组件实例，并通过它来提供安全管理的各种服务。</p>
<p>Realm： Realm充当了Shiro与应用安全数据间的“桥梁”或者“连接器”。也就是说，当对用户执行认证（登录）和授权（访问控制）验证时，Shiro会从应用配置的Realm中查找用户及其权限信息。 从这个意义上讲，Realm实质上是一个安全相关的DAO：它封装了数据源的连接细节，并在需要时将相关数据提供给Shiro。当配置Shiro时，你必须至少指定一个Realm，用于认证和（或）授权。配置多个Realm是可以的，但是至少需要一个。 Shiro内置了可以连接大量安全数据源（又名目录）的Realm，如LDAP、关系数据库（JDBC）、类似INI的文本配置资源以及属性文件等。如果缺省的Realm不能满足需求，你还可以插入代表自定义数据源的自己的Realm实现。</p>
<p>细分功能</p>
<ol>
<li>Authentication：身份认证&#x2F;登录(账号密码验证)。</li>
<li>Authorization：授权，即角色或者权限验证。</li>
<li>Session Manager：会话管理，用户登录后的session相关管理。</li>
<li>Cryptography：加密，密码加密等。</li>
<li>Web Support：Web支持，集成Web环境。</li>
<li>Caching：缓存，用户信息、角色、权限等缓存到如redis等缓存中。</li>
<li>Concurrency：多线程并发验证，在一个线程中开启另一个线程，可以把权限自动传播过去。</li>
<li>Testing：测试支持；</li>
<li>Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问。</li>
<li>Remember Me：记住我，登录后，下次再来的话不用登录了。</li>
</ol>
<p><a href="https://shiro.apache.org/architecture.html">以下引用官网介绍</a></p>
<blockquote>
<p>The following diagram shows Shiro’s core architectural concepts followed by short summaries of each:</p>
<p><img src="/images/shiro/ShiroArchitecture.png" alt="images"></p>
<ul>
<li>Subject (org.apache.shiro.subject.Subject)</li>
</ul>
<p>A security-specific ‘view’ of the entity (user, 3rd-party service, cron job, etc) currently interacting with the software.</p>
<ul>
<li>SecurityManager (org.apache.shiro.mgt.SecurityManager)</li>
</ul>
<p>As mentioned above, the SecurityManager is the heart of Shiro’s architecture. It is mostly an ‘umbrella’ object that coordinates its managed components to ensure they work smoothly together. It also manages Shiro’s view of every application user, so it knows how to perform security operations per user.</p>
<ul>
<li>Authenticator (org.apache.shiro.authc.Authenticator)</li>
</ul>
<p>The Authenticator is the component that is responsible for executing and reacting to authentication (log-in) attempts by users. When a user tries to log-in, that logic is executed by the Authenticator. The Authenticator knows how to coordinate with one or more Realms that store relevant user&#x2F;account information. The data obtained from these Realms is used to verify the user’s identity to guarantee the user really is who they say they are.</p>
<ul>
<li>Authentication Strategy (org.apache.shiro.authc.pam.AuthenticationStrategy)</li>
</ul>
<p>If more than one Realm is configured, the AuthenticationStrategy will coordinate the Realms to determine the conditions under which an authentication attempt succeeds or fails (for example, if one realm succeeds but others fail, is the attempt successful? Must all realms succeed? Only the first?).</p>
<ul>
<li>Authorizer (org.apache.shiro.authz.Authorizer)</li>
</ul>
<p>The Authorizer is the component responsible determining users’ access control in the application. It is the mechanism that ultimately says if a user is allowed to do something or not. Like the Authenticator, the Authorizer also knows how to coordinate with multiple back-end data sources to access role and permission information. The Authorizer uses this information to determine exactly if a user is allowed to perform a given action.</p>
<ul>
<li>SessionManager (org.apache.shiro.session.mgt.SessionManager)</li>
</ul>
<p>The SessionManager knows how to create and manage user Session lifecycles to provide a robust Session experience for users in all environments. This is a unique feature in the world of security frameworks - Shiro has the ability to natively manage user Sessions in any environment, even if there is no Web&#x2F;Servlet or EJB container available. By default, Shiro will use an existing session mechanism if available, (e.g. Servlet Container), but if there isn’t one, such as in a standalone application or non-web environment, it will use its built-in enterprise session management to offer the same programming experience. The SessionDAO exists to allow any datasource to be used to persist sessions.</p>
<ul>
<li>SessionDAO (org.apache.shiro.session.mgt.eis.SessionDAO)</li>
</ul>
<p>The SessionDAO performs Session persistence (CRUD) operations on behalf of the SessionManager. This allows any data store to be plugged in to the Session Management infrastructure.</p>
<ul>
<li>CacheManager (org.apache.shiro.cache.CacheManager) The CacheManager creates and manages Cache instance lifecycles used by other Shiro components. Because Shiro can access many back-end data sources for authentication, authorization and session management, caching has always been a first-class architectural feature in the framework to improve performance while using these data sources. Any of the modern open-source and&#x2F;or enterprise caching products can be plugged in to Shiro to provide a fast and efficient user-experience.</li>
<li>Cryptography (org.apache.shiro.crypto.*)</li>
</ul>
<p>Cryptography is a natural addition to an enterprise security framework. Shiro’s crypto package contains easy-to-use and understand representations of crytographic Ciphers, Hashes (aka digests) and different codec implementations. All of the classes in this package are carefully designed to be very easy to use and easy to understand. Anyone who has used Java’s native cryptography support knows it can be a challenging animal to tame. Shiro’s crypto APIs simplify the complicated Java mechanisms and make cryptography easy to use for normal mortal human beings.</p>
<ul>
<li>Realms (org.apache.shiro.realm.Realm)</li>
</ul>
<p>As mentioned above, Realms act as the ‘bridge’ or ‘connector’ between Shiro and your application’s security data. When it comes time to actually interact with security-related data like user accounts to perform authentication (login) and authorization (access control), Shiro looks up many of these things from one or more Realms configured for an application. You can configure as many Realms as you need (usually one per data source) and Shiro will coordinate with them as necessary for both authentication and authorization.</p>
</blockquote>
<p>过滤器说明</p>
<table>
<thead>
<tr>
<th align="center">过滤器</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">anon</td>
<td align="center">表示可以匿名使用</td>
</tr>
<tr>
<td align="center">authc</td>
<td align="center">表示需要认证(登录)才能使用</td>
</tr>
<tr>
<td align="center">authcBasic</td>
<td align="center">表示httpBasic认证</td>
</tr>
<tr>
<td align="center">perms</td>
<td align="center">当有多个参数时必须每个参数都通过才通过 perms[“user:add:”]</td>
</tr>
<tr>
<td align="center">port</td>
<td align="center">port[8081] 跳转到schemal:&#x2F;&#x2F;serverName:8081?queryString</td>
</tr>
<tr>
<td align="center">rest</td>
<td align="center">权限</td>
</tr>
<tr>
<td align="center">roles</td>
<td align="center">角色</td>
</tr>
<tr>
<td align="center">ssl</td>
<td align="center">表示安全的url请求</td>
</tr>
<tr>
<td align="center">user</td>
<td align="center">表示必须存在用户，当登入操作时不做检查</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">自定义</td>
</tr>
</tbody></table>
<p><a href="https://github.com/idream68/spring-demo/tree/master/shiro_base">代码示例</a></p>
]]></content>
      <categories>
        <category>spring</category>
        <category>springboot</category>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>java thread interrupt 方法概述</title>
    <url>/2021/06/08/java/multiThread/java-thread-interrupt/</url>
    <content><![CDATA[<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>中断（Interrupt）一个线程意味着在该线程完成任务之前停止其正在进行的一切，有效地中止其当前的操作。线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序。虽然初次看来它可能显得简单，但是，你必须进行一些预警以实现期望的结果</p>
<p>在java中，想要安全让一个线程停下来：<br>(1)采用退出标志，使得run方法执行完之后线程自然终止。<br>(2)使用中断机制。</p>
<h4 id="退出标志位"><a href="#退出标志位" class="headerlink" title="退出标志位"></a>退出标志位</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">exit</span> <span class="operator">=</span><span class="literal">false</span>;  <span class="comment">//退出标志</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程启动了&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span> (!exit) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程结束了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span> * <span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        exit = <span class="literal">true</span>;<span class="comment">//5秒后更改退出标志的值,没有这段代码，线程就一直不能停止</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h4><p>代码详见：<a href="https://github.com/idream68/java-demo/blob/master/src/main/java/com/demo/java/multi_thread/ThreadStop.java">https://github.com/idream68/java-demo/blob/master/src/main/java/com/demo/java/multi_thread/ThreadStop.java</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>java锁</title>
    <url>/2021/05/24/java/multiThread/java-lock/</url>
    <content><![CDATA[<blockquote>
<p>作者：<a href="https://www.cnblogs.com/jyroy/">JYRoy</a></p>
<p>出处：<a href="https://www.cnblogs.com/jyroy/p/11365935.html">https://www.cnblogs.com/jyroy/p/11365935.html</a></p>
</blockquote>
<p>Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码（本文中的源码来自JDK 8）、使用场景进行举例，为读者介绍主流锁的知识点，以及不同的锁的适用场景。</p>
<p>Java中往往是按照是否含有某一特性来定义锁，我们通过特性将锁进行分组归类，再使用对比的方式进行介绍，帮助大家更快捷的理解相关知识。下面给出本文内容的总体分类目录：</p>
<p><img src="/images/java-lock/java-lock-1.png" alt="images"></p>
<h1 id="乐观锁-VS-悲观锁"><a href="#乐观锁-VS-悲观锁" class="headerlink" title="乐观锁 VS 悲观锁"></a>乐观锁 VS 悲观锁</h1><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。</p>
<p>先说概念。对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。</p>
<p>而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。</p>
<p>乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</p>
<p><img src="/images/java-lock/java-lock-2.png" alt="images"></p>
<p>根据从上面的概念描述我们可以发现：</p>
<ul>
<li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</li>
<li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</li>
</ul>
<p>光说概念有些抽象，我们来看下乐观锁和悲观锁的调用方式示例：</p>
<p><img src="/images/java-lock/java-lock-3.png" alt="images"></p>
<p>通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？我们通过介绍乐观锁的主要实现方式 “CAS” 的技术原理来为大家解惑。</p>
<p>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。</p>
<p>CAS算法涉及到三个操作数：</p>
<ul>
<li>需要读写的内存值 V。</li>
<li>进行比较的值 A。</li>
<li>要写入的新值 B。</li>
</ul>
<p>当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p>
<p>之前提到java.util.concurrent包中的原子类，就是通过CAS来实现了乐观锁，那么我们进入原子类AtomicInteger的源码，看一下AtomicInteger的定义：</p>
<p><img src="/images/java-lock/java-lock-4.png" alt="images"></p>
<p>根据定义我们可以看出各属性的作用：</p>
<ul>
<li>unsafe： 获取并操作内存的数据。</li>
<li>valueOffset： 存储value在AtomicInteger中的偏移量。</li>
<li>value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。</li>
</ul>
<p>接下来，我们查看AtomicInteger的自增函数incrementAndGet()的源码时，发现自增函数底层调用的是unsafe.getAndAddInt()。但是由于JDK本身只有Unsafe.class，只通过class文件中的参数名，并不能很好的了解方法的作用，所以我们通过OpenJDK 8 来查看Unsafe的源码：</p>
<p><img src="/images/java-lock/java-lock-5.png" alt="images"></p>
<p>根据OpenJDK 8的源码我们可以看出，getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。</p>
<p>后续JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。</p>
<p>CAS虽然很高效，但是它也存在三大问题，这里也简单说一下：</p>
<ol>
<li>ABA问题。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。</li>
</ol>
<p>JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</p>
<ol start="2">
<li><p>循环时间长开销大。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</p>
</li>
<li><p>只能保证一个共享变量的原子操作。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。</p>
</li>
</ol>
<p>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</p>
<h1 id="自旋锁-VS-适应性自旋锁"><a href="#自旋锁-VS-适应性自旋锁" class="headerlink" title="自旋锁 VS 适应性自旋锁"></a>自旋锁 VS 适应性自旋锁</h1><p>在介绍自旋锁前，我们需要介绍一些前提知识来帮助大家明白自旋锁的概念。</p>
<p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>
<p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p>
<p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p>
<p><img src="/images/java-lock/java-lock-6.png" alt="images"></p>
<p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p>
<p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p>
<p><img src="/images/java-lock/java-lock-7.png" alt="images"></p>
<p>自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p>
<p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
<p>在自旋锁中 另有三种常见的锁形式:TicketLock、CLHlock和MCSlock，本文中仅做名词介绍，不做深入讲解，感兴趣的同学可以自行查阅相关资料。</p>
<h2 id="无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁"><a href="#无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁" class="headerlink" title="无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁"></a>无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h2><p>这四种锁是指锁的状态，专门针对synchronized的。在介绍这四种锁状态之前还需要介绍一些额外的知识。</p>
<p>首先为什么Synchronized能实现线程同步？</p>
<p>在回答这个问题之前我们需要了解两个重要的概念：“Java对象头”、“Monitor”。</p>
<p>Java对象头</p>
<p>synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？</p>
<p>我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。</p>
<p>Mark Word：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p>
<p>Klass Point：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<p>Monitor</p>
<p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。</p>
<p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p>
<p>现在话题回到synchronized，synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p>
<p>如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p>
<p>所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。</p>
<p>通过上面的介绍，我们对synchronized的加锁机制以及相关知识有了一个了解，那么下面我们给出四种锁状态对应的的Mark Word内容，然后再分别讲解四种锁状态的思路以及特点：</p>
<p><img src="/images/java-lock/java-lock-8.png" alt="images"></p>
<h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p>
<p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p>
<p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p>
<p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p>
<p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p>
<p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking&#x3D;false，关闭之后程序默认会进入轻量级锁状态。</p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p>
<p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p>
<p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p>
<p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p>
<p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p>
<p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p>
<h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p>
<p>整体的锁状态升级流程如下：</p>
<p><img src="/images/java-lock/java-lock-9.png" alt="images"></p>
<p>综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p>
<h1 id="公平锁-VS-非公平锁"><a href="#公平锁-VS-非公平锁" class="headerlink" title="公平锁 VS 非公平锁"></a>公平锁 VS 非公平锁</h1><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p>
<p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p>
<p>直接用语言描述可能有点抽象，这里作者用从别处看到的一个例子来讲述一下公平锁和非公平锁。</p>
<p><img src="/images/java-lock/java-lock-10.png" alt="images"></p>
<p>如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。</p>
<p>但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示：</p>
<p><img src="/images/java-lock/java-lock-11.png" alt="images"></p>
<p>接下来我们通过ReentrantLock的源码来讲解公平锁和非公平锁。<img src="/images/java-lock/java-lock-12.png" alt="images"></p>
<p>根据代码可知，ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁FairSync和非公平锁NonfairSync两个子类。ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。</p>
<p>下面我们来看一下公平锁与非公平锁的加锁方法的源码:</p>
<p><img src="/images/java-lock/java-lock-13.png" alt="images"></p>
<p>通过上图中的源代码对比，我们可以明显的看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。</p>
<p><img src="/images/java-lock/java-lock-14.png" alt="images"></p>
<p>再进入hasQueuedPredecessors()，可以看到该方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。</p>
<p>综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。</p>
<h1 id="可重入锁-VS-非可重入锁"><a href="#可重入锁-VS-非可重入锁" class="headerlink" title="可重入锁 VS 非可重入锁"></a>可重入锁 VS 非可重入锁</h1><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析：</p>
<p><img src="/images/java-lock/java-lock-15.png" alt="images"></p>
<p>在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。</p>
<p>如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p>
<p>而为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？我们通过图示和源码来分别解析一下。</p>
<p>还是打水的例子，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。</p>
<p><img src="/images/java-lock/java-lock-16.png" alt="images"></p>
<p>但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。</p>
<p><img src="/images/java-lock/java-lock-17.png" alt="images"></p>
<p>之前我们说过ReentrantLock和synchronized都是重入锁，那么我们通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。</p>
<p>首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。</p>
<p>当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status &#x3D;&#x3D; 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status !&#x3D; 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status !&#x3D; 0的话会导致其获取锁失败，当前线程阻塞。</p>
<p>释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 &#x3D;&#x3D; 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。</p>
<p><img src="/images/java-lock/java-lock-18.png" alt="images"></p>
<h1 id="独享锁-VS-共享锁"><a href="#独享锁-VS-共享锁" class="headerlink" title="独享锁 VS 共享锁"></a>独享锁 VS 共享锁</h1><p>独享锁和共享锁同样是一种概念。我们先介绍一下具体的概念，然后通过ReentrantLock和ReentrantReadWriteLock的源码来介绍独享锁和共享锁。</p>
<p>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。</p>
<p>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p>
<p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p>
<p>下图为ReentrantReadWriteLock的部分源码：</p>
<p><img src="/images/java-lock/java-lock-19.png" alt="images"></p>
<p>我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。</p>
<p>在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。</p>
<p>那读锁和写锁的具体加锁方式有什么区别呢？在了解源码之前我们需要回顾一下其他知识。</p>
<p>在最开始提及AQS的时候我们也提到了state字段（int类型，32位），该字段用来描述有多少线程获持有锁。</p>
<p>在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数），在共享锁中state就是持有锁的数量。但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。如下图所示：</p>
<p><img src="/images/java-lock/java-lock-20.png" alt="images"></p>
<p>了解了概念之后我们再来看代码，先看写锁的加锁源码：</p>
<p><img src="/images/java-lock/java-lock-21.png" alt="images"></p>
<ul>
<li>这段代码首先取到当前锁的个数c，然后再通过c来获取写锁的个数w。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（ int w &#x3D; exclusiveCount(c); ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。</li>
<li>在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁（c!&#x3D;0），则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。</li>
<li>如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</li>
<li>如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!&#x3D;0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败。</li>
<li>如果c&#x3D;0，w&#x3D;0或者c&gt;0，w&gt;0（重入），则设置当前线程或锁的拥有者，返回成功！</li>
</ul>
<p>tryAcquire()除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：必须确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。</p>
<p>因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。</p>
<p>接着是读锁的代码：</p>
<p><img src="/images/java-lock/java-lock-22.png" alt="images"></p>
<p>可以看到在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1&lt;&lt;16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。</p>
<p>此时，我们再回头看一下互斥锁ReentrantLock中公平锁和非公平锁的加锁源码：</p>
<p><img src="/images/java-lock/java-lock-23.png" alt="images"></p>
<p>我们发现在ReentrantLock虽然有公平锁和非公平锁两种，但是它们添加的都是独享锁。根据源码所示，当某一个线程调用lock方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程在使用CAS更新state成功后就会成功抢占该资源。而如果公共资源被占用且不是被当前线程占用，那么就会加锁失败。所以可以确定ReentrantLock无论读操作还是写操作，添加的锁都是都是独享锁。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>锁</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>java 多线程</title>
    <url>/2021/05/24/java/multiThread/java-multi-thread/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p> 提到线程不得不提进程。因为线程是进程的一个执行单元。下面对线程和进程分别进行介绍。</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p> 进程是当前操作系统执行的任务，是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竟争计算机系统资源的基本单位。一般而言，现在的操作系统都是多进程的。</p>
<p>  <strong>进程的执行过程是线状的</strong>， 尽管中间会发生中断或暂停，但该进程所拥有的资源只为该线状执行过程服务。一旦发生进程上下文切换，这些资源都是要被保护起来的。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p> 线程，是进程的一部分，一个没有线程的进程可以被看作是单线程的。即：每个进程中至少包含一个线程。</p>
<p>线程本身是在CPU上执行的，CPU的每一个核在同一时刻只能执行一个线程，但CPU在底层会对线程进行快速的轮询切换。</p>
<h1 id="JAVA中如何定义线程"><a href="#JAVA中如何定义线程" class="headerlink" title="JAVA中如何定义线程"></a>JAVA中如何定义线程</h1><h2 id="继承Thread"><a href="#继承Thread" class="headerlink" title="继承Thread"></a>继承Thread</h2><p>通过继承Thread，重写run方法，将要执行的逻辑放在run方法中，然后创建线程对象调用start方法来开启线程。示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">TDemo</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TDemo</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        <span class="comment">// start方法中会给线程做很多的配置</span></span><br><span class="line">        <span class="comment">// 配置完成之后会自动调用run方法执行指定的任务</span></span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">// t1.run();</span></span><br><span class="line">        <span class="type">TDemo</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TDemo</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// t2.run();</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TDemo</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印0-9</span></span><br><span class="line">    <span class="comment">// 线程要执行的任务就是放在这个方法中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承Runnable"><a href="#继承Runnable" class="headerlink" title="继承Runnable"></a>继承Runnable</h2><p>实现Runnable，重写run方法，然后利用Runnable对象来构建Thread对象，调用start方法来启动线程。示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">RDemo</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RDemo</span>();</span><br><span class="line">        <span class="comment">// 包装 - 装饰设计模式</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现Callable"><a href="#实现Callable" class="headerlink" title="实现Callable"></a>实现Callable<T></h2><p>实现Callable<T>，重写call方法，通过线程池定义线程。示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">CDemo</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CDemo</span>();</span><br><span class="line">        <span class="comment">// 执行器服务 执行器助手</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        Future&lt;String&gt; f = es.submit(c);</span><br><span class="line">        System.out.println(f.get());</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型表示要的结果类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CDemo</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SUCCESS&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="多线程的并发安全问题"><a href="#多线程的并发安全问题" class="headerlink" title="多线程的并发安全问题"></a>多线程的并发安全问题</h1><p>线程之间是相互抢占执行，而且抢占是发生在线程执行的每一步；当线程重新抢回执行权之后，会沿着上次被抢占位置继续向下执行，而不是从头开始执行。</p>
<p>由于线程的抢占而导致出现了不合理的数据的现象：多线程的并发安全问题。</p>
<h1 id="线程中的锁机制"><a href="#线程中的锁机制" class="headerlink" title="线程中的锁机制"></a>线程中的锁机制</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>为了解决线程并发问题，引入了synchronized代码块，亦即同步代码块。同步代码块需要一个锁对象。</p>
<h2 id="锁对象及其特点"><a href="#锁对象及其特点" class="headerlink" title="锁对象及其特点"></a>锁对象及其特点</h2><p>锁对象要求被当前的所有线程都认识。共享资源，方法去中的资源和this都可以作为锁对象。</p>
<p>当使用this作为锁对象的时候，要求利用同一个Runnable对象来构建不同的Thread对象。</p>
<p>示例如下：利用多线程实现卖票机制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用多线程机制模拟卖票场景</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicketDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 利用properties做到改动数量但是不用改动代码的效果</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        prop.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;ticket.properties&quot;</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> Integer.parseInt(prop.getProperty(<span class="string">&quot;count&quot;</span>));</span><br><span class="line">        <span class="comment">// 利用ticket对象做到所有的线程共享一个对象</span></span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line">        t.setCount(count);</span><br><span class="line">        <span class="comment">// 表示四个售票员在分别卖票</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Seller</span>(t), <span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Seller</span>(t), <span class="string">&quot;B&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Seller</span>(t), <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Seller</span>(t), <span class="string">&quot;D&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了线程类表示售票员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Seller</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Ticket t;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Seller</span><span class="params">(Ticket t)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 锁对象 --- 需要指定一个对象作为锁来使用</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 由于所有的Seller线程都在卖票t，所以t是被所有线程都认识的</span></span><br><span class="line">            <span class="comment">// synchronized (t) &#123;</span></span><br><span class="line">            <span class="comment">// 由于所有的Seller线程都是Seller类产生的，所以Seller类也是被所有线程都认识的</span></span><br><span class="line">            <span class="comment">// synchronized (Seller.class) &#123;</span></span><br><span class="line">            <span class="comment">// synchronized (Thread.class) &#123;</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="string">&quot;abc&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.getCount() &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 让当前线程陷入休眠</span></span><br><span class="line">                    <span class="comment">// 时间单位是毫秒</span></span><br><span class="line">                    <span class="comment">// 不改变线程的执行结果</span></span><br><span class="line">                    <span class="comment">// 只会把线程的执行时间拉长</span></span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 票数减少1张</span></span><br><span class="line">                t.setCount(t.getCount() - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// currentThread()获取当前在执行的线程</span></span><br><span class="line">                <span class="comment">// 获取线程的名字</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">                System.out.println(name + <span class="string">&quot;卖了一张票，剩余&quot;</span> + t.getCount());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCount</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程的同步和异步"><a href="#线程的同步和异步" class="headerlink" title="线程的同步和异步"></a>线程的同步和异步</h2><p>同步：在同一时刻内资源&#x2F;逻辑只被一个线程占用&#x2F;执行。</p>
<p>异步：在同一时刻内资源&#x2F;逻辑可以被多个线程抢占使用。</p>
<h2 id="多线程死锁"><a href="#多线程死锁" class="headerlink" title="多线程死锁"></a>多线程死锁</h2><p>由于多个线程之间的锁形成了嵌套而导致代码无法继续执行，这种现象称之为死锁。</p>
<p>我们只能尽量避免出现死锁，在实际开发中，会做死锁的检验；如果真的出现了死锁，会根据线程的优先级打破其中一个或者多个锁。</p>
<p>死锁的示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Printer</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Printer</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Scan</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scan</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个员工</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (p) &#123;</span><br><span class="line">                    p.print();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span> (s) &#123;</span><br><span class="line">                        s.scan();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r1).start();</span><br><span class="line">        <span class="comment">// 第二个员工</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (s) &#123;</span><br><span class="line">                    s.scan();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span> (p) &#123;</span><br><span class="line">                        p.print();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表打印机的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打印机在吱呦吱呦的打印~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表扫描仪的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Scan</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scan</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;扫描仪在哼哧哼哧的扫描~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h1><p>Java中将线程的优先级分为1-10共十个等级。</p>
<p>理论上，数字越大优先级越高，那么该线程能抢到资源的概率也就越大；但实际上，相邻的两个优先级之间的差别非常不明显；如果想要相对明显一点，至少要相差5个优先级。</p>
<p>线程优先级示例如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">PDemo</span>(), <span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">PDemo</span>(), <span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在默认情况下，线程的优先级都是5</span></span><br><span class="line">        <span class="comment">// System.out.println(t1.getPriority());</span></span><br><span class="line">        <span class="comment">// System.out.println(t2.getPriority());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置优先级</span></span><br><span class="line">        t1.setPriority(<span class="number">1</span>);</span><br><span class="line">        t2.setPriority(<span class="number">10</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程的等待唤醒机制"><a href="#线程的等待唤醒机制" class="headerlink" title="线程的等待唤醒机制"></a>线程的等待唤醒机制</h1><p>利用标记为以及wait、notify、notifyAll方法来调用线程之间的执行顺序；</p>
<p>wait、notify、notifyAll和锁有关，用那个对象作为锁对象使用，那么就用该锁对象来调用wait、notify。</p>
<p>等待和唤醒示例如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotifyAllDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Supplier2</span>(p)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Supplier2</span>(p)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer2</span>(p)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer2</span>(p)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Supplier2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Product p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Supplier2</span><span class="params">(Product p)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.p = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (p) &#123;</span><br><span class="line">              <span class="comment">//因为线程被抢断后，会沿着停止出继续执行，因为用while循环强制对其进行判断，满足条件时才能执行</span></span><br><span class="line">              <span class="comment">//不满足条件就让其等待</span></span><br><span class="line">                <span class="keyword">while</span> (p.flag == <span class="literal">false</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 让当前线程陷入等待</span></span><br><span class="line">                        p.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 计算本次生产的商品数量</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * <span class="number">1000</span>);</span><br><span class="line">                p.setCount(count);</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者生产了&quot;</span> + count + <span class="string">&quot;件商品~~~&quot;</span>);</span><br><span class="line">                p.flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//当多个线程执行时，要唤醒所有的线程，否则可能连续唤起一个线程，导致程序执行混乱</span></span><br><span class="line">                p.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Product p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer2</span><span class="params">(Product p)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.p = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (p) &#123;</span><br><span class="line">                <span class="keyword">while</span> (p.flag == <span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        p.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> p.getCount();</span><br><span class="line">                p.setCount(<span class="number">0</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者消费了&quot;</span> + count + <span class="string">&quot;件商品~~~&quot;</span>);</span><br><span class="line">                p.flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 唤醒在等待的线程</span></span><br><span class="line">                p.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h1><p>线程从创建到开始消亡一般会经历如下几种状态:</p>
<p><img src="/images/java-multy-thread.png" alt="images"></p>
<h1 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>守护其他的线程被称为守护线程，只要被守护的线程结束，那么守护线程就会随之结束。</p>
<h2 id="守护线程的特点"><a href="#守护线程的特点" class="headerlink" title="守护线程的特点"></a>守护线程的特点</h2><ul>
<li>一个线程要么是守护线程，要么是被守护线程</li>
<li>守护线程可以守护其他的守护线程</li>
<li>在Java中，最常见的一个守护线程是GC</li>
</ul>
<p>守护线程的示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaemonDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Monster</span>(), <span class="string">&quot;小怪1号&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Monster</span>(), <span class="string">&quot;小怪2号&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Monster</span>(), <span class="string">&quot;小怪3号&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Monster</span>(), <span class="string">&quot;小怪4号&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置为守护线程</span></span><br><span class="line">        t1.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        t2.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        t3.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        t4.setDaemon(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Boss掉了一滴血，剩余&quot;</span> + i);</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//守护boss的小怪线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Monster</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1000</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;掉了一滴血，剩余&quot;</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：sleep和wait的区别</p>
<p>sleep：在使用的时候需要指定休眠时间，单位是毫秒，到点自然醒。在无锁状态下，会释放CPU；在有锁状态下，不释放CPU。sleep方法是一个静态方法，被设计在了Thread类上。</p>
<p>wait：可以指定等待时间也可以不指定。如果不指定等待时间则需要被唤醒。wait必须结合锁使用，当线程在wait的时候会释放锁。wait方法设计在了Object类上。</p>
<h1 id="线程产生和结束的场景"><a href="#线程产生和结束的场景" class="headerlink" title="线程产生和结束的场景"></a>线程产生和结束的场景</h1><h2 id="线程产生的场景"><a href="#线程产生的场景" class="headerlink" title="线程产生的场景"></a>线程产生的场景</h2><ul>
<li>系统自启动：开机默认启动的程序；</li>
<li>用户请求：QQ好友聊天；</li>
<li>线程之间的启动：App软件之间带有的插件。</li>
</ul>
<h2 id="线程结束的场景"><a href="#线程结束的场景" class="headerlink" title="线程结束的场景"></a>线程结束的场景</h2><ul>
<li>寿终正寝：线程自然结束</li>
<li>他杀：被其他线程kill </li>
<li>意外：线程因为报错崩溃而退出</li>
</ul>
<h1 id="JAVA虚拟机方法区和线程的关系"><a href="#JAVA虚拟机方法区和线程的关系" class="headerlink" title="JAVA虚拟机方法区和线程的关系"></a>JAVA虚拟机方法区和线程的关系</h1><p>类是存储在方法区中的，方法区是被所有的线程共享的空间。</p>
<p>每一个线程独有一个栈内存。</p>
<p>原文</p>
<p><a href="https://www.cnblogs.com/chhyan-dream/p/10786043.html">https://www.cnblogs.com/chhyan-dream/p/10786043.html</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>java cas 详解</title>
    <url>/2021/05/19/java/multiThread/java-cas/</url>
    <content><![CDATA[<p>日常编码过程中，基本不会直接用到 CAS 操作，都是通过一些JDK 封装好的并发工具类来使用的，在 java.util.concurrent 包下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类的成员变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// main方法内代码</span></span><br><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">2</span>).forEach((i) -&gt; &#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">20</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				IntStream.range(<span class="number">0</span>, <span class="number">100</span>).forEach(y -&gt; &#123;</span><br><span class="line">						data++;</span><br><span class="line">				&#125;);</span><br><span class="line">		&#125;).start();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合图示理解：</p>
<p><img src="/images/java-cas/java-cas-1.jpg" alt="image"></p>
<p>上述代码，问题很明显，data 是类中的成员变量，int 类型，即共享的资源。当多个线程同时<br>执行 <code>data++</code> 操作时，结果可能不等于 200，为了模拟出效果，线程中 sleep 了 20 毫秒，让线程就绪，代码运行多次，结果都不是 200 。</p>
<h4 id="如何保障线程安全"><a href="#如何保障线程安全" class="headerlink" title="如何保障线程安全"></a><strong>如何保障线程安全</strong></h4><p>示例代码执行结果表明了，多个线程同时操作共享变量导致了结果不准确，线程是不安全的。如何解决呢？</p>
<p><strong>方案一：使用 synchronized 关键字</strong></p>
<p>使用 synchronized 关键字，线程内使用同步代码块，由JVM自身的机制来保障线程的安全性。</p>
<p>synchronized 关键代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类中定义的Object锁对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// synchronized 同步块 () 中使用 lock 对象锁定资源</span></span><br><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">100</span>).forEach(y -&gt; &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (lock.getClass()) &#123;</span><br><span class="line">				data++;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="/images/java-cas/java-cas-2.jpg" alt="image"></p>
<p><strong>方案二：使用 Lock 锁</strong></p>
<p>高并发场景下，使用 Lock 锁要比使用 synchronized 关键字，在性能上得到极大的提高。<br>因为 Lock 底层是通过 AQS + CAS 机制来实现的。关于 AQS 机制可以参见往期文章 &lt;&lt;通过通过一个生活中的案例场景，揭开并发包底层AQS的神秘面纱&gt;&gt; 。CAS 机制会在文章中下面讲到。</p>
<p>使用 Lock 的关键代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类中定义成员变量  </span></span><br><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 lock() 方法加锁，执行 unlock() 方法解锁</span></span><br><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">100</span>).forEach(y -&gt; &#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		data++;</span><br><span class="line">		lock.unlock();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>结合图示理解：</p>
<p><img src="/images/java-cas/java-cas-3.jpg" alt="image"></p>
<p><strong>方案三：使用 Atomic 原子类</strong></p>
<p>除上面两种方案还有没有更为优雅的方案？synchronized 的使用在 JDK1.6 版本以后做了很多优化，如果并发量不大，相比 Lock 更为安全，性能也能接受，因其得益于 JVM 底层机制来保障，自动释放锁，无需硬编码方式释放锁。而使用 Lock 方式，一旦 unlock() 方法使用不规范，可能导致死锁。</p>
<p>JDK 并发包所有的原子类如下所示：</p>
<p><img src="/images/java-cas/java-cas-4.jpg" alt="image"></p>
<p>使用 AtomicInteger 工具类实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类中成员变量定义原子类</span></span><br><span class="line"><span class="type">AtomicInteger</span> <span class="variable">atomicData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码中原子类的使用方式</span></span><br><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">2</span>).forEach((i) -&gt; &#123;</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">20</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			IntStream.range(<span class="number">0</span>, <span class="number">100</span>).forEach(y -&gt; &#123;</span><br><span class="line">				  <span class="comment">// 原子类自增</span></span><br><span class="line">					atomicData.incrementAndGet();</span><br><span class="line">			&#125;);</span><br><span class="line">	&#125;).start();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">		Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 get () 方法获取结果</span></span><br><span class="line">System.out.println(atomicData.get());</span><br></pre></td></tr></table></figure>

<p>结合图示理解：</p>
<p><img src="/images/java-cas/java-cas-5.jpg" alt="image"></p>
<p>之所以推荐使用 Atomic 原子类，因为其底层基于 CAS 乐观锁来实现的，下文会详细分析。</p>
<p><strong>方案四：使用 LongAdder 原子类</strong></p>
<p>LongAdder 原子类在 JDK1.8 中新增的类， 跟方案三中提到的 AtomicInteger 类似，都是在 java.util.concurrent.atomic 并发包下的。</p>
<p>LongAdder 适合于高并发场景下，特别是写大于读的场景，相较于 AtomicInteger、AtomicLong 性能更好，代价是消耗更多的空间，以空间换时间。</p>
<p>使用 LongAdder 工具类实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类中成员变量定义的LongAdder</span></span><br><span class="line"><span class="type">LongAdder</span> <span class="variable">longAdderData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码中原子类的使用方式</span></span><br><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">2</span>).forEach((i) -&gt; &#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">20</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				IntStream.range(<span class="number">0</span>, <span class="number">100</span>).forEach(y -&gt; &#123;</span><br><span class="line">					  <span class="comment">// 使用 increment() 方法自增</span></span><br><span class="line">						longAdderData.increment();</span><br><span class="line">				&#125;);</span><br><span class="line">		&#125;).start();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">		Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 sum() 获取结果</span></span><br><span class="line">System.out.println(longAdderData.sum());</span><br></pre></td></tr></table></figure>

<p>结合图示理解：</p>
<p><img src="/images/java-cas/java-cas-6.jpg" alt="image"></p>
<p>但是，如果使用了 LongAdder 原子类，当然其底层也是基于 CAS 机制实现的。LongAdder 内部维护了 base 变量和 Cell[] 数组，当多线程并发写的情况下，各个线程都在写入自己的 Cell 中，LongAdder 操作后返回的是个近似准确的值，最终也会返回一个准确的值。</p>
<p>换句话说，使用了 LongAdder 后获取的结果并不是实时的，对实时性要求高的还是建议使用其他的原子类，如 AtomicInteger 等。</p>
<p><strong>volatile 关键字方案？</strong></p>
<p>可能还有朋友会说，还想到另外一种方案：使用** <code>volatile</code>** 关键字啊。</p>
<p><img src="/images/java-cas/java-cas-7.jpg" alt="image"></p>
<p>经过验证，是不可行的，大家可以试试，就本文给出的示例代码直接执行，结果都不等于 200，说明线程仍然是不安全的。</p>
<p>data++ 自增赋值并不是原子的，跟 Java内存模型有关。</p>
<p>在非线程安全的图示中有标注执行线程本地，会有个内存副本，即本地的工作内存，实际执行过程会经过如下几个步骤：</p>
<p>（1）执行线程从本地工作内存读取 data，如果有值直接获取，如果没有值，会从主内存读取，然后将其放到本地工作内存当中。</p>
<p>（2）执行线程在本地工作内存中执行 +1 操作。</p>
<p>（3）将 data 的值写入主内存。</p>
<p><strong>结论：请记住！</strong></p>
<p>一个变量简单的读取和赋值操作是原子性的，将一个变量赋值给另外一个变量不是原子性的。</p>
<p>Java内存模型（JMM）仅仅保障了变量的基本读取和赋值操作是原子性的，其他均不会保证的。如果想要使某段代码块要求具备原子性，就需要使用 synchronized 关键字、并发包中的 Lock 锁、并发包中 Atomic 各种类型的原子类来实现，即上面我们提到的<strong>四种方案都是可行的</strong>。</p>
<p>而 <code>volatile</code> 关键字修饰的变量，恰恰是不能保障原子性的，仅能保障可见性和有序性。</p>
<h4 id="CAS原理剖析"><a href="#CAS原理剖析" class="headerlink" title="CAS原理剖析"></a><strong>CAS原理剖析</strong></h4><p>CAS 被认为是一种乐观锁，有乐观锁，相对应的是悲观锁。</p>
<p>在上述示例中，我们使用了 synchronized，如果在线程竞争压力大的情况下，synchronized 内部会升级为重量级锁，此时仅能有一个线程进入代码块执行，如果这把锁始终不能释放，其他线程会一直阻塞等待下去。此时，可以认为是悲观锁。</p>
<p>悲观锁会因线程一直阻塞导致系统上下文切换，系统的性能开销大。</p>
<p>那么，我们可以用乐观锁来解决，所谓的乐观锁，其实就是一种思想。</p>
<p>乐观锁，会以一种更加乐观的态度对待事情，认为自己可以操作成功。当多个线程操作同一个共享资源时，仅能有一个线程同一时间获得锁成功，在乐观锁中，其他线程发现自己无法成功获得锁，并不会像悲观锁那样阻塞线程，而是直接返回，可以去选择再次重试获得锁，也可以直接退出。</p>
<p>CAS 正是乐观锁的核心算法实现。</p>
<p>在示例代码的方案中都提到了 AtomicInteger、LongAdder、Lock锁底层，此外，当然还包括 java.util.concurrent.atomic 并发包下的所有原子类都是基于 CAS 来实现的。</p>
<p>以 AtomicInteger 原子整型类为例，一起来分析下 CAS 底层实现机制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">atomicData.incrementAndGet()</span><br></pre></td></tr></table></figure>

<p>源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提供自增易用的方法，返回增加1后的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 额外提供的compareAndSet方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsafe 类的提供的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span> <span class="params">(Object o,<span class="type">long</span> offset, <span class="type">int</span> delta)</span>&#123;</span><br><span class="line">		<span class="type">int</span> v;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">				v = getIntVolatile(o, offset);</span><br><span class="line">		&#125; <span class="keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta));</span><br><span class="line">		<span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到了 AtomicInteger 内部方法都是基于 Unsafe 类实现的，Unsafe 类是个跟底层硬件CPU指令通讯的复制工具类。</p>
<p>由这段代码看到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update)</span><br></pre></td></tr></table></figure>

<p>所谓的 CAS，其实是个简称，全称是 Compare And Swap，对比之后交换数据。<br>上面的方法，有几个重要的参数：</p>
<p>（1）this，Unsafe 对象本身，需要通过这个类来获取 value 的内存偏移地址。</p>
<p>（2）valueOffset，value 变量的内存偏移地址。</p>
<p>（3）expect，期望更新的值。</p>
<p>（4）update，要更新的最新值。</p>
<p>如果原子变量中的 value 值等于 expect，则使用 update 值更新该值并返回 true，否则返回 false。</p>
<p>再看如何获得 valueOffset的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unsafe实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			  <span class="comment">// 获得value在AtomicInteger中的偏移量</span></span><br><span class="line">				valueOffset = unsafe.objectFieldOffset</span><br><span class="line">						(AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实际变量的值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br></pre></td></tr></table></figure>

<p>这里看到了 value 实际的变量，是由 <strong>volatile</strong> 关键字修饰的，为了保证在多线程下的<strong>内存可见性</strong>。</p>
<p>为何能通过 Unsafe.getUnsafe() 方法能获得 Unsafe 类的实例？其实因为 AtomicInteger 类也在 **rt.jar **包下面的，所以 AtomicInteger 类就是通过 <strong>Bootstrap 根类加载器</strong>进行加载的。</p>
<p>源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Class</span> <span class="variable">var0</span> <span class="operator">=</span> Reflection.getCallerClass();</span><br><span class="line">		<span class="comment">// Bootstrap 类加载器是C++的，正常返回null，否则就抛异常。</span></span><br><span class="line">		<span class="keyword">if</span> (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Unsafe&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> theUnsafe;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类加载器委托关系：</p>
<p><img src="/images/java-cas/java-cas-8.jpg" alt="image"></p>
<h4 id="CPU如何实现原子操作"><a href="#CPU如何实现原子操作" class="headerlink" title="CPU如何实现原子操作"></a><strong>CPU如何实现原子操作</strong></h4><p>CPU 处理器速度远远大于在主内存中的，为了解决速度差异，在他们之间架设了多级缓存，如 L1、L2、L3 级别的缓存，这些缓存离CPU越近就越快，将频繁操作的数据缓存到这里，加快访问速度 ，如下图所示：</p>
<p><img src="/images/java-cas/java-cas-9.jpg" alt="image"></p>
<p>现在都是多核 CPU 处理器，每个 CPU 处理器内维护了一块字节的内存，每个内核内部维护着一块字节的缓存，当多线程并发读写时，就会出现缓存数据不一致的情况。</p>
<p>此时，处理器提供：</p>
<ul>
<li><strong>总线锁定</strong></li>
</ul>
<p>当一个处理器要操作共享变量时，在 BUS 总线上发出一个 Lock 信号，其他处理就无法操作这个共享变量了。</p>
<p>缺点很明显，总线锁定在阻塞其它处理器获取该共享变量的操作请求时，也可能会导致大量阻塞，从而增加系统的性能开销。</p>
<ul>
<li>**缓存锁定 **</li>
</ul>
<p>后来的处理器都提供了缓存锁定机制，也就说当某个处理器对缓存中的共享变量进行了操作，其他处理器会有个嗅探机制，将其他处理器的该共享变量的缓存失效，待其他线程读取时会重新从主内存中读取最新的数据，基于 MESI 缓存一致性协议来实现的。</p>
<p>现代的处理器基本都支持和使用的缓存锁定机制。</p>
<p><strong>注意：</strong></p>
<p>有如下两种情况处理器不会使用缓存锁定：</p>
<p>（1）当操作的数据跨多个缓存行，或没被缓存在处理器内部，则处理器会使用总线锁定。</p>
<p>（2）有些处理器不支持缓存锁定，比如：Intel 486 和 Pentium 处理器也会调用总线锁定。</p>
<h4 id="解密CAS底层指令"><a href="#解密CAS底层指令" class="headerlink" title="解密CAS底层指令"></a><strong>解密CAS底层指令</strong></h4><p>其实，掌握以上内容，对于 CAS 机制的理解相对来说算是比较清楚了。</p>
<p>当然，如果感兴趣，也可以继续深入学习用到了哪些硬件 CPU 指令。</p>
<p>底层硬件通过将 CAS 里的多个操作在硬件层面语义实现上，通过一条处理器指令保证了原子性操作。这些指令如下所示：</p>
<p>（1）测试并设置（Tetst-and-Set）</p>
<p>（2）获取并增加（Fetch-and-Increment）</p>
<p>（3）交换（Swap）</p>
<p>（4）比较并交换（Compare-and-Swap）</p>
<p>（5）加载链接&#x2F;条件存储（Load-Linked&#x2F;Store-Conditional）</p>
<p>前面三条大部分处理器已经实现，后面的两条是现代处理器当中新增加的。而且根据不同的体系结构，指令存在着明显差异。</p>
<p>在IA64，x86 指令集中有 <strong>cmpxchg</strong> 指令完成 CAS 功能，在 sparc-TSO 也有 <strong>casa</strong> 指令实现，而在 ARM 和 PowerPC 架构下，则需要使用一对 <strong>ldrex&#x2F;strex</strong> 指令来完成 LL&#x2F;SC 的功能。在精简指令集的体系架构中，则通常是靠一对儿指令，如：<strong>load and reserve</strong> 和 **store conditional ** 实现的，在大多数处理器上 CAS 都是个非常轻量级的操作，这也是其优势所在。</p>
<p>sun.misc.Unsafe 中 CAS 的核心方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object var1, <span class="type">long</span> var2, Object var4, Object var5)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4, <span class="type">int</span> var5)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">long</span> var4, <span class="type">long</span> var6)</span>;</span><br></pre></td></tr></table></figure>

<p>这三个方法可以对应去查看 openjdk 的 hotspot 源码：</p>
<p>源码位置：<code>hotspot/src/share/vm/prims/unsafe.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;f)</span></span><br><span class="line"></span><br><span class="line">&#123;CC<span class="string">&quot;compareAndSwapObject&quot;</span>, CC<span class="string">&quot;(&quot;</span>OBJ<span class="string">&quot;J&quot;</span>OBJ<span class="string">&quot;&quot;</span>OBJ<span class="string">&quot;)Z&quot;</span>,  <span class="built_in">FN_PTR</span>(Unsafe_CompareAndSwapObject)&#125;,</span><br><span class="line"></span><br><span class="line">&#123;CC<span class="string">&quot;compareAndSwapInt&quot;</span>,  CC<span class="string">&quot;(&quot;</span>OBJ<span class="string">&quot;J&quot;</span><span class="string">&quot;I&quot;</span><span class="string">&quot;I&quot;</span><span class="string">&quot;)Z&quot;</span>,      <span class="built_in">FN_PTR</span>(Unsafe_CompareAndSwapInt)&#125;,</span><br><span class="line"></span><br><span class="line">&#123;CC<span class="string">&quot;compareAndSwapLong&quot;</span>, CC<span class="string">&quot;(&quot;</span>OBJ<span class="string">&quot;J&quot;</span><span class="string">&quot;J&quot;</span><span class="string">&quot;J&quot;</span><span class="string">&quot;)Z&quot;</span>,      <span class="built_in">FN_PTR</span>(Unsafe_CompareAndSwapLong)&#125;,</span><br></pre></td></tr></table></figure>

<p>上述三个方法，最终在 hotspot 源码实现中都会调用统一的 cmpxchg 函数，可以在 hotspot 源码中找到核心代码。</p>
<p>源码地址：<code>hotspot/src/share/vm/runtime/Atomic.cpp</code></p>
<p><strong>cmpxchg 函数源码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">jbyte <span class="title">Atomic::cmpxchg</span><span class="params">(jbyte exchange_value, <span class="keyword">volatile</span> jbyte*dest, jbyte compare_value)</span> </span>&#123;</span><br><span class="line">		 <span class="built_in">assert</span> (<span class="built_in">sizeof</span>(jbyte) == <span class="number">1</span>,<span class="string">&quot;assumption.&quot;</span>);</span><br><span class="line">		 <span class="type">uintptr_t</span> dest_addr = (<span class="type">uintptr_t</span>) dest;</span><br><span class="line">		 <span class="type">uintptr_t</span> offset = dest_addr % <span class="built_in">sizeof</span>(jint);</span><br><span class="line">		 <span class="keyword">volatile</span> jint*dest_int = ( <span class="keyword">volatile</span> jint*)(dest_addr - offset);</span><br><span class="line">		 <span class="comment">// 对象当前值</span></span><br><span class="line">		 jint cur = *dest_int;</span><br><span class="line">		 <span class="comment">// 当前值cur的地址</span></span><br><span class="line">		 jbyte * cur_as_bytes = (jbyte *) ( &amp; cur);</span><br><span class="line">		 <span class="comment">// new_val地址</span></span><br><span class="line">		 jint new_val = cur;</span><br><span class="line">		 jbyte * new_val_as_bytes = (jbyte *) ( &amp; new_val);</span><br><span class="line">		  <span class="comment">// new_val存exchange_value，后面修改则直接从new_val中取值</span></span><br><span class="line">		 new_val_as_bytes[offset] = exchange_value;</span><br><span class="line">		 <span class="comment">// 比较当前值与期望值，如果相同则更新，不同则直接返回</span></span><br><span class="line">		 <span class="keyword">while</span> (cur_as_bytes[offset] == compare_value) &#123;</span><br><span class="line">		  <span class="comment">// 调用汇编指令cmpxchg执行CAS操作，期望值为cur，更新值为new_val</span></span><br><span class="line">			 jint res = <span class="built_in">cmpxchg</span>(new_val, dest_int, cur);</span><br><span class="line">			 <span class="keyword">if</span> (res == cur) <span class="keyword">break</span>;</span><br><span class="line">			 cur = res;</span><br><span class="line">			 new_val = cur;</span><br><span class="line">			 new_val_as_bytes[offset] = exchange_value;</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="comment">// 返回当前值</span></span><br><span class="line">		 <span class="keyword">return</span> cur_as_bytes[offset];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码中具体变量添加了注释，因为都是 C++ 代码，所以作为了解即可 ~</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">jint res = <span class="built_in">cmpxchg</span>(new_val, dest_int, cur);</span><br></pre></td></tr></table></figure>

<p>这里就是调用了汇编指令 cmpxchg 了，其中也是包含了三个参数，跟CAS上的参数能对应上。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>任何技术都要找到适合的场景，都不是万能的，CAS 机制也一样，也有副作用。</p>
<p><strong>问题1：</strong></p>
<p>作为乐观锁的一种实现，当多线程竞争资源激烈的情况下，而且锁定的资源处理耗时，那么其他线程就要考虑自旋的次数限制，避免过度的消耗 CPU。</p>
<p>另外，可以考虑上文示例代码中提到的 LongAdder 来解决，LongAdder 以空间换时间的方式，来解决 CAS 大量失败后长时间占用 CPU 资源，加大了系统性能开销的问题。</p>
<p><strong>问题2：</strong></p>
<p><strong>A–&gt;B—&gt;A</strong> 问题，假设有一个变量 A ，修改为B，然后又修改为了 A，实际已经修改过了，但 CAS 可能无法感知，造成了不合理的值修改操作。</p>
<p>整数类型还好，如果是对象引用类型，包含了多个变量，那怎么办？加个版本号或时间戳呗，没问题！</p>
<p>JDK 中 java.util.concurrent.atomic 并发包下，提供了 <strong>AtomicStampedReference</strong>，通过为引用建立个 Stamp 类似版本号的方式，确保 CAS 操作的正确性。</p>
<p>原文：</p>
<p><a href="https://www.cnblogs.com/ldws/p/11970087.html">https://www.cnblogs.com/ldws/p/11970087.html</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>cas</tag>
      </tags>
  </entry>
  <entry>
    <title>java-linkedlist</title>
    <url>/2021/05/17/java/container/java-linkedlist/</url>
    <content><![CDATA[<p>LinkedList类层次结构<br>先来看看LinkedList的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>

<p>从中我们可以了解到</p>
<ul>
<li>LinkedList<E>：说明它支持泛型。</li>
<li>extends AbstractSequentialList<E></li>
<li>AbstractSequentialList 继承自AbstractList，但AbstractSequentialList 只支持按次序访问</li>
<li>而不像 AbstractList 那样支持随机访问。这是LinkedList随机访问效率低的原因之一。</li>
<li>implements List<E>：说明它支持集合的一般操作。</li>
<li>implements Deque<E>：Deque，Double ended queue，双端队列。LinkedList可用作队列或双端队列就是因为实现了它。</li>
<li>implements Cloneable：表明其可以调用clone()方法来返回实例的field-for-field拷贝。</li>
<li>implements java.io.Serializable：表明该类是可以序列化的。</li>
</ul>
<p>与ArrayList对比发现，LinkedList并没有实现RandomAccess，而实现RandomAccess表明其支持快速（通常是固定时间）随机访问。此接口的主要目的是允许一般的算法更改其行为，从而在将其应用到随机或连续访问列表时能提供良好的性能。这是LinkedList随机访问效率低的原因之一。</p>
<p>下图是LinkedList的类结构层次图</p>
<p><img src="/images/java-linkedlist/java-linkedlist-1.jpg" alt="image"></p>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LinkedList节点个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指向头节点的指针</span></span><br><span class="line"><span class="comment"> * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment"> *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指向尾节点的指针</span></span><br><span class="line"><span class="comment"> * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment"> *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>

<p>关于node的详细介绍请看本文末尾的<strong>内部类—Node.java</strong>一节。Node表示链表每个节点的内部结构，包括一个数据域item，一个后置指针next，一个前置指针prev。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>接下来，看LinkedList提供的构造方法。ArrayList提供了两种构造方法。</p>
<ol>
<li>构造空LinkedList。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个空链表.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>构造空LinkedList。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据指定集合c构造linkedList。先构造一个空linkedlist，在把指定集合c中的所有元素都添加到linkedList中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  c 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果特定指定集合c为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="以下几个方法是操作链表的底层方法"><a href="#以下几个方法是操作链表的底层方法" class="headerlink" title="以下几个方法是操作链表的底层方法"></a><strong>以下几个方法是操作链表的底层方法</strong></h4><h5 id="linkFirst-E-e"><a href="#linkFirst-E-e" class="headerlink" title="linkFirst(E e)"></a><strong>linkFirst(E e)</strong></h5><p>方法在表头添加指定元素e</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在表头添加元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">linkFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">//使节点f指向原来的头结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">//新建节点newNode，节点的前指针指向null，后指针原来的头节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>, e, f);</span><br><span class="line">    <span class="comment">//头指针指向新的头节点newNode </span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="comment">//如果原来的头结点为null，更新尾指针，否则使原来的头结点f的前置指针指向新的头结点newNode</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="linkLast-E-e"><a href="#linkLast-E-e" class="headerlink" title="linkLast(E e)"></a><strong>linkLast(E e)</strong></h5><p>方法在表尾插入指定元素e</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在表尾插入指定元素e</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">//使节点l指向原来的尾结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">//新建节点newNode，节点的前指针指向l，后指针为null</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//尾指针指向新的头节点newNode</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">//如果原来的尾结点为null，更新头指针，否则使原来的尾结点l的后置指针指向新的头结点newNode</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="linkBefore-E-e-Node-succ"><a href="#linkBefore-E-e-Node-succ" class="headerlink" title="linkBefore( E e, Node succ)"></a><strong>linkBefore( E e, Node succ)</strong></h5><p>方法在指定节点succ之前插入指定元素e</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在指定节点succ之前插入指定元素e。指定节点succ不能为null。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> &#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="comment">//获得指定节点的前驱</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">//新建节点newNode，前置指针指向pred，后置指针指向succ</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, succ);</span><br><span class="line">    <span class="comment">//succ的前置指针指向newTouch</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="comment">//如果指定节点的前驱为null，将newTouch设为头节点。否则更新pred的后置节点</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="unlinkFirst-Node-f"><a href="#unlinkFirst-Node-f" class="headerlink" title="unlinkFirst( Node f)"></a><strong>unlinkFirst( Node f)</strong></h5><p>方法删除并返回头结点f</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除头结点f，并返回头结点的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">unlinkFirst</span><span class="params">( Node&lt;E&gt; f)</span> &#123;</span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="comment">// 保存头结点的值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> f.item;</span><br><span class="line">    <span class="comment">// 保存头结点指向的下个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    <span class="comment">//头结点的值置为null</span></span><br><span class="line">    f.item = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//头结点的后置指针指向null</span></span><br><span class="line">    f.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    <span class="comment">//将头结点置为next</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="comment">//如果next为null，将尾节点置为null，否则将next的后置指针指向null</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">        last = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//返回被删除的头结点的值</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="unlinkLast-Node-l"><a href="#unlinkLast-Node-l" class="headerlink" title="unlinkLast( Node l)"></a><strong>unlinkLast( Node l)</strong></h5><p>方法删除并返回尾结点f</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除尾节点l.并返回尾节点的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> &#123;</span><br><span class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">    <span class="comment">// 保存尾节点的值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> l.item;</span><br><span class="line">    <span class="comment">//获取新的尾节点prev</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    <span class="comment">//旧尾节点的值置为null</span></span><br><span class="line">    l.item = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//旧尾节点的后置指针指向null</span></span><br><span class="line">    l.prev = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    <span class="comment">//将新的尾节点置为prev</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="comment">//如果新的尾节点为null，头结点置为null，否则将新的尾节点的后置指针指向null</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>)</span><br><span class="line">        first = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prev.next = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//返回被删除的尾节点的值</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="unlink-Node-x"><a href="#unlink-Node-x" class="headerlink" title="unlink( Node x)"></a><strong>unlink( Node x)</strong></h5><p>方法删除指定节点，返回指定元素的值x</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除指定节点，返回指定元素的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="comment">// 保存指定节点的值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;</span><br><span class="line">    <span class="comment">// 获取指定节点的下个节点next</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="comment">// 获取指定节点的下个节点prev</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line">    <span class="comment">//如果prev为null，那么next为新的头结点，否则将prev的后置指针指向next，x的前置指针指向null</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果next为null，那么prev为新的尾结点，否则将next的前置指针指向prev，x的后置指针指向null</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//x的值置为null</span></span><br><span class="line">    x.item = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//返回被删除的节点的值</span></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="getFirst"><a href="#getFirst" class="headerlink" title="getFirst()"></a><strong>getFirst()</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回链表中的头结点的值.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回链表中的头结点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException 如果链表为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="getLast"><a href="#getLast" class="headerlink" title="getLast()"></a><strong>getLast()</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回链表中的尾结点的值.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回链表中的头结点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException 如果链表为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常用的操作方法"><a href="#常用的操作方法" class="headerlink" title="常用的操作方法"></a><strong>常用的操作方法</strong></h4><h5 id="removeFirst"><a href="#removeFirst" class="headerlink" title="removeFirst"></a><strong>removeFirst</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除并返回表头元素.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 表头元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException 链表为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="removeLast"><a href="#removeLast" class="headerlink" title="removeLast"></a><strong>removeLast</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除并返回表尾元素.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 表尾元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException 链表为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="addFirst-E-e"><a href="#addFirst-E-e" class="headerlink" title="addFirst( E e)"></a><strong>addFirst( E e)</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在表头插入指定元素.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 插入的指定元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="addLast-E-e"><a href="#addLast-E-e" class="headerlink" title="addLast( E e)"></a><strong>addLast( E e)</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在表尾插入指定元素.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 该方法等价于add()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 插入的指定元素</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="contains-Object-o"><a href="#contains-Object-o" class="headerlink" title="contains( Object o)"></a><strong>contains( Object o)</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断链表是否包含指定对象o</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 指定对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否包含指定对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="size"><a href="#size" class="headerlink" title="size()"></a><strong>size()</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回链表元素个数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 链表元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add( E e)"></a><strong>add( E e)</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在表尾插入指定元素.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该方法等价于addLast</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 插入的指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a><strong>remove(Object o)</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正向遍历链表，删除出现的第一个值为指定对象的节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 要删除的节点置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果o在链表中存在，返回true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="comment">//遍历链表，如果o为null，删除第一个值为null的节点，返回true。如果不为null，删除第一个值为o的节点。如果链表中存在o，就返回true。</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="literal">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="addAll-Collection-lt-extends-E-gt-c"><a href="#addAll-Collection-lt-extends-E-gt-c" class="headerlink" title="addAll( Collection&lt;? extends E&gt; c)"></a><strong>addAll( Collection&lt;? extends E&gt; c)</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入指定集合到链尾</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果链表改变，返回true</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定集合为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="addAll-int-index-Collection-lt-extends-E-gt-c"><a href="#addAll-int-index-Collection-lt-extends-E-gt-c" class="headerlink" title="addAll( int index, Collection&lt;? extends E&gt; c)"></a><strong>addAll( int index, Collection&lt;? extends E&gt; c)</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入指定集合到链尾的指定位置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定的插入位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 插入的指定集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果链表改变，返回true</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 如果index&lt;0或index&gt;size</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定集合为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="comment">//检查插入的位置是否合法</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果c是空的话那么就返回false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义两个节点指针，指向插入点前后的节点元素</span></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        succ = <span class="literal">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入集合中所有元素</span></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改插入后的指针问题</span></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="literal">null</span>) &#123;</span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="clear"><a href="#clear" class="headerlink" title="clear()"></a><strong>clear()</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除链表中的所有元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Clearing all of the links between nodes is &quot;unnecessary&quot;, but:</span></span><br><span class="line">    <span class="comment">// - helps a generational GC if the discarded nodes inhabit</span></span><br><span class="line">    <span class="comment">//   more than one generation</span></span><br><span class="line">    <span class="comment">// - is sure to free memory even if there is a reachable Iterator</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; ) &#123;</span><br><span class="line">        Node&lt;E&gt; next = x.next;</span><br><span class="line">        x.item = <span class="literal">null</span>;</span><br><span class="line">        x.next = <span class="literal">null</span>;</span><br><span class="line">        x.prev = <span class="literal">null</span>;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">    first = last = <span class="literal">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="按位操作"><a href="#按位操作" class="headerlink" title="按位操作"></a><strong>按位操作</strong></h4><h5 id="get-int-index"><a href="#get-int-index" class="headerlink" title="get( int index)"></a><strong>get( int index)</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定索引处的元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定索引处的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 如果索引index越界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="set-int-index-E-element"><a href="#set-int-index-E-element" class="headerlink" title="set( int index, E element)"></a><strong>set( int index, E element)</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 替换指定索引处的元素为指定元素element</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 被替换的元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定元素element</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 索引越界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldVal</span> <span class="operator">=</span> x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add( int index, E element)"></a><strong>add( int index, E element)</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入指定元素到指定索引处</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 索引越界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove( int index)"></a><strong>remove( int index)</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除指定索引处的元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> 指定索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定索引处的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 索引越界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="isElementIndex-int-index"><a href="#isElementIndex-int-index" class="headerlink" title="isElementIndex( int index)"></a><strong>isElementIndex( int index)</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回索引是否越界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isElementIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="isPositionIndex-int-index"><a href="#isPositionIndex-int-index" class="headerlink" title="isPositionIndex(int index)"></a><strong>isPositionIndex(int index)</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回插入操作时给定的索引是否合法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPositionIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="outOfBoundsMsg-int-index"><a href="#outOfBoundsMsg-int-index" class="headerlink" title="outOfBoundsMsg( int index)"></a><strong>outOfBoundsMsg( int index)</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 索引越界时打印的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">outOfBoundsMsg</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Index: &quot;</span>+index+<span class="string">&quot;, Size: &quot;</span>+size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="checkElementIndex-int-index"><a href="#checkElementIndex-int-index" class="headerlink" title="checkElementIndex( int index)"></a><strong>checkElementIndex( int index)</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查索引是否越界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkElementIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isElementIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="checkPositionIndex-int-index"><a href="#checkPositionIndex-int-index" class="headerlink" title="checkPositionIndex( int index)"></a><strong>checkPositionIndex( int index)</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查插入操作时给定的索引是否合法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkPositionIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="node-int-index"><a href="#node-int-index" class="headerlink" title="node( int index)"></a><strong>node( int index)</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回在指定索引处的非空元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a><strong>查找操作</strong></h4><h5 id="indexOf-Object-o"><a href="#indexOf-Object-o" class="headerlink" title="indexOf( Object o)"></a><strong>indexOf( Object o)</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正向遍历链表，返回指定元素第一次出现时的索引。如果元素没有出现，返回-1.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 需要查找的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定元素第一次出现时的索引。如果元素没有出现，返回-1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="lastIndexOf-Object-o"><a href="#lastIndexOf-Object-o" class="headerlink" title="lastIndexOf( Object o)"></a><strong>lastIndexOf( Object o)</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逆向遍历链表，返回指定元素第一次出现时的索引。如果元素没有出现，返回-1.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 需要查找的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定元素第一次出现时的索引。如果元素没有出现，返回-1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> size;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="literal">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="literal">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="队列操作"><a href="#队列操作" class="headerlink" title="队列操作"></a><strong>队列操作</strong></h4><h5 id="peek"><a href="#peek" class="headerlink" title="peek()"></a><strong>peek()</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回头节点的元素，如果链表为空则返回null</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回头节点的元素，如果链表为空则返回null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="element"><a href="#element" class="headerlink" title="element()"></a><strong>element()</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取表头节点的值，头节点为空抛出异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 获取表头节点的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException 如果链表为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">element</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="poll"><a href="#poll" class="headerlink" title="poll()"></a><strong>poll()</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回并删除头节点，如果链表为空则返回null</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回并删除头节点，如果链表为空则返回null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="remove"><a href="#remove" class="headerlink" title="remove()"></a><strong>remove()</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除并返回头节点，如果链表为空，抛出异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 头结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException 链表为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="offer-E-e"><a href="#offer-E-e" class="headerlink" title="offer(E e)"></a><strong>offer(E e)</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素到队列尾部</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> add(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双向队列操作"><a href="#双向队列操作" class="headerlink" title="双向队列操作"></a><strong>双向队列操作</strong></h4><h5 id="offerFirst-E-e"><a href="#offerFirst-E-e" class="headerlink" title="offerFirst( E e)"></a><strong>offerFirst( E e)</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入指定元素到队列头部.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 插入的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  true</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="offerLast-E-e"><a href="#offerLast-E-e" class="headerlink" title="offerLast( E e)"></a><strong>offerLast( E e)</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入指定元素到队列尾部.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 插入的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  true</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="peekFirst"><a href="#peekFirst" class="headerlink" title="peekFirst()"></a><strong>peekFirst()</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回队列的头元素，如果头节点为空则返回空</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 返回队列的头元素，如果头节点为空则返回空</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">peekFirst</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">   <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="peekLast"><a href="#peekLast" class="headerlink" title="peekLast()"></a><strong>peekLast()</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回队列的尾元素，如果尾节点为空则返回空</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 返回队列的尾元素，如果尾节点为空则返回空</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">peekLast</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="literal">null</span>) ? <span class="literal">null</span> : l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="pollFirst"><a href="#pollFirst" class="headerlink" title="pollFirst()"></a><strong>pollFirst()</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除并返回队列的第一个元素，如果头节点为空，则返回null.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 删除并返回队列的第一个元素，如果头节点为空，则返回null.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">pollFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="pollLast"><a href="#pollLast" class="headerlink" title="pollLast()"></a><strong>pollLast()</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除并返回队列的最后个元素，如果尾节点为空，则返回null.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 删除并返回队列的最后一个元素，如果尾节点为空，则返回null.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">pollLast</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="literal">null</span>) ? <span class="literal">null</span> : unlinkLast(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="push-E-e"><a href="#push-E-e" class="headerlink" title="push( E e)"></a><strong>push( E e)</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入指定元素到栈头</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 此方法等价于addFirst(e)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 指定元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="pop"><a href="#pop" class="headerlink" title="pop()"></a><strong>pop()</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除并返回栈头元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 此方法等价于pop()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回栈头元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException 如果栈为空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="removeFirstOccurrence-Object-o"><a href="#removeFirstOccurrence-Object-o" class="headerlink" title="removeFirstOccurrence( Object o)"></a><strong>removeFirstOccurrence( Object o)</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正向遍历栈，删除指定对象第一次出现时，索引对应的元素</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 被删除的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 如果元素出现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeFirstOccurrence</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> remove(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原文：<a href="https://blog.csdn.net/panweiwei1994/article/details/77110354">https://blog.csdn.net/panweiwei1994/article/details/77110354</a></p>
]]></content>
      <categories>
        <category>java</category>
        <category>container</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title>java ArrayList</title>
    <url>/2021/05/17/java/container/java-arraylist/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p><img src="/images/java-arraylist/java-arraylist-1.jpg" alt="image"></p>
<h1 id="顶部注释"><a href="#顶部注释" class="headerlink" title="顶部注释"></a>顶部注释</h1><blockquote>
<p>List接口的大小可变数组的实现。实现了所有可选列表操作，并允许包括null在内的所有元素。除了实现List接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。（此类大致上等同于Vector类，除了此类是不同步的。）</p>
<p>size、isEmpty、get、set、iterator和listIterator操作都以固定时间运行。add操作以分摊的固定时间运行，也就是说，添加n个元素需要O(n)时间。其他所有操作都以线性时间运行（大体上讲）。与用于LinkedList实现的常数因子相比，此实现的常数因子较低。</p>
<p>每个ArrayList实例都有一个容量。该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向ArrayList中不断添加元素，其容量也自动增长。并未指定增长策略的细节，因为这不只是添加元素会带来分摊固定时间开销那样简单。</p>
<p>在添加大量元素前，应用程序可以使用ensureCapacity操作来增加ArrayList实例的容量。这可以减少递增式再分配的数量。</p>
<p>注意，此实现不是同步的。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。（结构上的修改是指任何添加或删除一个或多个元素的操作，或者显式调整底层数组的大小；仅仅设置元素的值不是结构上的修改。）这一般通过对自然封装该列表的对象进行同步操作来完成。如果不存在这样的对象，则应该使用Collections.synchronizedList方法将该列表“包装”起来。这最好在创建时完成，以防止意外对列表进行不同步的访问：<br>List list &#x3D; Collections.synchronizedList(new ArrayList(…));</p>
<p>此类的iterator和listIterator方法返回的迭代器是快速失败的：在创建迭代器之后，除非通过迭代器自身的remove或add方法从结构上对列表进行修改，否则在任何时间以任何方式对列表进行修改，迭代器都会抛出ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。</p>
<p>注意，迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败迭代器会尽最大努力抛出ConcurrentModificationException。因此，为提高这类迭代器的正确性而编写一个依赖于此异常的程序是错误的做法：迭代器的快速失败行为应该仅用于检测bug。</p>
<p>此类是Java Collections Framework的成员。</p>
</blockquote>
<p>从上面的内容中可以总结出以下几点：</p>
<ul>
<li><strong>底层</strong>：ArrayList是List接口的大小可变数组的实现。</li>
<li><strong>是否允许null</strong>：ArrayList允许null元素。</li>
<li><strong>时间复杂度</strong>：size、isEmpty、get、set、iterator和listIterator方法都以固定时间运行，时间复杂度为O(1)。add和remove方法需要O(n)时间。与用于LinkedList实现的常数因子相比，此实现的常数因子较低。</li>
<li><strong>容量</strong>：ArrayList的容量可以自动增长。</li>
<li><strong>是否同步</strong>：ArrayList不是同步的。</li>
<li><strong>迭代器</strong>：ArrayList的iterator和listIterator方法返回的迭代器是fail-fast的。</li>
</ul>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>先来看看ArrayList的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;,RandomAccess,Cloneable,java.io.Serializable</span><br></pre></td></tr></table></figure>

<p>从中我们可以了解到：</p>
<ul>
<li>ArrayList<E>：说明ArrayList支持泛型。</li>
<li>extends AbstractList<E> ：继承了AbstractList。AbstractList提供List接口的骨干实现，以最大限度地减少“随机访问”数据存储（如ArrayList）实现Llist所需的工作。</li>
<li>implements List<E>：实现了List。实现了所有可选列表操作。</li>
<li>implements RandomAccess：表明ArrayList支持快速（通常是固定时间）随机访问。此接口的</li>
<li>要目的是允许一般的算法更改其行为，从而在将其应用到随机或连续访问列表时能提供良好的性能。</li>
<li>implements Cloneable：表明其可以调用clone()方法来返回实例的field-for-field拷贝。<br>implements java.io.Serializable：表明该类具有序列化功能。</li>
</ul>
<p>但继承实现信息还不够完整，下图是ArrayList的类结构层次图。</p>
<p><img src="/images/java-arraylist/java-arraylist-2.jpg" alt="image"></p>
<h1 id="域"><a href="#域" class="headerlink" title="域"></a>域</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化默认容量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定该ArrayList容量为0时，返回该空数组。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当调用无参构造方法，返回的是该数组。刚创建一个ArrayList 时，其内数据量为0。</span></span><br><span class="line"><span class="comment"> * 它与EMPTY_ELEMENTDATA的区别就是：该数组是默认返回的，而后者是在用户指定容量为0时返回。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保存添加到ArrayList中的元素。</span></span><br><span class="line"><span class="comment"> * ArrayList的容量就是该数组的长度。</span></span><br><span class="line"><span class="comment"> * 该值为DEFAULTCAPACITY_EMPTY_ELEMENTDATA 时，当第一次添加元素进入ArrayList中时，数组将扩容值DEFAULT_CAPACITY。</span></span><br><span class="line"><span class="comment"> * 被标记为transient，在对象被序列化的时候不会被序列化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList的实际大小（数组包含的元素个数）。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure>

<p><strong>思考：elementData被标记为transient，那么它的序列化和反序列化是如何实现的呢？</strong><br>ArrayList自定义了它的序列化和反序列化方式。详情请查看writeObject(java.io.ObjectOutputStream s)和readObject(java.io.ObjectOutputStream s)方法。</p>
<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><ol>
<li>ArrayList(int initialCapacity)：构造一个指定容量为capacity的空ArrayList。</li>
<li>ArrayList()：构造一个初始容量为 10 的空列表。</li>
<li>ArrayList(Collection&lt;? extends E&gt; c)：构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。</li>
</ol>
<h2 id="ArrayList-int-initialCapacity"><a href="#ArrayList-int-initialCapacity" class="headerlink" title="ArrayList( int initialCapacity)"></a>ArrayList( int initialCapacity)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个指定初始化容量为capacity的空ArrayList。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity  ArrayList的指定初始化容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException  如果ArrayList的指定初始化容量为负。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList()"></a>ArrayList()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个初始容量为 10 的空列表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ArrayList-Collection-lt-extends-E-gt-c"><a href="#ArrayList-Collection-lt-extends-E-gt-c" class="headerlink" title="ArrayList(Collection&lt;? extends E&gt; c)"></a>ArrayList(Collection&lt;? extends E&gt; c)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 其元素将放置在此列表中的 collection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定的 collection 为 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h1><p>ArrayList有以下核心方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>get(int index)</td>
<td>O(1)</td>
</tr>
<tr>
<td>add(E e)</td>
<td>O(1)</td>
</tr>
<tr>
<td>add(add(int index, E element))</td>
<td>O(n)</td>
</tr>
<tr>
<td>remove(int index)</td>
<td>O(n)</td>
</tr>
<tr>
<td>set(int index, E element)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<h2 id="get-int-index"><a href="#get-int-index" class="headerlink" title="get( int index)"></a>get( int index)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回list中索引为index的元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  index 需要返回的元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> list中索引为index的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 如果索引超出size</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">//越界检查</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">//返回索引为index的元素</span></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 越界检查。</span></span><br><span class="line"><span class="comment"> * 检查给出的索引index是否越界。</span></span><br><span class="line"><span class="comment"> * 如果越界，抛出运行时异常。</span></span><br><span class="line"><span class="comment"> * 这个方法并不检查index是否合法。比如是否为负数。</span></span><br><span class="line"><span class="comment"> * 如果给出的索引index&gt;=size，抛出一个越界异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheck</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回索引为index的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看到，因为ArrayList底层是数组，所以它的get方法非常简单，先是判断一下有没有越界，之后就直接通过数组下标来获取元素。get方法的<strong>时间复杂度是O(1)。</strong></p>
<p>add(E e)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加元素到list末尾.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 被添加的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">//确认list容量，如果不够，容量加1。注意：只加1，保证资源不被浪费</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中可以看到，add(E e)有两个步骤：</p>
<ol>
<li>空间检查，如果有需要进行扩容</li>
<li>插入元素</li>
</ol>
<p>空间检查和扩容的介绍在下面。</p>
<p>空间的问题解决后，插入过程就显得非常简单。</p>
<p><img src="/images/java-arraylist/java-arraylist-3.jpg" alt="image"></p>
<h2 id="扩容-ensureCapacity等方法"><a href="#扩容-ensureCapacity等方法" class="headerlink" title="扩容-ensureCapacity等方法"></a>扩容-ensureCapacity等方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 增加ArrayList容量。</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>   minCapacity   想要的最小容量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果elementData等于DEFAULTCAPACITY_EMPTY_ELEMENTDATA，最小扩容量为DEFAULT_CAPACITY，否则为0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">minExpand</span> <span class="operator">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)? <span class="number">0</span>: DEFAULT_CAPACITY;</span><br><span class="line">    <span class="comment">//如果想要的最小容量大于最小扩容量，则使用想要的最小容量。</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 数组容量检查，不够时则进行扩容，只供类内部使用。</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> minCapacity    想要的最小容量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 若elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA，则取minCapacity为DEFAULT_CAPACITY和参数minCapacity之间的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 数组容量检查，不够时则进行扩容，只供类内部使用</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> minCapacity 想要的最小容量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保指定的最小容量 &gt; 数组缓冲区当前的长度  </span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//扩容</span></span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分派给arrays的最大容量</span></span><br><span class="line"><span class="comment"> * 为什么要减去8呢？</span></span><br><span class="line"><span class="comment"> * 因为某些VM会在数组中保留一些头字，尝试分配这个最大存储容量，可能会导致array容量大于VM的limit，最终导致OutOfMemoryError。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 扩容，保证ArrayList至少能存储minCapacity个元素</span></span><br><span class="line"><span class="comment">* 第一次扩容，逻辑为newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);即在原有的容量基础上增加一半。第一次扩容后，如果容量还是小于minCapacity，就将容量扩充为minCapacity。</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> minCapacity 想要的最小容量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前数组的容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">// 扩容。新的容量=当前容量+当前容量/2.即将当前容量增加一半。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//如果扩容后的容量还是小于想要的最小容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//将扩容后的容量再次扩容为想要的最小容量</span></span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">//如果扩容后的容量大于临界值，则进行大容量分配</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData,newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 进行大容量分配</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//如果minCapacity&lt;0，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="comment">//如果想要的容量大于MAX_ARRAY_SIZE，则分配Integer.MAX_VALUE，否则分配MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完了代码，可以对扩容方法总结如下：</p>
<ol>
<li>进行空间检查，决定是否进行扩容，以及确定最少需要的容量</li>
<li>如果确定扩容，就执行grow(int minCapacity)，minCapacity为最少需要的容量</li>
<li>第一次扩容，逻辑为newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);即在原有的容量基础上增加一半。</li>
<li>第一次扩容后，如果容量还是小于minCapacity，就将容量扩充为minCapacity。</li>
<li>对扩容后的容量进行判断，如果大于允许的最大容量MAX_ARRAY_SIZE，则将容量再次调整为MAX_ARRAY_SIZE。至此扩容操作结束。</li>
<li><strong>注意：扩容后是一个增加容量的新的数组，只是将原数据复制到新数组中，并非增加原数组的长度</strong></li>
</ol>
<h2 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add( int index, E element)"></a>add( int index, E element)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在制定位置插入元素。当前位置的元素和index之后的元素向后移一位</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 即将插入元素的位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 即将插入的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 如果索引超出size</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">//越界检查</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="comment">//确认list容量，如果不够，容量加1。注意：只加1，保证资源不被浪费</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 对数组进行复制处理，目的就是空出index的位置插入element，并将index后的元素位移一个位置</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,size - index);</span><br><span class="line">    <span class="comment">//将指定的index位置赋值为element</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">//实际容量+1</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中可以看到，add(E e)有三个步骤：</p>
<ol>
<li>越界检查</li>
<li>空间检查，如果有需要进行扩容</li>
<li>插入元素</li>
</ol>
<p>越界检查很简单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheckForAdd</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空间检查和扩容的介绍在上面。</p>
<p>空间的问题解决后，插入过程就显得非常简单。</p>
<p><img src="/images/java-arraylist/java-arraylist-4.jpg" alt="image"></p>
<p>add(int index, E e)需要先对元素进行移动，然后完成插入操作，也就意味着该方法有着<strong>线性的时间复杂度，即O(n)。</strong></p>
<h2 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove( int index)"></a>remove( int index)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除list中位置为指定索引index的元素</span></span><br><span class="line"><span class="comment"> * 索引之后的元素向左移一位</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 被删除元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 被删除的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 如果参数指定索引index&gt;=size，抛出一个越界异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">//检查索引是否越界。如果参数指定索引index&gt;=size，抛出一个越界异常</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">//结构性修改次数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//记录索引为inde处的元素</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除指定元素后，需要左移的元素个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果有需要左移的元素，就移动（移动后，该删除的元素就已经被覆盖了）</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// size减一，然后将索引为size-1处的元素置为null。为了让GC起作用，必须显式的为最后一个位置赋null值</span></span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回被删除的元素</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 越界检查。</span></span><br><span class="line"><span class="comment"> * 检查给出的索引index是否越界。</span></span><br><span class="line"><span class="comment"> * 如果越界，抛出运行时异常。</span></span><br><span class="line"><span class="comment"> * 这个方法并不检查index是否合法。比如是否为负数。</span></span><br><span class="line"><span class="comment"> * 如果给出的索引index&gt;=size，抛出一个越界异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheck</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完代码后，可以将ArrayList删除指定索引的元素的步骤总结为</p>
<ol>
<li>检查索引是否越界。如果参数指定索引index&gt;&#x3D;size，抛出一个越界异常</li>
<li>将索引大于index的元素左移一位（左移后，该删除的元素就被覆盖了，相当于被删除了）。</li>
<li>将索引为size-1处的元素置为null（为了让GC起作用）。</li>
</ol>
<p>注意：为了让GC起作用，必须显式的为最后一个位置赋null值。上面代码中如果不手动赋null值，除非对应的位置被其他元素覆盖，否则原来的对象就一直不会被回收。</p>
<p><img src="/images/java-arraylist/java-arraylist-5.jpg" alt="image"></p>
<h2 id="set-int-index-E-element"><a href="#set-int-index-E-element" class="headerlink" title="set( int index, E element)"></a>set( int index, E element)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 替换指定索引的元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> 被替换元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 即将替换到指定索引的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回被替换的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 如果参数指定索引index&gt;=size，抛出一个越界异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">//检查索引是否越界。如果参数指定索引index&gt;=size，抛出一个越界异常</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录被替换的元素</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    <span class="comment">//替换元素</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">//返回被替换的元素</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考：</p>
<p><a href="https://blog.csdn.net/panweiwei1994/article/details/76760238">https://blog.csdn.net/panweiwei1994/article/details/76760238</a></p>
]]></content>
      <categories>
        <category>java</category>
        <category>container</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title>java HashMap</title>
    <url>/2021/05/17/java/container/java-hashmap/</url>
    <content><![CDATA[<p>参考的JDK版本为1.8。</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p><img src="/images/java-hashmap/java-hash-map-1.jpg" alt="image"></p>
<p>从上图中可以很清楚的看到，HashMap的数据结构是数组+链表+红黑树（红黑树since JDK1.8）。我们常把数组中的每一个节点称为一个<strong>桶</strong>。当向桶中添加一个键值对时，首先计算键值对中key的hash值，以此确定插入数组中的位置，但是可能存在同一hash值的元素已经被放在数组同一位置了，这种现象称为<strong>碰撞</strong>，这时按照尾插法(jdk1.7及以前为头插法)的方式添加key-value到同一hash值的元素的后面，链表就这样形成了。当链表长度超过8(TREEIFY_THRESHOLD)时，链表就转换为红黑树。</p>
<h1 id="顶部注释"><a href="#顶部注释" class="headerlink" title="顶部注释"></a>顶部注释</h1><blockquote>
<p>HashMap是Map接口基于哈希表的实现。这种实现提供了所有可选的Map操作，并允许key和value为null（除了HashMap是unsynchronized的和允许使用null外，HashMap和HashTable大致相同。）。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
<p>此实现假设哈希函数在桶内适当地分布元素，为基本实现(get 和 put)提供了稳定的性能。迭代 collection 视图所需的时间与 HashMap 实例的“容量”（桶的数量）及其大小（键-值映射关系数）成比例。如果遍历操作很重要，就不要把初始化容量initial capacity设置得太高（或将加载因子load factor设置得太低），否则会严重降低遍历的效率。</p>
<p>HashMap有两个影响性能的重要参数：初始化容量initial capacity、加载因子load factor。容量是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度。initial capacity<em>load factor就是当前允许的最大元素数目，超过initial capacity</em>load factor之后，HashMap就会进行rehashed操作来进行扩容，扩容后的的容量为之前的两倍。</p>
<p>通常，默认加载因子 (0.75) 在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少rehash操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生rehash 操作。</p>
<p>如果很多映射关系要存储在 HashMap 实例中，则相对于按需执行自动的 rehash 操作以增大表的容量来说，使用足够大的初始容量创建它将使得映射关系能更有效地存储。</p>
<p>注意，此实现不是同步的。如果多个线程同时访问一个哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。（结构上的修改是指添加或删除一个或多个映射关系的任何操作；仅改变与实例已经包含的键关联的值不是结构上的修改。）这一般通过对自然封装该映射的对象进行同步操作来完成。如果不存在这样的对象，则应该使用 Collections.synchronizedMap 方法来“包装”该映射。最好在创建时完成这一操作，以防止对映射进行意外的非同步访问，如下所示：</p>
<p>Map m &#x3D; Collections.synchronizedMap(new HashMap(…));</p>
<p>由所有此类的“collection 视图方法”所返回的迭代器都是fail-fast 的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的remove方法，其他任何时间任何方式的修改，迭代器都将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不冒在将来不确定的时间发生任意不确定行为的风险。</p>
<p>注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测bug。</p>
<p>此类是 Java Collections Framework 的成员。</p>
<p>@author Doug Lea<br>@author Josh Bloch<br>@author Arthur van Hoff<br>@author Neal Gafter<br>@see Object#hashCode()<br>@see Collection<br>@see Map<br>@see TreeMap</p>
</blockquote>
<p>从上面的内容中可以总结出以下几点：</p>
<ul>
<li><strong>底层</strong>：HashMap是Map接口基于哈希表的实现。</li>
<li><strong>是否允许null</strong>：HashMap允许key和value为null。</li>
<li><strong>是否有序</strong>：HashMap不保证映射的顺序，特别是它不保证该顺序恒久不变。</li>
<li><strong>何时rehash</strong>：超出当前允许的最大容量。initial capacity<em>load factor就是当前允许的最大元素数目，超过initial capacity</em>load factor之后，HashMap就会进行rehashed操作来进行扩容，扩容后的的容量为之前的两倍。</li>
<li><strong>初始化容量对性能的影响</strong>：不应设置地太小，设置地小虽然可以节省空间，但会频繁地进行rehash操作。rehash会影响性能。总结：小了会增大时间开销（频繁rehash）；大了会增大空间开销（占用了更多空间）和时间开销（影响遍历）。</li>
<li><strong>加载因子对性能的影响</strong>：加载因子过高虽然减少了空间开销，但同时也增加了查询成本。0.75是个折中的选择。总结：小了会增大时间开销（频繁rehash）；大了会也增大时间开销（影响遍历）。</li>
<li><strong>是否同步</strong>：HashMap不是同步的。</li>
<li><strong>迭代器</strong>：迭代器是fast-fail的。</li>
</ul>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>

<ul>
<li>HashMap&lt;K,V&gt;：HashMap是以key-value形式存储数据的。</li>
<li>extends AbstractMap&lt;K,V&gt;：继承了AbstractMap，大大减少了实现Map接口时需要的工作量。</li>
<li>implements Map&lt;K,V&gt;：实现了Map，提供了所有可选的Map操作。</li>
<li>implements Cloneable：表明其可以调用clone()方法来返回实例的field-for-field拷贝。</li>
<li>implements Serializable：表明该类是可以序列化的。</li>
</ul>
<p>下图是HashMap的类结构层次图。</p>
<p><img src="/images/java-hashmap/java-hash-map-2.jpg" alt="image"></p>
<h1 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始化容量，值为16</span></span><br><span class="line"><span class="comment"> * 必须是2的n次幂.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大容量, 容量不能超出这个值。如果一个更大的初始化容量在构造函数中被指定，将被MAXIMUM_CAPACITY替换.</span></span><br><span class="line"><span class="comment"> * 必须是2的倍数。最大容量为1&lt;&lt;30，即2的30次方。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认的加载因子。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将链表转化为红黑树的临界值。</span></span><br><span class="line"><span class="comment"> * 当添加一个元素被添加到有至少TREEIFY_THRESHOLD个节点的桶中，桶中链表将被转化为树形结构。</span></span><br><span class="line"><span class="comment"> * 临界值最小为8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 恢复成链式结构的桶大小临界值</span></span><br><span class="line"><span class="comment"> * 小于TREEIFY_THRESHOLD，临界值最大为6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桶可能被转化为树形结构的最小容量。当哈希表的大小超过这个阈值，才会把链式结构转化成树型结构，否则仅采取扩容来尝试减少冲突。</span></span><br><span class="line"><span class="comment"> * 应该至少4*TREEIFY_THRESHOLD来避免扩容和树形结构化之间的冲突。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br></pre></td></tr></table></figure>

<h1 id="静态内部类Node"><a href="#静态内部类Node" class="headerlink" title="静态内部类Node"></a>静态内部类Node</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashMap的节点类型。既是HashMap底层数组的组成元素，又是每个单向链表的组成元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">//key的哈希值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">//指向下个节点的引用</span></span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.hash = hash;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h1><h2 id="get-Object-key"><a href="#get-Object-key" class="headerlink" title="get( Object key)"></a>get( Object key)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定的key映射的value，如果value为null，则返回null。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//如果通过key获取到的node为null，则返回null，否则返回node的value。getNode方法的实现就在下面。</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中可以看到，get(E e)可以分为三个步骤：</p>
<ol>
<li>通过hash(Object key)方法计算key的哈希值hash。</li>
<li>通过getNode( int hash, Object key)方法获取node。</li>
<li>如果node为null，返回null，否则返回node.value。<br>先来看看哈希值是如何计算的。</li>
</ol>
<p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。计算位置的方法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure>

<p>其中的n为数组的长度，hash为hash(key)计算得到的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算key的哈希值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看到，计算位置分为三步，第一步，取key的hashCode，第二步，key的hashCode高16位异或低16位，第三步，将第一步和第二部得到的结果进行取模运算。</p>
<p><img src="/images/java-hashmap/java-hash-map-3.jpg" alt="image"></p>
<p>看到这里有个疑问，<strong>为什么要做异或运算？</strong></p>
<p>设想一下，如果n很小，假设为16的话，那么n-1即为15（0000 0000 0000 0000 0000 0000 0000 1111），这样的值如果跟hashCode()直接做与操作，实际上只使用了哈希值的后4位。如果当哈希值的高位变化很大，低位变化很小，这样很容易造成碰撞，所以把高低位都参与到计算中，从而解决了这个问题，而且也不会有太大的开销。</p>
<p>看完哈希值是如何计算之后，看看如何通过key和hash获取node。</p>
<h2 id="getNode-int-hash-Object-key"><a href="#getNode-int-hash-Object-key" class="headerlink" title="getNode( int hash, Object key)"></a>getNode( int hash, Object key)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key的哈希值和key获取对应的节点</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 指定参数key的哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定参数key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回node，如果没有则返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="comment">//如果哈希表不为空，而且key对应的桶上不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果桶中的第一个节点就和指定参数hash和key匹配上了</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">//返回桶中的第一个节点</span></span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">//如果桶中的第一个节点没有匹配上，而且有后续节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果当前的桶采用红黑树，则调用红黑树的get方法去获取节点</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//如果当前的桶不采用红黑树，即桶中节点结构为链式结构</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//遍历链表，直到key匹配</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果哈希表为空，或者没有找到节点，返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="get方法总结"><a href="#get方法总结" class="headerlink" title="get方法总结"></a>get方法总结</h3><p>从源码中可以看到，get(E e)可以分为三个步骤：</p>
<ol>
<li>通过hash(Object key)方法计算key的哈希值hash。</li>
<li>通过getNode( int hash, Object key)方法获取node。</li>
<li>如果node为null，返回null，否则返回node.value。</li>
</ol>
<p>hash方法又可分为三步：</p>
<ol>
<li>取key的hashCode第二步</li>
<li>key的hashCode高16位异或低16位</li>
<li>将第一步和第二部得到的结果进行取模运算。</li>
</ol>
<p>getNode方法又可分为以下几个步骤：</p>
<ol>
<li>如果哈希表为空，或key对应的桶为空，返回null</li>
<li>如果桶中的第一个节点就和指定参数hash和key匹配上了，返回这个节点。</li>
<li>如果桶中的第一个节点没有匹配上，而且有后续节点<ol>
<li>如果当前的桶采用红黑树，则调用红黑树的get方法去获取节点</li>
<li>如果当前的桶不采用红黑树，即桶中节点结构为链式结构，遍历链表，直到key匹配</li>
</ol>
</li>
<li>找到节点返回值，否则返回null。</li>
</ol>
<h2 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put( K key, V value)"></a>put( K key, V value)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定参数key和指定参数value插入map中，如果key已经存在，那就替换key对应的value</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果value被替换，则返回旧的value，否则返回null。当然，可能key对应的value就是null。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">//putVal方法的实现就在下面</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中可以看到，put(K key, V value)可以分为三个步骤：</p>
<ol>
<li>通过hash(Object key)方法计算key的哈希值。</li>
<li>通过putVal(hash(key), key, value, false, true)方法实现功能。</li>
<li>返回putVal方法返回的结果。</li>
</ol>
<p>哈希值是如何计算的上面已经写了。下面看看putVal方法是如何实现的。</p>
<h2 id="putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict"><a href="#putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict" class="headerlink" title="putVal( int hash, K key, V value, boolean onlyIfAbsent,boolean evict)"></a>putVal( int hash, K key, V value, boolean onlyIfAbsent,boolean evict)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Map.put和其他相关方法的实现需要的方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 指定参数key的哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定参数key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 指定参数value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent 如果为true，即使指定参数key在map中已经存在，也不会替换value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict 如果为false，数组table在创建模式中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果value被替换，则返回旧的value，否则返回null。当然，可能key对应的value就是null。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,<span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">//如果哈希表为空，调用resize()创建一个哈希表，并用变量n记录哈希表长度</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//如果指定参数hash在表中没有对应的桶，即为没有碰撞</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//直接将键值对插入到map中即可</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//如果碰撞了，且桶中的第一个节点就匹配了</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">//将桶中的第一个节点记录起来</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//如果桶中的第一个节点没有匹配上，且桶内为红黑树结构，则调用红黑树对应的方法插入键值对</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">//不是红黑树结构，那么就肯定是链式结构</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//遍历链式结构</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//如果到了链表尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//在链表尾部插入键值对</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">//如果链的长度大于TREEIFY_THRESHOLD这个临界值，则把链变为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">//跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果找到了重复的key，判断链表中结点的key值与插入的元素的key值是否相等，如果相等，跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果key映射的节点不为null</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="comment">//记录节点的vlaue</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">//如果onlyIfAbsent为false，或者oldValue为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//替换value</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">//访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">//返回节点的旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结构型修改次数+1</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//判断是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">//插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>putVal方法可以分为下面的几个步骤：</p>
<ol>
<li>如果哈希表为空，调用resize()创建一个哈希表。</li>
<li>如果指定参数hash在表中没有对应的桶，即为没有碰撞，直接将键值对插入到哈希表中即可。</li>
<li>如果有碰撞，遍历桶，找到key映射的节点<ol>
<li>桶中的第一个节点就匹配了，将桶中的第一个节点记录起来。</li>
<li>如果桶中的第一个节点没有匹配，且桶中结构为红黑树，则调用红黑树对应的方法插入键值对。</li>
<li>如果不是红黑树，那么就肯定是链表。遍历链表，如果找到了key映射的节点，就记录这个节点，退出循环。如果没有找到，在链表尾部插入节点。插入后，如果链的长度大于TREEIFY_THRESHOLD这个临界值，则使用treeifyBin方法把链表转为红黑树。</li>
</ol>
</li>
<li>如果找到了key映射的节点，且节点不为null<ol>
<li>记录节点的vlaue。</li>
<li>如果参数onlyIfAbsent为false，或者oldValue为null，替换value，否则不替换。</li>
<li>返回记录下来的节点的value。</li>
</ol>
</li>
<li>如果没有找到key映射的节点（2、3步中讲了，这种情况会插入到hashMap中），插入节点后size会加1，这时要检查size是否大于临界值threshold，如果大于会使用resize方法进行扩容。</li>
</ol>
<h2 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h2><p>向hashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，hashMap就需要扩大数组的长度，以便能装入更多的元素。当然数组是无法自动扩容的，扩容方法使用一个新的数组代替已有的容量小的数组。</p>
<p>resize方法非常巧妙，因为每次扩容都是翻倍，与原来计算（n-1）&amp;hash的结果相比，节点要么就在原来的位置，要么就被分配到“原位置+旧容量”这个位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对table进行初始化或者扩容。</span></span><br><span class="line"><span class="comment"> * 如果table为null，则对table进行初始化</span></span><br><span class="line"><span class="comment"> * 如果对table扩容，因为每次扩容都是翻倍，与原来计算（n-1）&amp;hash的结果相比，节点要么就在原来的位置，要么就被分配到“原位置+旧容量”这个位置。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">//新建oldTab数组保存扩容前的数组table</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//使用变量oldCap扩容前table的容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">//保存扩容前的临界值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果扩容前的容量 &gt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果当前容量&gt;=MAXIMUM_CAPACITY</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">//扩容临界值提高到正无穷</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="comment">//无法进行扩容，返回原来的数组</span></span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果现在容量的两倍小于MAXIMUM_CAPACITY且现在的容量大于DEFAULT_INITIAL_CAPACITY</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">//临界值变为原来的2倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; </span><br><span class="line">    &#125;<span class="comment">//如果旧容量 &lt;= 0，而且旧临界值 &gt; 0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) </span><br><span class="line">        <span class="comment">//数组的新容量设置为老数组扩容的临界值</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//如果旧容量 &lt;= 0，且旧临界值 &lt;= 0，新容量扩充为默认初始化容量，新临界值为DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;<span class="comment">//在当上面的条件判断中，只有oldThr &gt; 0成立时，newThr == 0</span></span><br><span class="line">        <span class="comment">//ft为临时临界值，下面会确定这个临界值是否合法，如果合法，那就是真正的临界值</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        <span class="comment">//当新容量&lt; MAXIMUM_CAPACITY且ft &lt; (float)MAXIMUM_CAPACITY，新的临界值为ft，否则为Integer.MAX_VALUE</span></span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将扩容后hashMap的临界值设置为newThr</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">//创建新的table，初始化容量为newCap</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    <span class="comment">//修改hashMap的table为新建的newTab</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//如果旧table不为空，将旧table中的元素复制到新的table中</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历旧哈希表的每个桶，将旧哈希表中的桶复制到新的哈希表中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">//如果旧桶不为null，使用e记录旧桶</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//将旧桶置为null</span></span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//如果旧桶中只有一个node</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">//将e也就是oldTab[j]放入newTab中e.hash &amp; (newCap - 1)的位置</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//如果旧桶中的结构为红黑树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//将树中的node分离</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">//如果旧桶中的结构为链表，讲旧桶中元素按照hash值分装到高位和低位两个桶中</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">//遍历整个链表中的节点</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">//</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看到，扩容很耗性能。所以在使用HashMap的时候，先估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</p>
<p>看完代码后，可以将resize的步骤总结为</p>
<ol>
<li>计算扩容后的容量，临界值。</li>
<li>将hashMap的临界值修改为扩容后的临界值</li>
<li>根据扩容后的容量新建数组，然后将hashMap的table的引用指向新数组。</li>
<li>将旧数组的元素复制到table中。</li>
</ol>
<h2 id="remove-Object-key"><a href="#remove-Object-key" class="headerlink" title="remove( Object key)"></a>remove( Object key)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除hashMap中key映射的node</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  key 参数key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果没有映射到node，返回null，否则返回对应的value。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//根据key来删除node。removeNode方法的具体实现在下面</span></span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">        <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中可以看到，remove方法的实现可以分为三个步骤：</p>
<ol>
<li>通过hash(Object key)方法计算key的哈希值。</li>
<li>通过removeNode方法实现功能。</li>
<li>返回被删除的node的value。</li>
</ol>
<p>下面看看removeNode方法的具体实现</p>
<h2 id="removeNode-int-hash-Object-key-Object-value-boolean-matchValue-boolean-movable"><a href="#removeNode-int-hash-Object-key-Object-value-boolean-matchValue-boolean-movable" class="headerlink" title="removeNode( int hash, Object key, Object value,boolean matchValue, boolean movable)"></a>removeNode( int hash, Object key, Object value,boolean matchValue, boolean movable)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Map.remove和相关方法的实现需要的方法</span></span><br><span class="line"><span class="comment"> * 删除node</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash key的哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 参数key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 如果matchValue为true，则value也作为确定被删除的node的条件之一，否则忽略</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matchValue 如果为true，则value也作为确定被删除的node的条件之一</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> movable 如果为false，删除node时不会删除其他node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回被删除的node，如果没有node被删除，则返回null（针对红黑树的删除方法）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,<span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">    <span class="comment">//如果数组table不为空且key映射到的桶不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">//如果桶上第一个node的就是要删除的node</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">//记录桶上第一个node</span></span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;<span class="comment">//如果桶内不止一个node</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)<span class="comment">//如果桶内的结构为红黑树</span></span><br><span class="line">                <span class="comment">//记录key映射到的node</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//如果桶内的结构为链表</span></span><br><span class="line">                <span class="keyword">do</span> &#123;<span class="comment">//遍历链表，找到key映射到的node</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        <span class="comment">//记录key映射到的node</span></span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果得到的node不为null且(matchValue为false||node.value和参数value匹配)</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value || (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">//如果桶内的结构为红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">//使用红黑树的删除方法删除node</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)<span class="comment">//如果桶的第一个node的就是要删除的node</span></span><br><span class="line">                <span class="comment">//删除node</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//如果桶内的结构为链表，使用链表删除元素的方式删除node</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            <span class="comment">//结构性修改次数+1</span></span><br><span class="line">            ++modCount;</span><br><span class="line">            <span class="comment">//哈希表大小-1</span></span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="comment">//返回被删除的node</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果数组table为空或key映射到的桶为空，返回null。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完代码后，可以将removeNode方法的步骤总结为</p>
<ol>
<li>如果数组table为空或key映射到的桶为空，返回null。</li>
<li>如果key映射到的桶上第一个node的就是要删除的node，记录下来。</li>
<li>如果桶内不止一个node，且桶内的结构为红黑树，记录key映射到的node。</li>
<li>桶内的结构不为红黑树，那么桶内的结构就肯定为链表，遍历链表，找到key映射到的node，记录下来。</li>
<li>如果被记录下来的node不为null，删除node，size-1被删除。</li>
<li>返回被删除的node。</li>
</ol>
<h1 id="静态公用方法"><a href="#静态公用方法" class="headerlink" title="静态公用方法"></a>静态公用方法</h1><h2 id="hash-Object-key"><a href="#hash-Object-key" class="headerlink" title="hash( Object key)"></a>hash( Object key)</h2><p>该方法已在【核心方法】中详细讲解了，这里不做重复讲解。</p>
<h2 id="comparableClassFor-Object-x"><a href="#comparableClassFor-Object-x" class="headerlink" title="comparableClassFor( Object x)"></a>comparableClassFor( Object x)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果参数x实现了Comparable接口，返回参数x的类名，否则返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">        Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;</span><br><span class="line">        <span class="keyword">if</span> ((c = x.getClass()) == String.class) <span class="comment">// bypass checks</span></span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        <span class="keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ts.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((t = ts[i]) <span class="keyword">instanceof</span> ParameterizedType) &amp;&amp;</span><br><span class="line">                    ((p = (ParameterizedType)t).getRawType() ==</span><br><span class="line">                     Comparable.class) &amp;&amp;</span><br><span class="line">                    (as = p.getActualTypeArguments()) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                    as.length == <span class="number">1</span> &amp;&amp; as[<span class="number">0</span>] == c) <span class="comment">// type arg is c</span></span><br><span class="line">                    <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="compareComparables-Class-lt-gt-kc-Object-k-Object-x"><a href="#compareComparables-Class-lt-gt-kc-Object-k-Object-x" class="headerlink" title="compareComparables( Class&lt;?&gt; kc, Object k, Object x)"></a>compareComparables( Class&lt;?&gt; kc, Object k, Object x)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果x的类型为kc，则返回k.compareTo(x)，否则返回0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span> <span class="comment">// for cast to Comparable</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compareComparables</span><span class="params">(Class&lt;?&gt; kc, Object k, Object x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (x == <span class="literal">null</span> || x.getClass() != kc ? <span class="number">0</span> :</span><br><span class="line">            ((Comparable)k).compareTo(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="tableSizeFor-int-cap"><a href="#tableSizeFor-int-cap" class="headerlink" title="tableSizeFor( int cap)"></a>tableSizeFor( int cap)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回大于等于cap的最小的二次幂数值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="域"><a href="#域" class="headerlink" title="域"></a>域</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储键值对的数组，一般是2的幂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 键值对缓存，它们的映射关系集合保存在entrySet中。即使Key在外部修改导致hashCode变化，缓存中还可以找到映射关系</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 键值对的实际个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 记录HashMap被修改结构的次数。</span></span><br><span class="line"><span class="comment"> * 修改包括改变键值对的个数或者修改内部结构，比如rehash</span></span><br><span class="line"><span class="comment"> * 这个域被用作HashMap的迭代器的fail-fast机制中（参考ConcurrentModificationException）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容的临界值，通过capacity * load factor可以计算出来。超过这个值HashMap将进行扩容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载因子</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><h2 id="HashMap-int-initialCapacity-float-loadFactor"><a href="#HashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="HashMap( int initialCapacity, float loadFactor)"></a>HashMap( int initialCapacity, float loadFactor)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用指定的初始化容量initial capacity 和加载因子load factor构造一个空HashMap</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity 初始化容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  loadFactor      加载因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果指定的初始化容量为负数或者加载因子为非正数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap-int-initialCapacity"><a href="#HashMap-int-initialCapacity" class="headerlink" title="HashMap( int initialCapacity)"></a>HashMap( int initialCapacity)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用指定的初始化容量initial capacity和默认加载因子DEFAULT_LOAD_FACTOR（0.75）构造一个空HashMap</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity 初始化容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果指定的初始化容量为负数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap()"></a>HashMap()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用指定的初始化容量（16）和默认加载因子DEFAULT_LOAD_FACTOR（0.75）构造一个空HashMap</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap-Map-lt-extends-K-extends-V-gt-m"><a href="#HashMap-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="HashMap( Map&lt;? extends K, ? extends V&gt;m)"></a>HashMap( Map&lt;? extends K, ? extends V&gt;m)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用指定Map m构造新的HashMap。使用指定的初始化容量（16）和默认加载因子DEFAULT_LOAD_FACTOR（0.75）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   m 指定的map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  NullPointerException 如果指定的map是null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><h2 id="putMapEntries-Map-lt-extends-K-extends-V-gt-m-boolean-evict"><a href="#putMapEntries-Map-lt-extends-K-extends-V-gt-m-boolean-evict" class="headerlink" title="putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict)"></a>putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Map.putAll and Map constructor的实现需要的方法。</span></span><br><span class="line"><span class="comment"> * 将m的键值对插入本map中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m the map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict 初始化map时使用false，否则使用true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">    <span class="comment">//如果参数map不为空</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果table没有初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">//前面讲到，initial capacity*load factor就是当前hashMap允许的最大元素数目。那么不难理解，s/loadFactor+1即为应该初始化的容量。</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="comment">//如果ft小于最大容量MAXIMUM_CAPACITY，则容量为ft，否则容量为最大容量MAXIMUM_CAPACITY</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">//如果容量大于临界值</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                <span class="comment">//根据容量初始化临界值</span></span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//table已经初始化，并且map的大小大于临界值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            <span class="comment">//扩容处理</span></span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">//将map中所有键值对添加到hashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            <span class="comment">//putVal方法的实现在下面</span></span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回map中键值对映射的个数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> map中键值对映射的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty()"></a>isEmpty()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果map中没有键值对映射，返回true</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;如果map中没有键值对映射，返回true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">return</span> <span class="variable">size</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="get-Object-key-1"><a href="#get-Object-key-1" class="headerlink" title="get( Object key)"></a>get( Object key)</h2><p>该方法已在【核心方法】中详细讲解了，这里不做重复讲解。</p>
<h2 id="getNode-int-hash-Object-key-1"><a href="#getNode-int-hash-Object-key-1" class="headerlink" title="getNode( int hash, Object key)"></a>getNode( int hash, Object key)</h2><p>该方法已在【核心方法】中详细讲解了，这里不做重复讲解。</p>
<h2 id="containsKey-Object-key"><a href="#containsKey-Object-key" class="headerlink" title="containsKey( Object key)"></a>containsKey( Object key)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果map中含有key为指定参数key的键值对，返回true</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   key   指定参数key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果map中含有key为指定参数key的键值对，返回true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="put-K-key-V-value-1"><a href="#put-K-key-V-value-1" class="headerlink" title="put( K key, V value)"></a>put( K key, V value)</h2><p>该方法已在【核心方法】中详细讲解了，这里不做重复讲解。</p>
<h2 id="putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict-1"><a href="#putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict-1" class="headerlink" title="putVal( int hash, K key, V value, boolean onlyIfAbsent,boolean evict)"></a>putVal( int hash, K key, V value, boolean onlyIfAbsent,boolean evict)</h2><p>该方法已在【核心方法】中详细讲解了，这里不做重复讲解。</p>
<h2 id="扩容resize"><a href="#扩容resize" class="headerlink" title="扩容resize()"></a>扩容resize()</h2><p>该方法已在【核心方法】中详细讲解了，这里不做重复讲解。</p>
<h2 id="treeifyBin-Node-lt-K-V-gt-tab-int-hash"><a href="#treeifyBin-Node-lt-K-V-gt-tab-int-hash" class="headerlink" title="treeifyBin( Node&lt;K,V&gt;[] tab, int hash)"></a>treeifyBin( Node&lt;K,V&gt;[] tab, int hash)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将链表转化为红黑树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//如果桶数组table为空，或者桶数组table的长度小于MIN_TREEIFY_CAPACITY，不符合转化为红黑树的条件</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        <span class="comment">//扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;<span class="comment">//如果符合转化为红黑树的条件，而且hash对应的桶不为null</span></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//替换链表node为树node，建立双向链表</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//遍历链表插入每个节点到红黑树</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="putAll-Map-lt-extends-K-extends-V-gt-m"><a href="#putAll-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="putAll( Map&lt;? extends K, ? extends V&gt; m)"></a>putAll( Map&lt;? extends K, ? extends V&gt; m)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将参数map中的所有键值对映射插入到hashMap中，如果有碰撞，则覆盖value。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 参数map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果map为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    putMapEntries(m, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="remove-Object-key-1"><a href="#remove-Object-key-1" class="headerlink" title="remove( Object key)"></a>remove( Object key)</h2><p>该方法已在【核心方法】中详细讲解了，这里不做重复讲解。</p>
<h2 id="removeNode-int-hash-Object-key-Object-value-boolean-matchValue-boolean-movable-1"><a href="#removeNode-int-hash-Object-key-Object-value-boolean-matchValue-boolean-movable-1" class="headerlink" title="removeNode( int hash, Object key, Object value,boolean matchValue, boolean movable)"></a>removeNode( int hash, Object key, Object value,boolean matchValue, boolean movable)</h2><p>该方法已在【核心方法】中详细讲解了，这里不做重复讲解。</p>
<h2 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除map中所有的键值对</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">            tab[i] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="containsValue-Object-value"><a href="#containsValue-Object-value" class="headerlink" title="containsValue( Object value)"></a>containsValue( Object value)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果hashMap中的键值对有一对或多对的value为参数value，返回true</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 参数value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果hashMap中的键值对有一对或多对的value为参数value，返回true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历数组table</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="comment">//遍历桶中的node</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                    (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><h2 id="keySet"><a href="#keySet" class="headerlink" title="keySet()"></a>keySet()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回hashMap中所有key的视图。</span></span><br><span class="line"><span class="comment"> * 改变hashMap会影响到set，反之亦然。</span></span><br><span class="line"><span class="comment"> * 如果当迭代器迭代set时，hashMap被修改(除非是迭代器自己的remove()方法)，迭代器的结果是不确定的。</span></span><br><span class="line"><span class="comment"> * set支持元素的删除，通过Iterator.remove、Set.remove、removeAll、retainAll、clear操作删除hashMap中对应的键值对。不支持add和addAll方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回hashMap中所有key的set视图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Set&lt;K&gt; ks = keySet;</span><br><span class="line">    <span class="keyword">if</span> (ks == <span class="literal">null</span>) &#123;</span><br><span class="line">        ks = <span class="keyword">new</span> <span class="title class_">KeySet</span>();</span><br><span class="line">        keySet = ks;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内部类KeySet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">KeySet</span> <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;K&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>                 &#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>               &#123; HashMap.<span class="built_in">this</span>.clear(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title function_">iterator</span><span class="params">()</span>     &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeyIterator</span>(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123; <span class="keyword">return</span> containsKey(o); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;K&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeySpliterator</span>&lt;&gt;(HashMap.<span class="built_in">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> K&gt; action)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="values"><a href="#values" class="headerlink" title="values()"></a>values()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回hashMap中所有value的collection视图</span></span><br><span class="line"><span class="comment"> * 改变hashMap会改变collection，反之亦然。</span></span><br><span class="line"><span class="comment"> * 如果当迭代器迭代collection时，hashMap被修改（除非是迭代器自己的remove()方法），迭代器的结果是不确定的。</span></span><br><span class="line"><span class="comment"> * collection支持元素的删除，通过Iterator.remove、Collection.remove、removeAll、retainAll、clear操作删除hashMap中对应的键值对。不支持add和addAll方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回hashMap中所有key的collection视图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span> &#123;</span><br><span class="line">    Collection&lt;V&gt; vs = values;</span><br><span class="line">    <span class="keyword">if</span> (vs == <span class="literal">null</span>) &#123;</span><br><span class="line">        vs = <span class="keyword">new</span> <span class="title class_">Values</span>();</span><br><span class="line">        values = vs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内部类Values</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Values</span> <span class="keyword">extends</span> <span class="title class_">AbstractCollection</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>                 &#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>               &#123; HashMap.<span class="built_in">this</span>.clear(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;V&gt; <span class="title function_">iterator</span><span class="params">()</span>     &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ValueIterator</span>(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123; <span class="keyword">return</span> containsValue(o); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;V&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ValueSpliterator</span>&lt;&gt;(HashMap.<span class="built_in">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> V&gt; action)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e.value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="entrySet"><a href="#entrySet" class="headerlink" title="entrySet()"></a>entrySet()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回hashMap中所有键值对的set视图</span></span><br><span class="line"><span class="comment"> * 改变hashMap会影响到set，反之亦然。</span></span><br><span class="line"><span class="comment"> * 如果当迭代器迭代set时，hashMap被修改(除非是迭代器自己的remove()方法)，迭代器的结果是不确定的。</span></span><br><span class="line"><span class="comment"> * set支持元素的删除，通过Iterator.remove、Set.remove、removeAll、retainAll、clear操作删除hashMap中对应的键值对。不支持add和addAll方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回hashMap中所有键值对的set视图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="literal">null</span> ? (entrySet = <span class="keyword">new</span> <span class="title class_">EntrySet</span>()) : es;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内部类EntrySet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">EntrySet</span> <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>                 &#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>               &#123; HashMap.<span class="built_in">this</span>.clear(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EntryIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">        Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">        <span class="keyword">return</span> candidate != <span class="literal">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>) != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EntrySpliterator</span>&lt;&gt;(HashMap.<span class="built_in">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mc</span> <span class="operator">=</span> modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JDK8重写的方法"><a href="#JDK8重写的方法" class="headerlink" title="JDK8重写的方法"></a>JDK8重写的方法</h1><h2 id="getOrDefault-Object-key-V-defaultValue"><a href="#getOrDefault-Object-key-V-defaultValue" class="headerlink" title="getOrDefault( Object key, V defaultValue)"></a>getOrDefault( Object key, V defaultValue)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过key映射到对应node，如果没映射到则返回默认值defaultValue</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> key映射到对应的node，如果没映射到则返回默认值defaultValue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? defaultValue : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="putIfAbsent-K-key-V-value"><a href="#putIfAbsent-K-key-V-value" class="headerlink" title="putIfAbsent( K key, V value)"></a>putIfAbsent( K key, V value)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在hashMap中插入参数key和value组成的键值对，如果key在hashMap中已经存在，不替换value</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果key在hashMap中不存在，返回旧value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="remove-Object-key-Object-value"><a href="#remove-Object-key-Object-value" class="headerlink" title="remove( Object key, Object value)"></a>remove( Object key, Object value)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除hashMap中key为参数key，value为参数value的键值对。如果桶中结构为树，则级联删除</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 删除成功，返回true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key, Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="literal">true</span>, <span class="literal">true</span>) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="replace-K-key-V-oldValue-V-newValue"><a href="#replace-K-key-V-oldValue-V-newValue" class="headerlink" title="replace( K key, V oldValue, V newValue)"></a>replace( K key, V oldValue, V newValue)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用newValue替换key和oldValue映射到的键值对中的value</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 替换成功，返回true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">replace</span><span class="params">(K key, V oldValue, V newValue)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e; V v;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        ((v = e.value) == oldValue || (v != <span class="literal">null</span> &amp;&amp; v.equals(oldValue)))) &#123;</span><br><span class="line">        e.value = newValue;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="replace-K-key-V-value"><a href="#replace-K-key-V-value" class="headerlink" title="replace( K key, V value)"></a>replace( K key, V value)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用参数value替换key映射到的键值对中的value</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 替换成功，返回true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">replace</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">        e.value = value;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 浅拷贝。</span></span><br><span class="line"><span class="comment"> * clone方法虽然生成了新的HashMap对象，新的HashMap中的table数组虽然也是新生成的，但是数组中的元素还是引用以前的HashMap中的元素。</span></span><br><span class="line"><span class="comment"> * 这就导致在对HashMap中的元素进行修改的时候，即对数组中元素进行修改，会导致原对象和clone对象都发生改变，但进行新增或删除就不会影响对方，因为这相当于是对数组做出的改变，clone对象新生成了一个数组。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> hashMap的浅拷贝</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    HashMap&lt;K,V&gt; result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = (HashMap&lt;K,V&gt;)<span class="built_in">super</span>.clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn&#x27;t happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    result.reinitialize();</span><br><span class="line">    result.putMapEntries(<span class="built_in">this</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="loadFactor"><a href="#loadFactor" class="headerlink" title="loadFactor()"></a>loadFactor()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// These methods are also used when serializing HashSets</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> <span class="title function_">loadFactor</span><span class="params">()</span> &#123; <span class="keyword">return</span> loadFactor; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="capacity"><a href="#capacity" class="headerlink" title="capacity()"></a>capacity()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// These methods are also used when serializing HashSets</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">capacity</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (table != <span class="literal">null</span>) ? table.length :</span><br><span class="line">        (threshold &gt; <span class="number">0</span>) ? threshold :</span><br><span class="line">        DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="writeObject-java-io-ObjectOutputStream-s"><a href="#writeObject-java-io-ObjectOutputStream-s" class="headerlink" title="writeObject( java.io.ObjectOutputStream s)"></a>writeObject( java.io.ObjectOutputStream s)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化hashMap到ObjectOutputStream中</span></span><br><span class="line"><span class="comment"> * 将hashMap的总容量capacity、实际容量size、键值对映射写入到ObjectOutputStream中。键值对映射序列化时是无序的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">buckets</span> <span class="operator">=</span> capacity();</span><br><span class="line">    <span class="comment">// Write out the threshold, loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    <span class="comment">//写入总容量</span></span><br><span class="line">    s.writeInt(buckets);</span><br><span class="line">    <span class="comment">//写入实际容量</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line">    <span class="comment">//写入键值对</span></span><br><span class="line">    internalWriteEntries(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入hashMap键值对到ObjectOutputStream中</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">internalWriteEntries</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                s.writeObject(e.key);</span><br><span class="line">                s.writeObject(e.value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="readObject-java-io-ObjectInputStream-s"><a href="#readObject-java-io-ObjectInputStream-s" class="headerlink" title="readObject( java.io.ObjectInputStream s)"></a>readObject( java.io.ObjectInputStream s)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 到ObjectOutputStream中读取hashMap</span></span><br><span class="line"><span class="comment"> * 将hashMap的总容量capacity、实际容量size、键值对映射读取出来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 将hashMap的总容量capacity、实际容量size、键值对映射读取出来</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    <span class="comment">//重置hashMap</span></span><br><span class="line">    reinitialize();</span><br><span class="line">    <span class="comment">//如果加载因子不合法，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">    <span class="comment">//读出桶的数量，忽略</span></span><br><span class="line">    s.readInt();                <span class="comment">// Read and ignore number of buckets</span></span><br><span class="line">    <span class="comment">//读出实际容量size</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mappings</span> <span class="operator">=</span> s.readInt(); <span class="comment">// Read number of mappings (size)</span></span><br><span class="line">    <span class="comment">//如果读出的实际容量size小于0，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal mappings count: &quot;</span> + mappings);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// (if zero, use defaults)</span></span><br><span class="line">        <span class="comment">//调整hashMap大小</span></span><br><span class="line">        <span class="comment">// Size the table using given load factor only if within range of 0.25...4.0。为什么？</span></span><br><span class="line">        <span class="comment">// 加载因子</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">lf</span> <span class="operator">=</span> Math.min(Math.max(<span class="number">0.25f</span>, loadFactor), <span class="number">4.0f</span>);</span><br><span class="line">        <span class="comment">//初步得到的总容量，后续还会处理</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">fc</span> <span class="operator">=</span> (<span class="type">float</span>)mappings / lf + <span class="number">1.0f</span>;</span><br><span class="line">        <span class="comment">//处理初步得到的容量，确认最终的总容量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                   DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                   (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor((<span class="type">int</span>)fc));</span><br><span class="line">        <span class="comment">//计算临界值，得到初步的临界值</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)cap * lf;</span><br><span class="line">        <span class="comment">//得到最终的临界值</span></span><br><span class="line">        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ? (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        <span class="comment">//新建桶数组table</span></span><br><span class="line">            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[cap];</span><br><span class="line">        table = tab;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读出key和value，并组成键值对插入hashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原文链接：<a href="https://blog.csdn.net/panweiwei1994/article/details/77244920">https://blog.csdn.net/panweiwei1994/article/details/77244920</a></p>
]]></content>
      <categories>
        <category>java</category>
        <category>container</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>java CurrencHashMap 详解</title>
    <url>/2021/05/14/java/container/java-currenchashmap/</url>
    <content><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>在涉及到Java多线程开发时，如果我们使用HashMap可能会导致死锁问题，使用HashTable效率又不高。而ConcurrentHashMap既可以保持同步也可以提高并发效率，所以这个时候ConcurrentHashmap是我们最好的选择。</p>
<h4 id="为什么使用ConcurrentHashMap"><a href="#为什么使用ConcurrentHashMap" class="headerlink" title="为什么使用ConcurrentHashMap"></a>为什么使用ConcurrentHashMap</h4><ul>
<li><p>在多线程环境中使用HashMap的put方法有可能导致程序死循环，因为多线程可能会导致HashMap形成环形链表，即链表的一个节点的next节点永不为null，就会产生死循环。这时，CPU的利用率接近100%，所以并发情况下不能使用HashMap。</p>
</li>
<li><p>HashTable通过使用synchronized保证线程安全，但在线程竞争激烈的情况下效率低下。因为当一个线程访问HashTable的同步方法时，其他线程只能阻塞等待占用线程操作完毕。</p>
</li>
<li><p>ConcurrentHashMap使用分段锁的思想，对于不同的数据段使用不同的锁，可以支持多个线程同时访问不同的数据段，这样线程之间就不存在锁竞争，从而提高了并发效率。</p>
</li>
</ul>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在阅读ConcurrentHashMap的源码时，有一段相关描述。</p>
<p>The primary design goal of this hash table is to maintain concurrent readability(typically method get(), but also iterators and related methods) while minimizing update contention. Secondary goals are to keep space consumption about the same or better than java.util.HashMap, and to support high initial insertion rates on an empty table by many threads.</p>
<p>大致意思就是： ConcurrentHashMap的主要设计目的是保持并发的可读性（通常是指的get()方法的使用，同时也包括迭代器和相关方法），同时最小化更新征用（即在进行插入操作或者扩容时也可以保持其他数据段的访问）。第二个目标就是在空间利用方面保持与HashMap一致或者更好，并且支持多线程在空表的初始插入速率。</p>
<h4 id="Java7与Java8中的ConcurrentHashMap："><a href="#Java7与Java8中的ConcurrentHashMap：" class="headerlink" title="Java7与Java8中的ConcurrentHashMap："></a>Java7与Java8中的ConcurrentHashMap：</h4><p>在ConcurrentHashMap中主要通过锁分段技术实现上述目标。</p>
<p>在Java7中，ConcurrentHashMap由Segment数组结构和HashEntry数组组成。Segment是一种可重入锁，是一种数组和链表的结构，一个Segment中包含一个HashEntry数组，每个HashEntry又是一个链表结构。正是通过Segment分段锁，ConcurrentHashMap实现了高效率的并发。</p>
<p>在Java8中，ConcurrentHashMap去除了Segment分段锁的数据结构，主要是基于CAS操作保证保证数据的获取以及使用synchronized关键字对相应数据段加锁实现了主要功能，这进一步提高了并发性。同时同时为了提高哈希碰撞下的寻址性能，Java 8在链表长度超过一定阈值(8)时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(long(N)))。</p>
<h4 id="Java8中ConcurrentHashMap的结构"><a href="#Java8中ConcurrentHashMap的结构" class="headerlink" title="Java8中ConcurrentHashMap的结构"></a>Java8中ConcurrentHashMap的结构</h4><p>在Java8中，ConcurrentHashMap弃用了Segment类，但是保留了Segment属性，用于序列化。目前ConcurrentHashMap采用Node类作为基本的存储单元，每个键值对(key-value)都存储在一个Node中。同时Node也有一些子类，TreeNodes用于树结构中（当链表长度大于8时转化为红黑树）；TreeBins用于维护TreeNodes。当链表转树时，用于封装TreeNode。也就是说，ConcurrentHashMap的红黑树存放的是TreeBin，而不是treeNode；ForwordingNodes是一个重要的结构，它用于ConcurrentHashMap扩容时，是一个标志节点，内部有一个指向nextTable的属性，同时也提供了查找的方法；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V val;  <span class="comment">//使用了volatile属性</span></span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;  <span class="comment">//使用了volatile属性</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="type">int</span> hash, K key, V val) &#123;</span><br><span class="line">            <span class="built_in">this</span>.hash = hash;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">        Node(<span class="type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>(hash, key, val);</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>     &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>   &#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123; <span class="keyword">return</span> key.hashCode() ^ val.hashCode(); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V value)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Virtualized support for map.get(); overridden in subclasses.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node&lt;K,V&gt; <span class="title function_">find</span><span class="params">(<span class="type">int</span> h, Object k)</span> &#123;...&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>处理Node之外，Node的一个子类ForwardingNodes也是一个重要的结构，它主要作为一个标记，在处理并发时起着关键作用，有了ForwardingNodes，也是ConcurrentHashMap有了分段的特性，提高了并发效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * A node inserted at head of bins during transfer operations.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">       ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="comment">//hash值默认为MOVED(-1)</span></span><br><span class="line">           <span class="built_in">super</span>(MOVED, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">           <span class="built_in">this</span>.nextTable = tab;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Node&lt;K,V&gt; <span class="title function_">find</span><span class="params">(<span class="type">int</span> h, Object k)</span> &#123;</span><br><span class="line">           <span class="comment">// loop to avoid arbitrarily deep recursion on forwarding nodes</span></span><br><span class="line">           <span class="comment">//在nextTable中查找，nextTable可以看做是当前hash表的一个副本</span></span><br><span class="line">           outer: <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = nextTable;;) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e; <span class="type">int</span> n;</span><br><span class="line">               <span class="keyword">if</span> (k == <span class="literal">null</span> || tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">                   (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) == <span class="literal">null</span>)</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">               <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                   <span class="type">int</span> eh; K ek;</span><br><span class="line">                   <span class="keyword">if</span> ((eh = e.hash) == h &amp;&amp;</span><br><span class="line">                       ((ek = e.key) == k || (ek != <span class="literal">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                       <span class="keyword">return</span> e;</span><br><span class="line">                   <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ForwardingNode) &#123;</span><br><span class="line">                           tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;</span><br><span class="line">                           <span class="keyword">continue</span> outer;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">else</span></span><br><span class="line">                           <span class="keyword">return</span> e.find(h, k);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>)</span><br><span class="line">                       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ConcurrentHashMap中的原子操作"><a href="#ConcurrentHashMap中的原子操作" class="headerlink" title="ConcurrentHashMap中的原子操作"></a>ConcurrentHashMap中的原子操作</h3><p>在ConcurrentHashMap中通过原子操作查找元素、替换元素和设置元素。这些原子操作起着非常关键的作用，你可以在所有ConcurrentHashMap的基本功能中看到它们的身影。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="title function_">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectAcquire(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i,</span></span><br><span class="line"><span class="params">                                        Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> U.compareAndSetObject(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="keyword">void</span> <span class="title function_">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i, Node&lt;K,V&gt; v)</span> &#123;</span><br><span class="line">        U.putObjectRelease(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ConcurrentHashMap的功能实现"><a href="#ConcurrentHashMap的功能实现" class="headerlink" title="ConcurrentHashMap的功能实现"></a>ConcurrentHashMap的功能实现</h3><p><strong>1.ConcurrentHashMap初始化</strong></p>
<p>在介绍初始化之前先介绍一个重要的参数sizeCtl，含义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Table initialization and resizing control.  When negative,the</span></span><br><span class="line"><span class="comment">    * table is being initialized or resized: -1 for initialization,</span></span><br><span class="line"><span class="comment">    * else -(1 + the number of active resizing threads). Otherwise,</span></span><br><span class="line"><span class="comment">    * when table is null, holds the initial table size to use upon</span></span><br><span class="line"><span class="comment">    * creation, or 0 for default. After initialization, holds the</span></span><br><span class="line"><span class="comment">    * next element count value upon which to resize the table.</span></span><br><span class="line"><span class="comment">    * Hash表的初始化和调整大小的控制标志。为负数，Hash表正在初始化或者扩容;</span></span><br><span class="line"><span class="comment">    * (-1表示正在初始化,-N表示有N-1个线程在进行扩容)</span></span><br><span class="line"><span class="comment">    * 否则，当表为null时，保存创建时使用的初始化大小或者默认0;</span></span><br><span class="line"><span class="comment">    * 初始化以后保存下一个调整大小的尺寸。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> sizeCtl;</span><br></pre></td></tr></table></figure>

<p>这个参数起到一个控制标志的作用，在ConcurrentHashMap初始化和扩容都有用到。 ConcurrentHashMap构造函数只是设置了一些参数，并没有对Hash表进行初始化。当在从插入元素时，才会初始化Hash表。在开始初始化的时候，首先判断sizeCtl的值，如果sizeCtl &lt; 0，说明有线程在初始化，当前线程便放弃初始化操作。否则，将SIZECTL设置为-1，Hash表进行初始化。初始化成功以后，将sizeCtl的值设置为当前的容量值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">        <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">	        <span class="comment">//sizeCtl小于0，正在初始化</span></span><br><span class="line">            <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//调用yield()函数，使线程让出CPU资源</span></span><br><span class="line">                Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">            <span class="comment">//设置SIZECTL为-1，表示正在初始化</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSetInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                        table = tab = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>); <span class="comment">//n-(1/4)n,即默认的容量(n * loadFactor)</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sizeCtl = sc; <span class="comment">//重新设置sizeCtl</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.确定元素在Hash表的索引</strong></p>
<p>通过hash算法可以将元素分散到哈希桶中。在ConcurrentHashMap中通过如下方法确定数组索引： 第一步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">spread</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>第二步：(length-1) &amp; (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS);</p>
<h3 id="ConcurrentHashMap的put方法"><a href="#ConcurrentHashMap的put方法" class="headerlink" title="ConcurrentHashMap的put方法"></a>ConcurrentHashMap的put方法</h3><ul>
<li><p>如果key或者value为null，则抛出空指针异常；</p>
</li>
<li><p>如果table为null或者table的长度为0，则初始化table，调用initTable()方法。</p>
</li>
<li><p>计算当前键值的索引位置，如果Hash表中当前节点为null，则将元素直接插入。(注意，这里使用的就是前面锁说的CAS操作)</p>
</li>
<li><p>如果当前位置的节点元素的hash值为-1，说明这是一个ForwaringNodes节点，即正在进行扩容。那么当前线程加入扩容。</p>
</li>
<li><p>当前节点不为null，对当前节点加锁，将元素插入到当前节点。在Java8中，当节点长度大于8时，就将节点转为树的结构。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">	<span class="comment">//数据不合法，抛出异常</span></span><br><span class="line">       <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">       <span class="comment">//计算索引的第一步，传入键值的hash值</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">       <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//保存当前节点的长度</span></span><br><span class="line">       <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">           Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh; K fk; V fv;</span><br><span class="line">           <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">               tab = initTable(); <span class="comment">//初始化Hash表</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//利用CAS操作将元素插入到Hash表中</span></span><br><span class="line">               <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value)))</span><br><span class="line">                   <span class="keyword">break</span>;  <span class="comment">// no lock when adding to empty bin(插入null的节点，无需加锁)</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) <span class="comment">//f.hash == -1 </span></span><br><span class="line">            <span class="comment">//正在扩容，当前线程加入扩容</span></span><br><span class="line">               tab = helpTransfer(tab, f);</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (onlyIfAbsent &amp;&amp; fh == hash &amp;&amp;  <span class="comment">// check first node</span></span><br><span class="line">                    ((fk = f.key) == key || fk != <span class="literal">null</span> &amp;&amp; key.equals(fk)) &amp;&amp;</span><br><span class="line">                    (fv = f.val) != <span class="literal">null</span>)</span><br><span class="line">               <span class="keyword">return</span> fv;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">               <span class="comment">//当前节点加锁</span></span><br><span class="line">               <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                           binCount = <span class="number">1</span>;</span><br><span class="line">                           <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                               K ek;</span><br><span class="line">                               <span class="comment">//插入的元素键值的hash值有节点中元素的hash值相同，替换当前元素的值</span></span><br><span class="line">                               <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                   ((ek = e.key) == key ||</span><br><span class="line">                                    (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                   oldVal = e.val;</span><br><span class="line">                                   <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    <span class="comment">//替换当前元素的值</span></span><br><span class="line">                                       e.val = value;</span><br><span class="line">                                   <span class="keyword">break</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">                               Node&lt;K,V&gt; pred = e;</span><br><span class="line">                               <span class="comment">//没有相同的值，直接插入到节点中</span></span><br><span class="line">                               <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                   pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value);</span><br><span class="line">                                   <span class="keyword">break</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">//节点为树</span></span><br><span class="line">                       <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                           Node&lt;K,V&gt; p;</span><br><span class="line">                           binCount = <span class="number">2</span>;</span><br><span class="line">                           <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                          value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                               oldVal = p.val;</span><br><span class="line">                               <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                <span class="comment">//替换旧值</span></span><br><span class="line">                                   p.val = value;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ReservationNode)</span><br><span class="line">                           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Recursive update&quot;</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果节点长度大于8,转化为树</span></span><br><span class="line">                   <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                       treeifyBin(tab, i);</span><br><span class="line">                   <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                       <span class="keyword">return</span> oldVal; </span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ConcurrentHashMap的扩容机制"><a href="#ConcurrentHashMap的扩容机制" class="headerlink" title="ConcurrentHashMap的扩容机制"></a>ConcurrentHashMap的扩容机制</h3><p>当ConcurrentHashMap中元素的数量达到cap * loadFactor时，就需要进行扩容。扩容主要通过transfer()方法进行，当有线程进行put操作时，如果正在进行扩容，可以通过helpTransfer()方法加入扩容。也就是说，ConcurrentHashMap支持多线程扩容，多个线程处理不同的节点。</p>
<ul>
<li><p>开始扩容，首先计算步长，也就是每个线程分配到的扩容的节点数(默认是16)。这个值是根据当前容量和CPU的数量来计算(stride &#x3D; (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) &#x2F; NCPU : n)，最小是16。</p>
</li>
<li><p>接下来初始化临时的Hash表nextTable，如果nextTable为null，初始化nextTable长度为原来的2倍；</p>
</li>
<li><p>通过计算出的步长开始遍历Hash表，其中坐标是通过一个原子操作(compareAndSetInt)记录。通过一个while循环，如果在一个线程的步长内便跳过此节点。否则转下一步；</p>
</li>
<li><p>如果当前节点为空，之间将此节点在旧的Hash表中设置为一个ForwardingNodes节点，表示这个节点已经被处理过了。</p>
</li>
<li><p>如果当前节点元素的hash值为MOVED(f.hash &#x3D;&#x3D; -1)，表示这是一个ForwardingNodes节点，则直接跳过。否则，开始重新处理节点；</p>
</li>
<li><p>对当前节点进行加锁，在这一步的扩容操作中，重新计算元素位置的操作与HashMap中是一样的，即当前元素键值的hash与长度进行&amp;操作，如果结果为0则保持位置不变，为1位置就是i+n。其中进行处理的元素是最后一个符合条件的元素，所以扩容后可能是一种倒序，但在Hash表中这种顺序也没有太大的影响。</p>
</li>
<li><p>最后如果是链表结构直接获得高位与低位的新链表节点，如果是树结构，同样计算高位与低位的节点，但是需要根据节点的长度进行判断是否需要转化为树的结构。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Moves and/or copies the nodes in each bin to new table. See</span></span><br><span class="line"><span class="comment">     * above for explanation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tab.length, stride;</span><br><span class="line">        <span class="comment">//根据长度和CPU的数量计算步长，最小是16</span></span><br><span class="line">        <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">            stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">        <span class="keyword">if</span> (nextTab == <span class="literal">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="comment">//初始化新的Hash表，长度为原来的2倍</span></span><br><span class="line">                Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                nextTab = nt;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">                sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nextTable = nextTab;</span><br><span class="line">            transferIndex = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextn</span> <span class="operator">=</span> nextTab.length;</span><br><span class="line">        <span class="comment">//初始化ForwardingNodes节点</span></span><br><span class="line">        ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">advance</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">//是否跨过节点的标记</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">finishing</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="type">int</span> fh;</span><br><span class="line">            <span class="comment">//根据步长判断是否需要跨过节点</span></span><br><span class="line">            <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">                <span class="type">int</span> nextIndex, nextBound;</span><br><span class="line">                <span class="comment">//到达没有处理的节点下标</span></span><br><span class="line">                <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                    advance = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//所有节点都已经接收处理</span></span><br><span class="line">                    i = -<span class="number">1</span>;</span><br><span class="line">                    advance = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSetInt</span><br><span class="line">                         (<span class="built_in">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                          nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                       nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="comment">//更新下表transferIndex,在步长的范围内都忽略</span></span><br><span class="line">                    bound = nextBound;</span><br><span class="line">                    i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                    advance = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//所有节点都被接收处理或者已经处理完毕</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">                <span class="type">int</span> sc;</span><br><span class="line">                <span class="comment">//处理完毕</span></span><br><span class="line">                <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                    nextTable = <span class="literal">null</span>;</span><br><span class="line">                    table = nextTab;</span><br><span class="line">                    <span class="comment">//更新sizeCtl</span></span><br><span class="line">                    sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断所有节点是否全部被处理</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSetInt(<span class="built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    finishing = advance = <span class="literal">true</span>;</span><br><span class="line">                    i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果节点为null,直接标记为已接收处理</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="literal">null</span>)</span><br><span class="line">                advance = casTabAt(tab, i, <span class="literal">null</span>, fwd);</span><br><span class="line">            <span class="comment">//键值的hash为-1，表示这是一个ForwardingNodes节点，已经被处理</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                advance = <span class="literal">true</span>; <span class="comment">// already processed</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">	            <span class="comment">//对当前节点进行加锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">	                        <span class="comment">//索引位置是否改变的标志</span></span><br><span class="line">                            <span class="type">int</span> <span class="variable">runBit</span> <span class="operator">=</span> fh &amp; n;</span><br><span class="line">                            Node&lt;K,V&gt; lastRun = f; <span class="comment">//最后一个元素</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">                                <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> p.hash &amp; n;</span><br><span class="line">                                <span class="comment">//重新计算更新直到最后一个元素</span></span><br><span class="line">                                <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                    runBit = b;</span><br><span class="line">                                    lastRun = p;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//runBit = 0,保持位置不变</span></span><br><span class="line">                            <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                                ln = lastRun;</span><br><span class="line">                                hn = <span class="literal">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//runBit = 1,位置时i+n</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                hn = lastRun;</span><br><span class="line">                                ln = <span class="literal">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//重新遍历节点元素</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                                <span class="type">int</span> <span class="variable">ph</span> <span class="operator">=</span> p.hash; <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key; <span class="type">V</span> <span class="variable">pv</span> <span class="operator">=</span> p.val;</span><br><span class="line">                                <span class="comment">//构建低位(位置不变)新的链表</span></span><br><span class="line">                                <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                    ln = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                                    <span class="comment">//构建高位(i+n)新的链表</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hn = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//将新的链表设置到新的Hash表中相应的位置</span></span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            <span class="comment">//将原来的Hash表中相应位置的节点设置为ForwardingNodes节点</span></span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//如果节点是树的结构</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                            TreeNode&lt;K,V&gt; lo = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                            TreeNode&lt;K,V&gt; hi = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                                <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> e.hash;</span><br><span class="line">                                TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;</span><br><span class="line">                                    (h, e.key, e.val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                                <span class="comment">//同样的方式计算新的索引位置</span></span><br><span class="line">                                <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">	                                <span class="comment">//构建新的链表结构</span></span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                                        lo = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        loTail.next = p;</span><br><span class="line">                                    loTail = p;</span><br><span class="line">                                    ++lc;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">//构建新的链表结构</span></span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                                        hi = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        hiTail.next = p;</span><br><span class="line">                                    hiTail = p;</span><br><span class="line">                                    ++hc;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//判断是否需要转化为树</span></span><br><span class="line">                            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                                (hc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(lo) : t;</span><br><span class="line">                            <span class="comment">//判断是否需要转化为树</span></span><br><span class="line">                            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                                (lc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(hi) : t;</span><br><span class="line">                            <span class="comment">//将新的链表设置到新的Hash表中相应的位置</span></span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            <span class="comment">//将原来的Hash表中相应位置的节点设置为ForwardingNodes节点</span></span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ConcurrentHashMap的get方法"><a href="#ConcurrentHashMap的get方法" class="headerlink" title="ConcurrentHashMap的get方法"></a>ConcurrentHashMap的get方法</h3><p>ConcurrentHashMap的get方法就是从Hash表中读取数据，而且与扩容不冲突。该方法没有同步锁。</p>
<ul>
<li><p>通过键值的hash计算索引位置，如果满足条件，直接返回对应的值；</p>
</li>
<li><p>如果相应节点的hash值小于0 ，即该节点在进行扩容，直接在调用ForwardingNodes节点的find方法进行查找。</p>
</li>
<li><p>否则，遍历当前节点直到找到对应的元素。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> key.equals(k)&#125;,</span></span><br><span class="line"><span class="comment">     * then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise it returns</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified key is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">        <span class="comment">//满足条件直接返回对应的值</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//e.hash&lt;0，正在扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//遍历当前节点</span></span><br><span class="line">            <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>




<p>原文：<a href="https://blog.csdn.net/programerxiaoer/article/details/80040090">https://blog.csdn.net/programerxiaoer/article/details/80040090</a></p>
]]></content>
      <categories>
        <category>java</category>
        <category>container</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql视图</title>
    <url>/2021/05/13/database/mysql/mysql-view/</url>
    <content><![CDATA[<h1 id="视图概述"><a href="#视图概述" class="headerlink" title="视图概述"></a>视图概述</h1><p>视图是由数据库中的一个表或多个表导出的虚拟表，是一种虚拟存在的表，方便用户对数据的操作。</p>
<h2 id="视图的概念"><a href="#视图的概念" class="headerlink" title="视图的概念"></a>视图的概念</h2><p>视图是一个虚拟表，是从数据库中一个或多个表中导出来的表，其内容由查询定义。同真实表一样，视图包含一系列带有名称的列和行数据。但是，数据库中只存放了视图的定义，而并没有存放视图中的数据。这些数据存放在原来的表中。使用视图查询数据时，数据库系统会从原来的表中取出对应的数据。因此，视图中的数据是依赖于原来的表中的数据的。一旦表中的数据发生改变，显示在视图中的数据也会发生改变。</p>
<p>视图是存储在数据库中的查询的SQL语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，例如，员工信息表，可以用视图只显示姓名、工龄、地址，而不显示社会保险号和工资数等；另一个原因是可使复杂的查询易于理解和使用。</p>
<h2 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h2><p>对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其他数据库的一个或多个表，或者其他视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。视图的作用归纳为如下几点。</p>
<h3 id="简单性"><a href="#简单性" class="headerlink" title="简单性"></a>简单性</h3><p>看到的就是需要的。视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。</p>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>视图的安全性可以防止未授权用户查看特定的行或列，使有权限用户只能看到表中特定行的方法，如下：</p>
<ol>
<li>在表中增加一个标志用户名的列。</li>
<li>建立视图，使用户只能看到标有自己用户名的行。</li>
<li>把视图授权给其他用户。</li>
</ol>
<h3 id="逻辑数据独立性"><a href="#逻辑数据独立性" class="headerlink" title="逻辑数据独立性"></a>逻辑数据独立性</h3><p>视图可以使应用程序和数据库表在一定程度上独立。如果没有视图，程序一定是建立在表上的。有了视图之后，程序可以建立在视图之上，从而程序与数据库表被视图分割开来。视图可以在以下几个方面使程序与数据独立。</p>
<ol>
<li>如果应用建立在数据库表上，当数据库表发生变化时，可以在表上建立视图，通过视图屏蔽表的变化，从而使应用程序可以不动。</li>
<li>如果应用建立在数据库表上，当应用发生变化时，可以在表上建立视图，通过视图屏蔽应用的变化，从而使数据库表不动。</li>
<li>如果应用建立在视图上，当数据库表发生变化时，可以在表上修改视图，通过视图屏蔽表的变化，从而使应用程序可以不动。</li>
<li>如果应用建立在视图上，当应用发生变化时，可以在表上修改视图，通过视图屏蔽应用的变化，从而使数据库可以不动。</li>
</ol>
<h1 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h1><p>创建视图是指在已经存在的数据库表上建立视图。视图可以建立在一张表中，也可以建立在多张表中。</p>
<h2 id="查看创建视图的权限"><a href="#查看创建视图的权限" class="headerlink" title="查看创建视图的权限"></a>查看创建视图的权限</h2><p>创建视图需要具有CREATE VIEW的权限。同时应该具有查询涉及的列的SELECT权限。可以使用SELECT语句来查询这些权限信息。查询语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Select_priv,Create_view_priv <span class="keyword">FROM</span> mysql.user <span class="keyword">WHERE</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;用户名&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ol>
<li>Select_priv：属性表示用户是否具有SELECT权限，Y表示拥有SELECT权限，N表示没有。</li>
<li>Create_view_priv：属性表示用户是否具有CREATE VIEW权限。</li>
<li>mysql.user：表示MySQL数据库下面的user表。</li>
<li>用户名：参数表示要查询是否拥有权限的用户，该参数需要用单引号引起来。</li>
</ol>
<p><strong>示例：</strong>查询MySQL中root用户是否具有创建视图的权限。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mysql.user <span class="keyword">WHERE</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="创建视图-1"><a href="#创建视图-1" class="headerlink" title="创建视图"></a>创建视图</h2><p>MySQL中，创建视图是通过CREATE VIEW语句实现的。其语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] [ALGORITHM<span class="operator">=</span>&#123;UNDEFINED<span class="operator">|</span><span class="keyword">MERGE</span><span class="operator">|</span>TEMPTABLE&#125;]</span><br><span class="line"><span class="keyword">VIEW</span> 视图名[(属性清单)]</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span>语句</span><br><span class="line">[<span class="keyword">WITH</span> [<span class="keyword">CASCADED</span><span class="operator">|</span><span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> OPTION];</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ol>
<li>ALGORITHM：可选项，表示视图选择的算法。</li>
<li>视图名：表示要创建的视图名称。</li>
<li>属性清单：可选项，指定视图中各个属性的名词，默认情况下与SELECT语句中的查询的属性相同。</li>
<li>SELECT语句：表示一个完整的查询语句，将查询记录导入视图中。</li>
<li>WITH CHECK OPTION：可选项，表示更新视图时要保证在该视图的权限范围之内。</li>
</ol>
<p><strong>示例：</strong>创建视图。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> view_user</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">	<span class="keyword">SELECT</span> id,name <span class="keyword">FROM</span> tb_user;</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong>创建视图同时，指定属性清单。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> view_user (a_id,a_name)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">	<span class="keyword">SELECT</span> id,name <span class="keyword">FROM</span> tb_user;</span><br></pre></td></tr></table></figure>

<p>创建视图时需要注意以下几点：</p>
<ol>
<li>运行创建视图的语句需要用户具有创建视图（create view）的权限，若加了[or replace]时，还需要用户具有删除视图（drop view）的权限；</li>
<li>select语句不能包含from子句中的子查询；</li>
<li>select语句不能引用系统或用户变量；</li>
<li>select语句不能引用预处理语句参数；</li>
<li>在存储子程序内，定义不能引用子程序参数或局部变量；</li>
<li>在定义中引用的表或视图必须存在。但是，创建了视图后，能够舍弃定义引用的表或视图。要想检查视图定义是否存在这类问题，可使用check table语句；</li>
<li>在定义中不能引用temporary表，不能创建temporary视图；</li>
<li>在视图定义中命名的表必须已存在；</li>
<li>不能将触发程序与视图关联在一起；</li>
<li>在视图定义中允许使用order by，但是，如果从特定视图进行了选择，而该视图使用了具有自己order by的语句，它将被忽略。</li>
</ol>
<h1 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h1><p>修改视图是指修改数据库中已存在的表的定义。当基本表的某些字段发生改变时，可以通过修改视图来保持视图和基本表之间一致。MySQL中通过CREATE OR REPLACE VIEW语句和ALTER VIEW语句来修改视图。</p>
<p><strong>示例：</strong>修改视图</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> view_user</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">	<span class="keyword">SELECT</span> id,name <span class="keyword">FROM</span> tb_user <span class="keyword">where</span> id  <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> tb_user);</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong>ALTER VIEW语句改变了视图的定义，该语句与CREATE OR REPLACE VIEW语句有着同样的限制，如果删除并重新创建一个视图，就必须重新为它分配权限。</p>
<h1 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h1><p>删除视图是指删除数据库中已存在的视图。删除视图时，只能删除视图的定义，不会删除数据。MySQL中，使用DROP VIEW语句来删除视图。但是，用户必须拥有DROP权限。</p>
<p><strong>示例：</strong>删除视图。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> IF <span class="keyword">EXISTS</span> view_user;</span><br></pre></td></tr></table></figure>

<h1 id="MySQL视图中使用IF和CASE语句"><a href="#MySQL视图中使用IF和CASE语句" class="headerlink" title="MySQL视图中使用IF和CASE语句"></a>MySQL视图中使用IF和CASE语句</h1><p>在创建视图时，经常需要使用到MySQL的流程控制语句，如：IF语句和CASE语句。</p>
<p><strong>示例：</strong>创建MySQL视图中使用IF和CASE语句。</p>
<ol>
<li><p>创建员工信息表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 判断数据表是否存在，存在则删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> tb_staff;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 创建数据表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> tb_staff</span><br><span class="line">( </span><br><span class="line">	id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">	NAME <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">	sex <span class="type">INT</span> COMMENT <span class="string">&#x27;性别（1：男；2：女；）&#x27;</span>,</span><br><span class="line">	dept_code <span class="type">VARCHAR</span>(<span class="number">10</span>) COMMENT <span class="string">&#x27;部门编号&#x27;</span>,</span><br><span class="line">	is_post BIT COMMENT <span class="string">&#x27;是否在职（0：否；1：是）&#x27;</span></span><br><span class="line">) COMMENT <span class="operator">=</span> <span class="string">&#x27;员工信息表&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建员工视图，在视图中使用IF和CASE语句。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建视图</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> view_staff</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">	<span class="keyword">SELECT</span> id </span><br><span class="line">	,NAME</span><br><span class="line">	,IF(sex<span class="operator">=</span><span class="number">1</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;女&#x27;</span>) <span class="keyword">AS</span> sex_name</span><br><span class="line">	,<span class="keyword">CASE</span> dept_code</span><br><span class="line">		<span class="keyword">WHEN</span> <span class="string">&#x27;1001&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;研发部&#x27;</span></span><br><span class="line">		<span class="keyword">WHEN</span> <span class="string">&#x27;1002&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;人事部&#x27;</span></span><br><span class="line">		<span class="keyword">WHEN</span> <span class="string">&#x27;1003&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;财务部&#x27;</span></span><br><span class="line">		<span class="keyword">ELSE</span> <span class="string">&#x27;其他&#x27;</span></span><br><span class="line">	<span class="keyword">END</span> <span class="keyword">AS</span> dept_name</span><br><span class="line">	,IF(is_post,<span class="string">&#x27;在职&#x27;</span>,<span class="string">&#x27;离职&#x27;</span>) <span class="keyword">AS</span> is_post_name</span><br><span class="line">	<span class="keyword">FROM</span> tb_staff</span><br><span class="line">;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>原文链接：<a href="https://blog.csdn.net/pan_junbiao/article/details/86132535">https://blog.csdn.net/pan_junbiao/article/details/86132535</a></p>
]]></content>
      <categories>
        <category>database</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql 索引</title>
    <url>/2021/05/13/database/mysql/mysql-index/</url>
    <content><![CDATA[<p>作者：EnjoyMoving<br>链接：<a href="https://zhuanlan.zhihu.com/p/29118331">网页链接</a><br>来源：知乎</p>
<p>著作权归作者所有</p>
<p><img src="/images/mysql-index/mysql-index-1.jpg" alt="image"></p>
<h1 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>索引大大减小了服务器需要扫描的数据量</li>
<li>索引可以帮助服务器避免排序和临时表</li>
<li>索引可以将随机IO变成顺序IO</li>
<li>索引对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询锁更少的元组。在MySQL5.1和更新的版本中，InnoDB可以在服务器端过滤掉行后就释放锁，但在早期的MySQL版本中，InnoDB直到事务提交时才会解锁。对不需要的元组的加锁，会增加锁的开销，降低并发性。 InnoDB仅对需要访问的元组加锁，而索引能够减少InnoDB访问的元组数。但是只有在存储引擎层过滤掉那些不需要的数据才能达到这种目的。一旦索引不允许InnoDB那样做（即索引达不到过滤的目的），MySQL服务器只能对InnoDB返回的数据进行WHERE操作，此时，已经无法避免对那些元组加锁了。如果查询不能使用索引，MySQL会进行全表扫描，并锁住每一个元组，不管是否真正需要。</li>
<li>关于InnoDB、索引和锁：InnoDB在二级索引上使用共享锁（读锁），但访问主键索引需要排他锁（写锁）<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2></li>
<li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存索引文件。</li>
<li>建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。</li>
<li>如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。</li>
<li>对于非常小的表，大部分情况下简单的全表扫描更高效；<br>索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。<br>因此应该只为最经常查询和最经常排序的数据列建立索引。<br>MySQL里同一个数据表里的索引总数限制为16个。</li>
</ul>
<h1 id="索引存储类型"><a href="#索引存储类型" class="headerlink" title="索引存储类型"></a>索引存储类型</h1><h2 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h2><p>InnoDB使用的是B+Tree。<br>B+Tree：每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。<br>B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同，很适合查找范围数据。<br>B-Tree可以对&lt;，&lt;&#x3D;，&#x3D;，&gt;，&gt;&#x3D;，BETWEEN，IN，以及不以通配符开始的LIKE使用索引。</p>
<h3 id="索引查询"><a href="#索引查询" class="headerlink" title="索引查询"></a>索引查询</h3><p>可以利用B-Tree索引进行全关键字、关键字范围和关键字前缀查询，但必须保证按索引的最左边前缀(leftmost prefix of the index)来进行查询<br><img src="/images/mysql-index/mysql-index-2.jpg" alt="image"><br>假设有如下一个表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> People (</span><br><span class="line">  last_name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  first_name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  dob <span class="type">date</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  gender enum(<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;f&#x27;</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  key(last_name, first_name, dob)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>其组合索引包含表中每一行的last_name、first_name和dob列。其结构大致如下：<br><img src="/images/mysql-index/mysql-index-3.jpg" alt="image"><br>按索引的最左边前缀(leftmost prefix of the index)来进行查询：</p>
<ol>
<li><p>查询必须从索引的最左边的列开始，否则无法使用索引。例如，你不能直接利用索引查找在某一天出生的人。</p>
</li>
<li><p>不能跳过某一索引列。例如，你不能利用索引查找last name为Smith且出生于某一天的人。</p>
</li>
<li><p>存储引擎不能使用索引中范围条件右边的列。例如，如果你的查询语句为WHERE last_name&#x3D;”Smith” AND first_name LIKE ‘J%’ AND dob&#x3D;’1976-12-23’，则该查询只会使用索引中的前两列，因为LIKE是范围查询。</p>
</li>
<li><p>匹配全值(Match the full value)：对索引中的所有列都指定具体的值。例如，上图中索引可以帮助你查找出生于1960-01-01的Cuba Allen。</p>
</li>
<li><p>匹配最左前缀(Match a leftmost prefix)：你可以利用索引查找last name为Allen的人，仅仅使用索引中的第1列。</p>
</li>
<li><p>匹配列前缀(Match a column prefix)：例如，你可以利用索引查找last name以J开始的人，这仅仅使用索引中的第1列。</p>
</li>
<li><p>匹配值的范围查询(Match a range of values)：可以利用索引查找last name在Allen和Barrymore之间的人，仅仅使用索引中第1列。</p>
</li>
<li><p>匹配部分精确而其它部分进行范围匹配(Match one part exactly and match a range on another part)：可以利用索引查找last name为Allen，而first name以字母K开始的人。</p>
</li>
<li><p>仅对索引进行查询(Index-only queries)：如果查询的列都位于索引中，则不需要再多一次I&#x2F;O回读元组。(覆盖索引：索引的叶子节点中已经包含要查询的数据，那么就没有必要再回表查询了，如果索引包含满足查询的所有数据，就称为覆盖索引。)</p>
</li>
</ol>
<h3 id="索引排序"><a href="#索引排序" class="headerlink" title="索引排序"></a>索引排序</h3><p>也可以利用B-Tree索引进行索引排序（对查询结果进行ORDER BY），必须保证ORDER BY按索引的最左边前缀(leftmost prefix of the index)来进行。</p>
<p>MySQL中，有两种方式生成有序结果集：</p>
<ul>
<li>使用filesort</li>
<li>按索引顺序扫描</li>
</ul>
<p>如果explain出来的type列的值为“index”，则说明MYSQL使用了索引扫描来做排序。</p>
<h4 id="按索引顺序扫描："><a href="#按索引顺序扫描：" class="headerlink" title="按索引顺序扫描："></a>按索引顺序扫描：</h4><p>可以利用同一索引同时进行查找和排序操作：</p>
<ul>
<li>当索引的顺序与ORDER BY中的列顺序相同，且所有的列是同一方向（全部升序或者全部降序）时，可以使用索引来排序。</li>
<li>ORDER BY子句和查询型子句的限制是一样的：需要满足索引的最左前缀的要求，有一种情况下ORDER BY子句可以不满足索引的最左前缀要求，那就是前导列为常量时：WHERE子句或者JOIN子句中对前导列指定了常量。</li>
</ul>
<p><img src="/images/mysql-index/mysql-index-4.png" alt="image"></p>
<ul>
<li>如果查询是连接多个表，仅当ORDER BY中的所有列都是第一个表的列时才会使用索引。其它情况都会使用filesort文件排序。</li>
</ul>
<h4 id="使用filesort："><a href="#使用filesort：" class="headerlink" title="使用filesort："></a>使用filesort：</h4><p>当MySQL不能使用索引进行排序时，就会利用自己的排序算法(快速排序算法)在内存(sort buffer)中对数据进行排序；</p>
<p>如果内存装载不下，它会将磁盘上的数据进行分块，再对各个数据块进行排序，然后将各个块合并成有序的结果集（实际上就是外排序，使用临时表）。</p>
<p>对于filesort，MySQL有两种排序算法：</p>
<ul>
<li><h5 id="两次扫描算法-Two-passes"><a href="#两次扫描算法-Two-passes" class="headerlink" title="两次扫描算法(Two passes)"></a>两次扫描算法(Two passes)</h5><p> 先将需要排序的字段和可以直接定位到相关行数据的指针信息取出，然后在设定的内存（通过参数sort_buffer_size设定）中进行排序，完成排序之后再次通过行指针信息取出所需的Columns。<br> 该算法是MySQL4.1之前采用的算法，它需要两次访问数据，尤其是第二次读取操作会导致大量的随机I&#x2F;O操作。另一方面，内存开销较小。</p>
</li>
<li><h5 id="一次扫描算法-single-pass"><a href="#一次扫描算法-single-pass" class="headerlink" title="一次扫描算法(single pass)"></a>一次扫描算法(single pass)</h5><p> 该算法一次性将所需的Columns全部取出，在内存中排序后直接将结果输出。<br> 从MySQL4.1版本开始使用该算法。它减少了I&#x2F;O的次数，效率较高，但是内存开销也较大。如果我们将并不需要的Columns也取出来，就会极大地浪费排序过程所需要的内存。<br> 在 MySQL 4.1 之后的版本中，可以通过设置 max_length_for_sort_data 参数来控制 MySQL 选择第一种排序算法还是第二种：当取出的所有大字段总大小大于 max_length_for_sort_data 的设置时，MySQL 就会选择使用第一种排序算法，反之，则会选择第二种。<br> 当对连接操作进行排序时，如果ORDER BY仅仅引用第一个表的列，MySQL对该表进行filesort操作，然后进行连接处理，此时，EXPLAIN输出“Using filesort”；否则，MySQL必须将查询的结果集生成一个临时表，在连接完成之后进行filesort操作，此时，EXPLAIN输出“Using temporary;Using filesort”。<br> 为了尽可能地提高排序性能，我们自然更希望使用第二种排序算法，所以在 Query 中仅仅取出需要的 Columns 是非常有必要的。</p>
</li>
</ul>
<h2 id="聚簇索引-cluster-index"><a href="#聚簇索引-cluster-index" class="headerlink" title="聚簇索引(cluster index)"></a>聚簇索引(cluster index)</h2><p>一个表只能有一个聚簇索引。</p>
<p>目前，只有solidDB和InnoDB支持聚簇索引，MyISAM不支持聚簇索引。一些DBMS允许用户指定聚簇索引，但是MySQL的存储引擎到目前为止都不支持。</p>
<h3 id="InnoDB的聚簇索引："><a href="#InnoDB的聚簇索引：" class="headerlink" title="InnoDB的聚簇索引："></a>InnoDB的聚簇索引：</h3><ol>
<li>InnoDB对主键建立聚簇索引。</li>
<li>如果你不指定主键，InnoDB会用一个具有唯一且非空值的索引来代替。</li>
<li>如果不存在这样的索引，InnoDB会定义一个隐藏的主键，然后对其建立聚簇索引。</li>
</ol>
<p>InnoDB默认使用聚簇索引来组织数据，如果你用InnoDB，而且不需要特殊的聚簇索引，一个好的做法就是使用代理主键(surrogate key)——独立于你的应用中的数据。最简单的做法就是使用一个AUTO_INCREMENT的列，这会保证记录按照顺序插入，而且能提高使用primary key进行连接的查询的性能。应该尽量避免随机的聚簇主键，例如字符串主键就是一个不好的选择，它使得插入操作变得随机。</p>
<p>一般来说，DBMS都会以聚簇索引的形式来存储实际的数据，它是其它二级索引的基础：</p>
<ul>
<li>聚簇索引（primary索引）：主键索引</li>
<li>非聚簇索引（second索引）：二级索引</li>
</ul>
<h3 id="聚簇索引结构："><a href="#聚簇索引结构：" class="headerlink" title="聚簇索引结构："></a>聚簇索引结构：</h3><p>聚簇索引的结构大致如下：</p>
<p>聚簇索引：节点页只包含了索引列，叶子页包含了行的全部数据。聚簇索引“就是表”，因此可以不需要独立的行存储。<br>聚簇索引保证关键字的值相近的元组存储的物理位置也相近（所以字符串类型不宜建立聚簇索引，特别是随机字符串，会使得系统进行大量的移动操作）。</p>
<p><img src="/images/mysql-index/mysql-index-5.jpg" alt="image"></p>
<p>二级索引：叶子节点保存的不是指行的物理位置的指针，而是行的主键值。<br>这意味着通过二级索引查找行，存储引擎需要：</p>
<ol>
<li>找到二级索引的叶子节点获取对应的主键值，</li>
<li>根据这个主键值去聚簇索引中查找到对应的行。这里需要两次B-Tree查找而不是一次。</li>
</ol>
<p>覆盖索引对于InnoDB表尤其有用，因为InnoDB使用聚簇索引组织数据，如果二级索引中包含查询所需的数据，就不再需要在聚集索引中查找了。</p>
<p><strong>聚簇索引（InnoDB）和二级索引（MyISAM）数据布局比较：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> layout_test (</span><br><span class="line">  col1 <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  col2 <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(col1),</span><br><span class="line">  KEY(col2)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>MyISAM</strong></li>
</ul>
<p>MyISAM按照插入的顺序在磁盘上存储数据：</p>
<p>左边为行号(row number)，从0开始。因为元组的大小固定，所以MyISAM可以很容易的从表的开始位置找到某一字节的位置。</p>
<p><img src="/images/mysql-index/mysql-index-6.png" alt="image"></p>
<p>MyISAM建立的索引结构大致如下：</p>
<p>col1主键索引：</p>
<p>MyISAM不支持聚簇索引，索引中每一个叶子节点仅仅包含行号(row number)，且叶子节点按照col1的顺序存储。</p>
<p><img src="/images/mysql-index/mysql-index-7.jpg" alt="image"></p>
<p>col2非主键索引：</p>
<p>在MyISAM中，primary key和其它索引没有什么区别。Primary key仅仅只是一个叫做PRIMARY的唯一，非空的索引而已，叶子节点按照col2的顺序存储。</p>
<p><img src="/images/mysql-index/mysql-index-8.jpg" alt="image"></p>
<ul>
<li><strong>InnoDB</strong></li>
</ul>
<p>col1主键索引，即聚簇索引：</p>
<p>聚簇索引中的每个叶子节点包含主键的值，事务ID，用于事务和MVCC的回滚指针，和余下的列(如col2)。</p>
<p><img src="/images/mysql-index/mysql-index-9.jpg" alt="image"></p>
<p>col2非主键索引，即二级索引：</p>
<p>InnoDB的二级索引的叶子包含主键的值，而不是行指针(row pointers)，这样的策略减小了移动数据或者数据页面分裂时维护二级索引的开销，因为InnoDB不需要更新索引的行指针。</p>
<p><img src="/images/mysql-index/mysql-index-10.jpg" alt="image"></p>
<ul>
<li><strong>聚簇索引+二级索引表 与 非聚簇索引表 的对比</strong></li>
</ul>
<p><img src="/images/mysql-index/mysql-index-11.jpg" alt="image"></p>
<h2 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h2><p>哈希索引基于哈希表实现，只有精确索引所有列的查询才有效。</p>
<p>对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据的指针。</p>
<p>MySQL中，只有Memory存储引擎显示支持hash索引，是Memory表的默认索引类型，尽管Memory表也可以使用B-Tree索引。</p>
<p>Memory存储引擎支持非唯一hash索引，这在数据库领域是罕见的：如果多个值有相同的hash code，索引把它们的行指针用链表保存到同一个hash表项中。</p>
<p>假设创建如下一个表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> testhash (</span><br><span class="line">  fname <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  lname <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  KEY <span class="keyword">USING</span> HASH(fname)</span><br><span class="line">) ENGINE<span class="operator">=</span>MEMORY;</span><br></pre></td></tr></table></figure>

<p>包含的数据如下：</p>
<p><img src="/images/mysql-index/mysql-index-12.jpg" alt="image"></p>
<p>假设索引使用hash函数f( )，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(&#x27;Arjen&#x27;) = 2323</span><br><span class="line">f(&#x27;Baron&#x27;) = 7437</span><br><span class="line">f(&#x27;Peter&#x27;) = 8784</span><br><span class="line">f(&#x27;Vadim&#x27;) = 2458</span><br></pre></td></tr></table></figure>

<p>此时，索引的结构大概如下：</p>
<p><img src="/images/mysql-index/mysql-index-13.png" alt="image"></p>
<p>哈希索引中存储的是：哈希值+数据行指针</p>
<p>当你执行 SELECT lname FROM testhash WHERE fname&#x3D;’Peter’; MySQL会计算’Peter’的hash值，然后通过它来查询索引的行指针。因为f(‘Peter’) &#x3D; 8784，MySQL会在索引中查找8784，得到指向记录3的指针。</p>
<h3 id="Hash索引有以下一些限制："><a href="#Hash索引有以下一些限制：" class="headerlink" title="Hash索引有以下一些限制："></a>Hash索引有以下一些限制：</h3><ul>
<li>由于索引仅包含hash code和记录指针，所以，MySQL不能通过使用索引避免读取记录，即每次使用哈希索引查询到记录指针后都要回读元祖查取数据。</li>
<li>不能使用hash索引排序。</li>
<li>Hash索引不支持键的部分匹配，因为是通过整个索引值来计算hash值的。</li>
<li>Hash索引只支持等值比较，例如使用&#x3D;，IN( )和&lt;&#x3D;&gt;。对于WHERE price&gt;100并不能加速查询。</li>
<li>访问Hash索引的速度非常快，除非有很多哈希冲突（不同的索引列值却有相同的哈希值）。当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行。</li>
<li>如果哈希冲突很多的话，一些索引维护操作的代价也会很高。当从表中删除一行时，存储引擎要遍历对应哈希值的链表中的每一行，找到并删除对应行的引用，冲突越多，代价越大。</li>
</ul>
<p>InnoDB引擎有一个特殊的功能叫做“自适应哈希索引”，由Mysql自动管理，不需要DBA人为干预。默认情况下为开启，我们可以通过参数innodb_adaptive_hash_index来禁用此特性。</p>
<p>当InnoDB注意到某些索引值被使用得非常频繁时，它会在内存中基于缓冲池中的B+ Tree索引上再创建一个哈希索引，这样就上B-Tree索引也具有哈希索引的一些优点，比如快速的哈希查找。</p>
<ul>
<li>只能用于等值比较，例如&#x3D;， &lt;&#x3D;&gt;，in ；</li>
<li>无法用于排序</li>
</ul>
<p>InnoDB官方文档显示，启用自适应哈希索引后，读和写性能可以提高2倍，对于辅助索引的连接操作，性能可以提高5倍</p>
<h2 id="空间-R-Tree-索引"><a href="#空间-R-Tree-索引" class="headerlink" title="空间(R-Tree)索引"></a>空间(R-Tree)索引</h2><p>MyISAM支持空间索引，主要用于地理空间数据类型，例如GEOMETRY。</p>
<h2 id="全文-Full-text-索引"><a href="#全文-Full-text-索引" class="headerlink" title="全文(Full-text)索引"></a>全文(Full-text)索引</h2><p>全文索引是MyISAM的一个特殊索引类型，它查找的是文本中的关键词，主要用于全文检索。</p>
<p>MySQL InnoDB从5.6开始已经支持全文索引，但InnoDB内部并不支持中文、日文等，因为这些语言没有分隔符。可以使用插件辅助实现中文、日文等的全文索引。详见：<a href="https://dev.mysql.com/doc/refman/5.7/en/fulltext-restrictions.html">12.9.5 Full-Text Restrictions</a></p>
<h1 id="MySQL建立索引类型"><a href="#MySQL建立索引类型" class="headerlink" title="MySQL建立索引类型"></a>MySQL建立索引类型</h1><ul>
<li>单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。</li>
<li>组合索引，即一个索包含多个列。</li>
</ul>
<p>索引是在存储引擎中实现的，而不是在服务器层中实现的。所以，每种存储引擎的索引都不一定完全相同，并不是所有的存储引擎都支持所有的索引类型。</p>
<h2 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h2><p>这是最基本的索引，它没有任何限制。普通索引（由关键字KEY或INDEX定义的索引）的唯一任务是加快对数据的访问速度。因此，应该只为那些最经常出现在查询条件(WHERE column &#x3D; …)或排序条件(ORDER BY column)中的数据列创建索引。</p>
<p>它有以下几种创建方式：</p>
<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>CREATE INDEX indexName ON mytable(username(length));</p>
<p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length，下同。</p>
<h3 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h3><p>ALTER mytable ADD INDEX [indexName] ON (username(length))</p>
<h3 id="创建表的时候直接指定"><a href="#创建表的时候直接指定" class="headerlink" title="创建表的时候直接指定"></a>创建表的时候直接指定</h3><p>CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, INDEX [indexName] (username(length)) );</p>
<h3 id="删除索引的语法："><a href="#删除索引的语法：" class="headerlink" title="删除索引的语法："></a>删除索引的语法：</h3><p>DROP INDEX [indexName] ON mytable;</p>
<h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><p>它与前面的普通索引类似，不同的就是：普通索引允许被索引的数据列包含重复的值。而唯一索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</p>
<p>它有以下几种创建方式：</p>
<h3 id="创建索引-1"><a href="#创建索引-1" class="headerlink" title="创建索引"></a>创建索引</h3><p>CREATE UNIQUE INDEX indexName ON mytable(username(length))</p>
<h3 id="修改表结构-1"><a href="#修改表结构-1" class="headerlink" title="修改表结构"></a>修改表结构</h3><p>ALTER mytable ADD UNIQUE [indexName] ON (username(length))</p>
<h3 id="创建表的时候直接指定-1"><a href="#创建表的时候直接指定-1" class="headerlink" title="创建表的时候直接指定"></a>创建表的时候直接指定</h3><p>CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, UNIQUE [indexName] (username(length)) );</p>
<h2 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h2><p>它是一种特殊的唯一索引，不允许有空值。一个表只能有一个主键。</p>
<p>一般是在建表的时候同时创建主键索引：</p>
<p>CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, PRIMARY KEY(ID) ); 当然也可以用 ALTER 命令。</p>
<p>与之类似的，外键索引</p>
<p>如果为某个外键字段定义了一个外键约束条件，MySQL就会定义一个内部索引来帮助自己以最有效率的方式去管理和使用外键约束条件。</p>
<h2 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h2><p>为了形象地对比单列索引和组合索引，为表添加多个字段：</p>
<p>CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, city VARCHAR(50) NOT NULL, age INT NOT NULL );</p>
<p>为了进一步榨取MySQL的效率，就要考虑建立组合索引。就是将 name, city, age建到一个索引里：</p>
<p>ALTER TABLE mytable ADD INDEX name_city_age (name(10),city,age);</p>
<p>建表时，usernname长度为 16，这里用 10。这是因为一般情况下名字的长度不会超过10，这样会加速索引查询速度，还会减少索引文件的大小，提高INSERT的更新速度。</p>
<p>建立这样的组合索引，其实是相当于分别建立了下面三组组合索引：</p>
<p>usernname,city,age</p>
<p>usernname,city</p>
<p>usernname</p>
<p>为什么没有 city，age这样的组合索引呢？这是因为MySQL组合索引“最左前缀”的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这三列的查询都会用到该组合索引。下面的几个SQL就会用到这个组合索引：</p>
<p>SELECT * FROM mytable WHREE username&#x3D;”admin” AND city&#x3D;”郑州”</p>
<p>SELECT * FROM mytable WHREE username&#x3D;”admin”</p>
<p>而下面几个则不会用到：</p>
<p>SELECT * FROM mytable WHREE age&#x3D;20 AND city&#x3D;”郑州”</p>
<p>SELECT * FROM mytable WHREE city&#x3D;”郑州”</p>
<p>如果分别在 usernname，city，age上建立单列索引，让该表有3个单列索引，查询时和上述的组合索引效率也会大不一样，远远低于我们的组合索引。因为虽然此时有了三个索引，但MySQL只能用到其中的那个它认为似乎是最有效率的单列索引。</p>
<h1 id="建立索引的时机"><a href="#建立索引的时机" class="headerlink" title="建立索引的时机"></a>建立索引的时机</h1><p>一般来说，在WHERE和JOIN中出现的列需要建立索引，但也不完全如此，因为MySQL的B-Tree只对&lt;，&lt;&#x3D;，&#x3D;，&gt;，&gt;&#x3D;，BETWEEN，IN，以及不以通配符开始的LIKE才会使用索引。</p>
<p>例如：</p>
<p>SELECT t.Name FROM mytable t LEFT JOIN mytable m ON t.Name&#x3D;m.username WHERE m.age&#x3D;20 AND m.city&#x3D;’郑州’</p>
<p>此时就需要对city和age建立索引，由于mytable表的userame也出现在了JOIN子句中，也有对它建立索引的必要。</p>
<h1 id="正确使用索引"><a href="#正确使用索引" class="headerlink" title="正确使用索引"></a>正确使用索引</h1><p>使用（B-Tree）索引时，有以下一些技巧和注意事项：</p>
<h2 id="索引设计："><a href="#索引设计：" class="headerlink" title="索引设计："></a>索引设计：</h2><ul>
<li><h3 id="索引字段尽量使用数字型（简单的数据类型）"><a href="#索引字段尽量使用数字型（简单的数据类型）" class="headerlink" title="索引字段尽量使用数字型（简单的数据类型）"></a>索引字段尽量使用数字型（简单的数据类型）</h3></li>
</ul>
<p>若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了</p>
<ul>
<li><h3 id="尽量不要让字段的默认值为NULL"><a href="#尽量不要让字段的默认值为NULL" class="headerlink" title="尽量不要让字段的默认值为NULL"></a>尽量不要让字段的默认值为NULL</h3></li>
</ul>
<p>在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。</p>
<p>索引不会包含有NULL值的列，只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。</p>
<p>所以我们在数据库设计时尽量不要让字段的默认值为NULL，应该指定列为NOT NULL，除非你想存储NULL。你应该用0、一个特殊的值或者一个空串代替空值。</p>
<ul>
<li><h3 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h3></li>
</ul>
<p>对串列进行索引，如果可能应该指定一个前缀长度。</p>
<p>对于BLOB、TEXT或者很长的VARCHAR类型的列，必须使用前缀索引，因为MYSQL不允许索引这些列的完整长度。</p>
<p>前缀索引是一种能使索引更小、更快的有效办法，但另一方面也有其缺点：MySQL无法使用前缀索引做order by和group by，也无法使用前缀索引做覆盖扫描。</p>
<p>一般情况下某个前缀的选择性也是足够高的，足以满足查询性能。</p>
<p>例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。</p>
<p>短索引不仅可以提高查询速度而且可以节省磁盘空间和I&#x2F;O操作。在绝大多数应用里，数据库中的字符串数据大都以各种各样的名字为主，把索引的长度设置为10~15个字符已经足以把搜索范围缩小到很少的几条数据记录了。</p>
<p>通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。</p>
<p>索引的选择性是指，不重复的索引值（基数）和数据表中的记录总数的比值。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MYSQL在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p>
<p>决窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长（以便节约空间）。前缀应该足够长，以使得前缀索引的选择性接近于索引整个列。换句话说，前缀的“基数”应该接近于完整列的“基数”。</p>
<p>为了决定前缀的合适长度，需要找到最常见的值的列表，然后和最常见的前缀列表进行比较。例如以下查询：</p>
<p>select count(*) as cnt,city from sakila.city_demo group by city order by cnt desc limit 10;</p>
<p>select count(*) as cnt,left(city,7) as perf from sakila.city_demo group by city order by cnt desc limit 10;</p>
<p>直到这个前缀的选择性接近完整列的选择性。</p>
<p>计算合适的前缀长度的另一个方法就是计算完整列的选择性，并使前缀的选择性接近于完整列的选择性，如下：</p>
<p>select count(distinct city)&#x2F;count(*) from sakila.city_demo;</p>
<p>select count(distinct left(city,7))&#x2F;count(*) from sakila.city_demo;</p>
<ul>
<li><h3 id="使用唯一索引"><a href="#使用唯一索引" class="headerlink" title="使用唯一索引"></a>使用唯一索引</h3></li>
</ul>
<p>考虑某列中值的分布。索引的列的基数越大，索引的效果越好。</p>
<p>例如，存放出生日期的列具有不同值，很容易区分各行。而用来记录性别的列，只含有“ M” 和“F”，则对此列进行索引没有多大用处，因为不管搜索哪个值，都会得出大约一半的行。</p>
<ul>
<li><h3 id="使用组合索引代替多个列索引"><a href="#使用组合索引代替多个列索引" class="headerlink" title="使用组合索引代替多个列索引"></a>使用组合索引代替多个列索引</h3></li>
</ul>
<p>一个多列索引（组合索引）与多个列索引MySQL在解析执行上是不一样的，如果在explain中看到有索引合并（即MySQL为多个列索引合并优化），应该好好检查一下查询的表和结构是不是已经最优。</p>
<ul>
<li><h3 id="注意重复-x2F-冗余的索引、不使用的索引"><a href="#注意重复-x2F-冗余的索引、不使用的索引" class="headerlink" title="注意重复&#x2F;冗余的索引、不使用的索引"></a>注意重复&#x2F;冗余的索引、不使用的索引</h3></li>
</ul>
<p>MySQL允许在相同的列上创建多个索引，无论是有意还是无意的。大多数情况下不需要使用冗余索引。</p>
<p>对于重复&#x2F;冗余、不使用的索引：可以直接删除这些索引。因为这些索引需要占用物理空间，并且也会影响更新表的性能。</p>
<h2 id="索引使用："><a href="#索引使用：" class="headerlink" title="索引使用："></a>索引使用：</h2><ul>
<li>如果对大的文本进行搜索，使用全文索引而不要用使用 like ‘%…%’</li>
<li>like语句不要以通配符开头</li>
</ul>
<p>对于LIKE：在以通配符%和_开头作查询时，MySQL不会使用索引。like操作一般在全文索引中会用到（InnoDB数据表不支持全文索引）。</p>
<p>例如下句会使用索引：</p>
<p>SELECT * FROM mytable WHERE username like’admin%’</p>
<p>而下句就不会使用：</p>
<p>SELECT * FROM mytable WHEREt Name like’%admin’</p>
<ul>
<li>不要在列上进行运算</li>
</ul>
<p>索引列不能是表达式的一部分，也不是是函数的参数。</p>
<p>例如以下两个查询无法使用索引：</p>
<ol>
<li>表达式： select actor_id from sakila.actor where actor_id+1&#x3D;5;</li>
<li>函数参数：select … where TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col)&lt;&#x3D;10;</li>
</ol>
<ul>
<li>尽量不要使用NOT IN、&lt;&gt;、!&#x3D; 操作</li>
</ul>
<p>应尽量避免在 where 子句中使用!&#x3D;或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p>
<p>对于not in，可以用not exists或者（外联结+判断为空）来代替；很多时候用 exists 代替 in 是一个好的选择： select num from a where num in(select num from b) 用下面的语句替换： select num from a where exists(select 1 from b where num&#x3D;a.num)</p>
<p>对于&lt;&gt;，用其它相同功能的操作运算代替，如a&lt;&gt;0 改为 a&gt;0 or a&lt;0</p>
<ul>
<li>or条件</li>
</ul>
<p>用 or 分割开的条件， 如果 or 前的条件中的列有索引， 而后面的列中没有索引， 那么涉及到的索引都不会被用到。</p>
<p>应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： 假设num1有索引，num2没有索引，查询语句select id from t where num1&#x3D;10 or num2&#x3D;20会放弃使用索引，可以改为这样查询： select id from t where num1&#x3D;10 union all select id from t where num2&#x3D;20，这样虽然num2没有使用索引，但至少num1会使用索引，提高效率。</p>
<ul>
<li>组合索引的使用要遵守“最左前缀”原则’</li>
</ul>
<p>组合索引：当不需要考虑排序和分组时，将选择性最高的列放在前面通常是最好的。</p>
<p>例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> People (</span><br><span class="line">  last_name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  first_name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  birthday <span class="type">date</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  gender enum(<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;f&#x27;</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  key(last_name, first_name, birthday)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ol>
<li>查询必须从索引的最左边的列开始，否则无法使用索引。例如，你不能直接利用索引查找在某一天出生的人。</li>
<li>不能跳过某一索引列。例如，你不能利用索引查找last name为Smith且出生于某一天的人。</li>
<li>存储引擎不能使用索引中范围条件右边的列。例如，如果你的查询语句为WHERE last_name&#x3D;”Smith” AND first_name LIKE ‘J%’ AND dob&#x3D;’1976-12-23’，则该查询只会使用索引中的前两列，因为LIKE是范围查询。</li>
</ol>
<ul>
<li>使用索引排序时，ORDER BY也要遵守“最左前缀”原则</li>
</ul>
<ol>
<li>当索引的顺序与ORDER BY中的列顺序相同，且所有的列是同一方向（全部升序或者全部降序）时，可以使用索引来排序。</li>
<li>ORDER BY子句和查询型子句的限制是一样的：需要满足索引的最左前缀的要求，有一种情况下ORDER BY子句可以不满足索引的最左前缀要求，那就是前导列为常量时：WHERE子句或者JOIN子句中对前导列指定了常量。</li>
<li>如果查询是连接多个表，仅当ORDER BY中的所有列都是第一个表的列时才会使用索引。其它情况都会使用filesort文件排序。</li>
</ol>
<p><img src="/images/mysql-index/mysql-index-14.png" alt="image"></p>
<ul>
<li>如果列类型是字符串，那么一定记得在 where 条件中把字符常量值用引号引起来，否则的话即便这个列上有索引，MySQL 也不会用到的，因为MySQL 默认把输入的常量值进行转换以后才进行检索。 例如：</li>
</ul>
<p><img src="/images/mysql-index/mysql-index-15.jpg" alt="image"></p>
<p><img src="/images/mysql-index/mysql-index-16.jpg" alt="image"></p>
<ul>
<li>任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段</li>
<li>如果 MySQL 估计使用索引比全表扫描更慢，则不使用索引。当索引列有大量数据重复时,查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</li>
</ul>
<h1 id="索引性能测试与索引优化"><a href="#索引性能测试与索引优化" class="headerlink" title="索引性能测试与索引优化"></a>索引性能测试与索引优化</h1><p>只有当数据库里已经有了足够多的测试数据时，它的性能测试结果才有实际参考价值。如果在测试数据库里只有几百条数据记录，它们往往在执行完第一条查询命令之后就被全部加载到内存里，这将使后续的查询命令都执行得非常快——不管有没有使用索引。只有当数据库里的记录超过了1000条、数据总量也超过了 MySQL服务器上的内存总量时，数据库的性能测试结果才有意义。</p>
<p>在不确定应该在哪些数据列上创建索引的时候，人们从EXPLAIN SELECT命令那里往往可以获得一些帮助。这其实只是简单地给一条普通的SELECT命令加一个EXPLAIN关键字作为前缀而已。有了这个关键字，MySQL将不是去执行那条SELECT命令，而是去对它进行分析。MySQL将以表格的形式把查询的执行过程和用到的索引(如果有的话)等信息列出来。</p>
<h2 id="查看索引使用情况："><a href="#查看索引使用情况：" class="headerlink" title="查看索引使用情况："></a>查看索引使用情况：</h2><ul>
<li>如果索引正在工作，Handler_read_key 的值将很高，这个值代表了一个行被索引值读的次数，很低的值表明增加索引得到的性能改善不高，因为索引并不经常使用。</li>
<li>Handler_read_rnd_next 的值高则意味着查询运行低效，并且应该建立索引补救。这个值的含义是在数据文件中读下一行的请求数。如果正进行大量的表扫描， Handler_read_rnd_next 的值较高，则通常说明表索引不正确或写入的查询没有利用索引。</li>
</ul>
<p>具体如下：</p>
<p><img src="/images/mysql-index/mysql-index-17.png" alt="image"></p>
<p>从上面的例子中可以看出，目前使用的 MySQL 数据库的索引情况并不理想。</p>
]]></content>
      <categories>
        <category>database</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql 事务 MVCC</title>
    <url>/2021/05/13/database/mysql/mysql-transaction/</url>
    <content><![CDATA[<h1 id="mysql事务"><a href="#mysql事务" class="headerlink" title="mysql事务"></a>mysql事务</h1><ul>
<li>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务</li>
<li>事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</li>
<li>一般来说，事务需要满足4个条件（ACID）：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）</li>
<li>mysql默认自动提交事务</li>
</ul>
<p><strong>原子性</strong></p>
<p>一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p>
<p><strong>一致性</strong></p>
<p>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p>
<p><strong>隔离性</strong></p>
<p>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p>
<p><strong>持久性</strong></p>
<p>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>
<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><h3 id="未提交读（READ-UNCOMMITTED）"><a href="#未提交读（READ-UNCOMMITTED）" class="headerlink" title="未提交读（READ UNCOMMITTED）"></a>未提交读（READ UNCOMMITTED）</h3><p>如果一个事务读到了另一个未提交事务修改过的数据，那么这种隔离级别就称之为未提交读（英文名：READ UNCOMMITTED），示意图如下：</p>
<p><img src="/images/mysql-transaction/mysql-transaction-1.png" alt="image"></p>
<p>如上图，Session A和Session B各开启了一个事务，Session B中的事务先将id为1的记录的列c更新为’关羽’，然后Session A中的事务再去查询这条id为1的记录，那么在未提交读的隔离级别下，查询结果就是’关羽’，也就是说某个事务读到了另一个未提交事务修改过的记录。但是如果Session B中的事务稍后进行了回滚，那么Session A中的事务相当于读到了一个不存在的数据，这种现象就称之为脏读，就像这个样子：</p>
<p><img src="/images/mysql-transaction/mysql-transaction-2.png" alt="image"></p>
<p>脏读违背了现实世界的业务含义，所以这种READ UNCOMMITTED算是十分不安全的一种隔离级别。</p>
<h3 id="已提交读（Read-committed）"><a href="#已提交读（Read-committed）" class="headerlink" title="已提交读（Read committed）"></a>已提交读（Read committed）</h3><p>如果一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值，那么这种隔离级别就称之为已提交读（英文名：READ COMMITTED），如图所示：</p>
<p><img src="/images/mysql-transaction/mysql-transaction-3.png" alt="image"></p>
<p>从图中可以看到，第4步时，由于Session B中的事务尚未提交，所以Session A中的事务查询得到的结果只是’刘备’，而第6步时，由于Session B中的事务已经提交，所以Session B中的事务查询得到的结果就是’关羽’了。</p>
<p>对于某个处在在已提交读隔离级别下的事务来说，只要其他事务修改了某个数据的值，并且之后提交了，那么该事务就会读到该数据的最新值，比方说：</p>
<p><img src="/images/mysql-transaction/mysql-transaction-4.png" alt="image"></p>
<p>我们在Session B中提交了几个隐式事务，这些事务都修改了id为1的记录的列c的值，每次事务提交之后，Session A中的事务都可以查看到最新的值。这种现象也被称之为不可重复读。</p>
<h3 id="可重复读（Repeatable-read）"><a href="#可重复读（Repeatable-read）" class="headerlink" title="可重复读（Repeatable read）"></a>可重复读（Repeatable read）</h3><p>在一些业务场景中，一个事务只能读到另一个已经提交的事务修改过的数据，但是第一次读过某条记录后，即使其他事务修改了该记录的值并且提交，该事务之后再读该条记录时，读到的仍是第一次读到的值，而不是每次都读到不同的数据。那么这种隔离级别就称之为可重复读（英文名：REPEATABLE READ），如图所示：</p>
<p><img src="/images/mysql-transaction/mysql-transaction-5.png" alt="image"></p>
<p>从图中可以看出来，Session A中的事务在第一次读取id为1的记录时，列c的值为’刘备’，之后虽然Session B中隐式提交了多个事务，每个事务都修改了这条记录，但是Session A中的事务读到的列c的值仍为’刘备’，与第一次读取的值是相同的。</p>
<h3 id="可串行化（Serializable-）"><a href="#可串行化（Serializable-）" class="headerlink" title="可串行化（Serializable ）"></a>可串行化（Serializable ）</h3><p>以上3种隔离级别都允许对同一条记录进行读-读、读-写、写-读的并发操作，如果我们不允许读-写、写-读的并发操作，可以使用SERIALIZABLE隔离级别，示意图如下：</p>
<p><img src="/images/mysql-transaction/mysql-transaction-6.png" alt="image"></p>
<p>如图所示，当Session B中的事务更新了id为1的记录后，之后Session A中的事务再去访问这条记录时就被卡住了，直到Session B中的事务提交之后，Session A中的事务才可以获取到查询结果。</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读(Dirty Read)</th>
<th align="center">不可重复读 (NonRepeatable Read)</th>
<th align="center">幻读 (Phantom Read)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">未提交读（Read uncommitted）</td>
<td align="center">可能</td>
<td align="center">可能</td>
<td align="center">可能</td>
</tr>
<tr>
<td align="center">已提交读（Read committed）</td>
<td align="center">不可能</td>
<td align="center">不可能</td>
<td align="center">不可能</td>
</tr>
<tr>
<td align="center">可重复读（Repeatable read）</td>
<td align="center">不可能</td>
<td align="center">不可能</td>
<td align="center">可能</td>
</tr>
<tr>
<td align="center">可串行化（Serializable ）</td>
<td align="center">不可能</td>
<td align="center">不可能</td>
<td align="center">不可能</td>
</tr>
</tbody></table>
<p>InnoDB默认是可重复读级别的</p>
<ul>
<li>脏读: 脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</li>
<li>不可重复读:是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。</li>
<li>幻读:第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样，幻读是数据行记录变多了或者少了。</li>
</ul>
<p>简单点总结下他们的区别：脏读是指读取了未修改完的记录，不可重复读指因为被其它事务修改了记录导致某事务两次读取记录不一致，而幻读是指因为其它事务对表做了增删导致某事务两次读取的表记录数不一致问题。</p>
<h1 id="链版本-MVCC"><a href="#链版本-MVCC" class="headerlink" title="链版本(MVCC)"></a>链版本(MVCC)</h1><p>对于使用InnoDB存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列（row_id并不是必要的，我们创建的表中有主键或者非NULL唯一键时都不会包含row_id列）：</p>
<ul>
<li>trx_id：每次对某条聚簇索引记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。</li>
<li>roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li>
</ul>
<p>比方说我们的表t现在只包含一条记录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t;</span><br><span class="line">+----+--------+</span><br><span class="line">| id | c      |</span><br><span class="line">+----+--------+</span><br><span class="line">|  1 | 刘备   |</span><br><span class="line">+----+--------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>假设插入该记录的事务id为80，那么此刻该条记录的示意图如下所示：</p>
<p><img src="/images/mysql-transaction/mysql-transaction-7.png" alt="image"></p>
<p>假设之后两个id分别为100、200的事务对这条记录进行UPDATE操作，操作流程如下：</p>
<p><img src="/images/mysql-transaction/mysql-transaction-8.png" alt="image"></p>
<blockquote>
<p>小贴士： 能不能在两个事务中交叉更新同一条记录呢？哈哈，这是不可以滴，第一个事务更新了某条记录后，就会给这条记录加锁，另一个事务再次更新时就需要等待第一个事务提交了，把锁释放之后才可以继续更新。本篇文章不是讨论锁的，有关锁的更多细节我们之后再说。</p>
</blockquote>
<p>每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个roll_pointer属性（INSERT操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些undo日志都连起来，串成一个链表，所以现在的情况就像下图一样：</p>
<p><img src="/images/mysql-transaction/mysql-transaction-9.png" alt="image"></p>
<p>对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务id，这个信息很重要，我们稍后就会用到。</p>
<h2 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h2><p>对于使用READ UNCOMMITTED隔离级别的事务来说，直接读取记录的最新版本就好了，对于使用SERIALIZABLE隔离级别的事务来说，使用加锁的方式来访问记录。对于使用READ COMMITTED和REPEATABLE READ隔离级别的事务来说，就需要用到我们上边所说的版本链了，核心问题就是：需要判断一下版本链中的哪个版本是当前事务可见的。所以设计InnoDB的大叔提出了一个ReadView的概念，这个ReadView中主要包含当前系统中还有哪些活跃的读写事务，把它们的事务id放到一个列表中，我们把这个列表命名为为m_ids。这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：</p>
<ul>
<li>如果被访问版本的trx_id属性值小于m_ids列表中最小的事务id，表明生成该版本的事务在生成ReadView前已经提交，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值大于m_ids列表中最大的事务id，表明生成该版本的事务在生成ReadView后才生成，所以该版本不可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值在m_ids列表中最大的事务id和最小事务id之间，那就需要判断一下trx_id属性值是不是在m_ids列表中，如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li>
</ul>
<p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本，如果最后一个版本也不可见的话，那么就意味着该条记录对该事务不可见，查询结果就不包含该记录。</p>
<p>在MySQL中，READ COMMITTED和REPEATABLE READ隔离级别的的一个非常大的区别就是它们生成ReadView的时机不同，我们来看一下。</p>
<h3 id="COMMITTED-—-每次读取数据前都生成一个ReadView"><a href="#COMMITTED-—-每次读取数据前都生成一个ReadView" class="headerlink" title="COMMITTED — 每次读取数据前都生成一个ReadView"></a>COMMITTED — 每次读取数据前都生成一个ReadView</h3><p>比方说现在系统里有两个id分别为100、200的事务在执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># Transaction <span class="number">100</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> c <span class="operator">=</span> <span class="string">&#x27;关羽&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> c <span class="operator">=</span> <span class="string">&#x27;张飞&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># Transaction <span class="number">200</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"> </span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士： 事务执行过程中，只有在第一次真正修改记录时（比如使用INSERT、DELETE、UPDATE语句），才会被分配一个单独的事务id，这个事务id是递增的。</p>
</blockquote>
<p>此刻，表t中id为1的记录得到的版本链表如下所示：</p>
<p><img src="/images/mysql-transaction/mysql-transaction-10.png" alt="image"></p>
<p>假设现在有一个使用READ COMMITTED隔离级别的事务开始执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"> </span><br><span class="line"># SELECT1：Transaction <span class="number">100</span>、<span class="number">200</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列c的值为<span class="string">&#x27;刘备&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个SELECT1的执行过程如下：</p>
<ol>
<li>在执行SELECT语句时会先生成一个ReadView，ReadView的m_ids列表的内容就是[100, 200]。</li>
<li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列c的内容是’张飞’，该版本的trx_id值为100，在m_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。</li>
<li>下一个版本的列c的内容是’关羽’，该版本的trx_id值也为100，也在m_ids列表内，所以也不符合要求，继续跳到下一个版本。</li>
<li>下一个版本的列c的内容是’刘备’，该版本的trx_id值为80，小于m_ids列表中最小的事务id100，所以这个版本是符合要求的，最后返回给用户的版本就是这条列c为’刘备’的记录。</li>
</ol>
<p>之后，我们把事务id为100的事务提交一下，就像这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># Transaction <span class="number">100</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> c <span class="operator">=</span> <span class="string">&#x27;关羽&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> c <span class="operator">=</span> <span class="string">&#x27;张飞&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>然后再到事务id为200的事务中更新一下表t中id为1的记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># Transaction <span class="number">200</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"> </span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> c <span class="operator">=</span> <span class="string">&#x27;赵云&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> c <span class="operator">=</span> <span class="string">&#x27;诸葛亮&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>此刻，表t中id为1的记录的版本链就长这样：</p>
<p><img src="/images/mysql-transaction/mysql-transaction-11.png" alt="image"></p>
<p>然后再到刚才使用READ COMMITTED隔离级别的事务中继续查找这个id为1的记录，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"> </span><br><span class="line"># SELECT1：Transaction <span class="number">100</span>、<span class="number">200</span>均未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列c的值为<span class="string">&#x27;刘备&#x27;</span></span><br><span class="line"> </span><br><span class="line"># SELECT2：Transaction <span class="number">100</span>提交，Transaction <span class="number">200</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列c的值为<span class="string">&#x27;张飞&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个SELECT2的执行过程如下：</p>
<ol>
<li>在执行SELECT语句时会先生成一个ReadView，ReadView的m_ids列表的内容就是[200]（事务id为100的那个事务已经提交了，所以生成快照时就没有它了）。</li>
<li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列c的内容是’诸葛亮’，该版本的trx_id值为200，在m_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。</li>
<li>下一个版本的列c的内容是’赵云’，该版本的trx_id值为200，也在m_ids列表内，所以也不符合要求，继续跳到下一个版本。</li>
<li>下一个版本的列c的内容是’张飞’，该版本的trx_id值为100，比m_ids列表中最小的事务id200还要小，所以这个版本是符合要求的，最后返回给用户的版本就是这条列c为’张飞’的记录。</li>
</ol>
<h3 id="REPEATABLE-READ-—在第一次读取数据时生成一个ReadView"><a href="#REPEATABLE-READ-—在第一次读取数据时生成一个ReadView" class="headerlink" title="REPEATABLE READ —在第一次读取数据时生成一个ReadView"></a>REPEATABLE READ —在第一次读取数据时生成一个ReadView</h3><p>对于使用REPEATABLE READ隔离级别的事务来说，只会在第一次执行查询语句时生成一个ReadView，之后的查询就不会重复生成了。我们还是用例子看一下是什么效果。</p>
<p>比方说现在系统里有两个id分别为100、200的事务在执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># Transaction <span class="number">100</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> c <span class="operator">=</span> <span class="string">&#x27;关羽&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> c <span class="operator">=</span> <span class="string">&#x27;张飞&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># Transaction <span class="number">200</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"> </span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>此刻，表t中id为1的记录得到的版本链表如下所示：</p>
<p><img src="/images/mysql-transaction/mysql-transaction-12.png" alt="image"></p>
<p>假设现在有一个使用REPEATABLE READ隔离级别的事务开始执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"> </span><br><span class="line"># SELECT1：Transaction <span class="number">100</span>、<span class="number">200</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列c的值为<span class="string">&#x27;刘备&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个SELECT1的执行过程如下：</p>
<ol>
<li>在执行SELECT语句时会先生成一个ReadView，ReadView的m_ids列表的内容就是[100, 200]。</li>
<li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列c的内容是’张飞’，该版本的trx_id值为100，在m_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。</li>
<li>下一个版本的列c的内容是’关羽’，该版本的trx_id值也为100，也在m_ids列表内，所以也不符合要求，继续跳到下一个版本。</li>
<li>下一个版本的列c的内容是’刘备’，该版本的trx_id值为80，小于m_ids列表中最小的事务id100，所以这个版本是符合要求的，最后返回给用户的版本就是这条列c为’刘备’的记录。</li>
</ol>
<p>之后，我们把事务id为100的事务提交一下，就像这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># Transaction <span class="number">100</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> c <span class="operator">=</span> <span class="string">&#x27;关羽&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> c <span class="operator">=</span> <span class="string">&#x27;张飞&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>然后再到事务id为200的事务中更新一下表t中id为1的记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># Transaction <span class="number">200</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"> </span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> c <span class="operator">=</span> <span class="string">&#x27;赵云&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> c <span class="operator">=</span> <span class="string">&#x27;诸葛亮&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>此刻，表t中id为1的记录的版本链就长这样：</p>
<p><img src="/images/mysql-transaction/mysql-transaction-13.png" alt="image"></p>
<p>然后再到刚才使用REPEATABLE READ隔离级别的事务中继续查找这个id为1的记录，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"> </span><br><span class="line"># SELECT1：Transaction <span class="number">100</span>、<span class="number">200</span>均未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列c的值为<span class="string">&#x27;刘备&#x27;</span></span><br><span class="line"> </span><br><span class="line"># SELECT2：Transaction <span class="number">100</span>提交，Transaction <span class="number">200</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列c的值仍为<span class="string">&#x27;刘备&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个SELECT2的执行过程如下：</p>
<ol>
<li>因为之前已经生成过ReadView了，所以此时直接复用之前的ReadView，之前的ReadView中的m_ids列表就是[100, 200]。</li>
<li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列c的内容是’诸葛亮’，该版本的trx_id值为200，在m_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。</li>
<li>下一个版本的列c的内容是’赵云’，该版本的trx_id值为200，也在m_ids列表内，所以也不符合要求，继续跳到下一个版本。</li>
<li>下一个版本的列c的内容是’张飞’，该版本的trx_id值为100，而m_ids列表中是包含值为100的事务id的，所以该版本也不符合要求，同理下一个列c的内容是’关羽’的版本也不符合要求。继续跳到下一个版本。</li>
<li>下一个版本的列c的内容是’刘备’，该版本的trx_id值为80，80小于m_ids列表中最小的事务id100，所以这个版本是符合要求的，最后返回给用户的版本就是这条列c为’刘备’的记录。</li>
</ol>
<p>也就是说两次SELECT查询得到的结果是重复的，记录的列c值都是’刘备’，这就是可重复读的含义。如果我们之后再把事务id为200的记录提交了，之后再到刚才使用REPEATABLE READ隔离级别的事务中继续查找这个id为1的记录，得到的结果还是’刘备’，具体执行过程大家可以自己分析一下。</p>
<h3 id="MVCC总结"><a href="#MVCC总结" class="headerlink" title="MVCC总结"></a>MVCC总结</h3><p>从上边的描述中我们可以看出来，所谓的MVCC（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用READ COMMITTD、REPEATABLE READ这两种隔离级别的事务在执行普通的SEELCT操作时访问记录的版本链的过程，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。READ COMMITTD、REPEATABLE READ这两个隔离级别的一个很大不同就是生成ReadView的时机不同，READ COMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复这个ReadView就好了。</p>
<p>参考：</p>
<ol>
<li><a href="https://www.cnblogs.com/personsiglewine/p/11507866.html">https://www.cnblogs.com/personsiglewine/p/11507866.html</a></li>
<li><a href="https://blog.csdn.net/qq_38538733/article/details/88902979">https://blog.csdn.net/qq_38538733/article/details/88902979</a></li>
</ol>
]]></content>
      <categories>
        <category>database</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程：volatile关键字解析</title>
    <url>/2021/05/12/java/multiThread/java-volatile/</url>
    <content><![CDATA[<p>　　volatile这个关键字可能很多朋友都听说过，或许也都用过。在Java 5之前，它是一个备受争议的关键字，因为在程序中使用它往往会导致出人意料的结果。在Java 5之后，volatile关键字才得以重获生机。</p>
<p>　　volatile关键字虽然从字面上理解起来比较简单，但是要用好不是一件容易的事情。由于volatile关键字是与Java的内存模型有关的，因此在讲述volatile关键之前，我们先来了解一下与内存模型相关的概念和知识，然后分析了volatile关键字的实现原理，最后给出了几个使用volatile关键字的场景。</p>
<h1 id="内存模型的相关概念"><a href="#内存模型的相关概念" class="headerlink" title="内存模型的相关概念"></a>内存模型的相关概念</h1><p>　　大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。</p>
<p>　　也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i = i + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。</p>
<p>　　这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。</p>
<p>　　比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？</p>
<p>　　可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。</p>
<p>　　最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</p>
<p>　　也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。</p>
<p>　　为了解决缓存不一致性问题，通常来说有以下2种解决方法：</p>
<p>　　1）通过在总线加LOCK#锁的方式</p>
<p>　　2）通过缓存一致性协议</p>
<p>　　这2种方式都是硬件层面上提供的方式。</p>
<p>　　在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i &#x3D; i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。</p>
<p>　　但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。</p>
<p>　　所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>
<p><img src="/images/java-volatile/java-volatile-1.jpg"></p>
<h1 id="并发编程中的三个概念"><a href="#并发编程中的三个概念" class="headerlink" title="并发编程中的三个概念"></a>并发编程中的三个概念</h1><p>在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念：</p>
<ol>
<li><p><strong>原子性</strong></p>
<p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p>　　一个很经典的例子就是银行账户转账问题：</p>
<p>　　比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。</p>
<p>　　试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。</p>
<p>　　所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。</p>
<p>　　同样地反映到并发编程中会出现什么结果呢？</p>
<p>　　举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i = <span class="number">9</span>;</span><br></pre></td></tr></table></figure>

<p>假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。</p>
<p>那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。</p>
</li>
<li><p><strong>可见性</strong></p>
<p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>举个简单的例子，看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程1执行的代码</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2执行的代码</span></span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure>

<p>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i &#x3D;10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p>
<p>此时线程2执行 j &#x3D; i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p>
<p>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>
</li>
<li><p><strong>有序性</strong></p>
<p>有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;              </span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">i = <span class="number">1</span>;                <span class="comment">//语句1  </span></span><br><span class="line">flag = <span class="literal">true</span>;          <span class="comment">//语句2</span></span><br></pre></td></tr></table></figure>

<p>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</p>
<p>下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p>
<p>比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。</p>
<p>但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;    <span class="comment">//语句1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">2</span>;    <span class="comment">//语句2</span></span><br><span class="line">a = a + <span class="number">3</span>;    <span class="comment">//语句3</span></span><br><span class="line">r = a*a;     <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure>

<p>那么可不可能是这个执行顺序呢： 语句2  语句1  语句4  语句3</p>
<p><img src="/images/java-volatile/java-volatile-2.jpg"></p>
<p>不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。</p>
<p>虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();   <span class="comment">//语句1</span></span><br><span class="line">inited = <span class="literal">true</span>;             <span class="comment">//语句2</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>

<p>上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p>
<p>从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</p>
<p>也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p>
</li>
</ol>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>   　　在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。</p>
<p>   　　在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。</p>
<p>   　　Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p>
<p>   　　举个简单的例子：在java中，执行下面这个语句：</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i  = <span class="number">10</span>; </span><br></pre></td></tr></table></figure>



<p>   　　执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？   	</p>
<p><strong>1. 原子性</strong></p>
<p>   ​		在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p>
<p>   　　上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：</p>
<p>   　　请分析以下哪些操作是原子性操作：</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span>;         <span class="comment">//语句1</span></span><br><span class="line">y = x;         <span class="comment">//语句2</span></span><br><span class="line">x++;           <span class="comment">//语句3</span></span><br><span class="line">x = x + <span class="number">1</span>;     <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure>

<p>   ​		咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p>
<p>   　　语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</p>
<p>   　　语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</p>
<p>   　　同样的，x++和 x &#x3D; x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>
<p>   　　所以上面4个语句只有语句1的操作具备原子性。</p>
<p>   　　也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>
<p>   　　不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。</p>
<p>   　　从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>
<p><strong>2. 可见性</strong></p>
<p>   　　对于可见性，Java提供了volatile关键字来保证可见性。</p>
<p>   　　当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
<p>   　　而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>
<p>   　　另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<p><strong>3.有序性</strong></p>
<p>   　　在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>   　　在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>
<p>   　　另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>
<p>   　　下面就来具体介绍下happens-before原则（先行发生原则）：</p>
<ul>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li>
</ul>
<p>   　　这8条原则摘自《深入理解Java虚拟机》。</p>
<p>   　　这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。</p>
<p>   　　下面我们来解释一下前4条规则：</p>
<p>   　　对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。</p>
<p>   　　第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。</p>
<p>   　　第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</p>
<p>   　　第四条规则实际上就是体现happens-before原则具备传递性。</p>
<h1 id="深入剖析volatile关键字"><a href="#深入剖析volatile关键字" class="headerlink" title="深入剖析volatile关键字"></a>深入剖析volatile关键字</h1><p>   　　在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。</p>
<p>   <strong>1.volatile关键字的两层语义</strong></p>
<p>   　　一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<p>   　　1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>
<p>   　　2）禁止进行指令重排序。</p>
<p>   　　先看一段代码，假如线程1先执行，线程2后执行：</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line">stop = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>   　　这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>
<p>   　　下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>
<p>   　　那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>
<p>   　　但是用volatile修饰之后就变得不一样了：</p>
<p>   　　第一：使用volatile关键字会强制将修改的值立即写入主存；</p>
<p>   　　第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p>
<p>   　　第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p>
<p>   　　那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p>
<p>   　　那么线程1读取到的就是最新的正确的值。</p>
<p>   <strong>2.volatile保证原子性吗？</strong></p>
<p>   　　从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？</p>
<p>   　　下面看一个例子：</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   　　大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p>
<p>   　　可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10&#x3D;10000。</p>
<p>   　　这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p>
<p>   　　在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p>
<p>   　　假如某个时刻变量inc的值为10，</p>
<p>   　　线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p>
<p>   　　然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p>
<p>   　　然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p>
<p>   　　那么两个线程分别进行了一次自增操作后，inc只增加了1。</p>
<p>   　　解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</p>
<p>   　　根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</p>
<p>   　　把上面的代码改成以下任何一种都可以达到效果：</p>
<p>   　　采用synchronized：</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   　　采用Lock：</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inc++;</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   ​		采用AtomicInteger：</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="type">AtomicInteger</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        inc.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   　　在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p>
<p>   <strong>3.volatile能保证有序性吗？</strong></p>
<p>   　　在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p>
<p>   　　volatile关键字禁止指令重排序有两层意思：</p>
<p>   　　1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p>
<p>   　　2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</p>
<p>   　　可能上面说的比较绕，举个简单的例子：</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//x、y为非volatile变量</span></span><br><span class="line"><span class="comment">//flag为volatile变量</span></span><br><span class="line"> </span><br><span class="line">x = <span class="number">2</span>;        <span class="comment">//语句1</span></span><br><span class="line">y = <span class="number">0</span>;        <span class="comment">//语句2</span></span><br><span class="line">flag = <span class="literal">true</span>;  <span class="comment">//语句3</span></span><br><span class="line">x = <span class="number">4</span>;         <span class="comment">//语句4</span></span><br><span class="line">y = -<span class="number">1</span>;       <span class="comment">//语句5</span></span><br></pre></td></tr></table></figure>

<p>​		由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p>
<p>   　　并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p>
<p>   　　那么我们回到前面举的一个例子：</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();   <span class="comment">//语句1</span></span><br><span class="line">inited = <span class="literal">true</span>;             <span class="comment">//语句2</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>

<p>   　　前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。</p>
<p>   　　这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>
<p>   <strong>4.volatile的原理和实现机制</strong></p>
<p>   　　前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。</p>
<p>   　　下面这段话摘自《深入理解Java虚拟机》：</p>
<p>   　　“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p>
<p>   　　lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p>
<p>   　　1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p>
<p>   　　2）它会强制将对缓存的修改操作立即写入主存；</p>
<p>   　　3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>
<h1 id="使用volatile关键字的场景"><a href="#使用volatile关键字的场景" class="headerlink" title="使用volatile关键字的场景"></a>使用volatile关键字的场景</h1><p>   　　synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p>
<p>   　　1）对变量的写操作不依赖于当前值</p>
<p>   　　2）该变量没有包含在具有其他变量的不变式中</p>
<p>   　　实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p>
<p>   　　事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p>
<p>   　　下面列举几个Java中使用volatile的几个场景。</p>
<p>   <strong>1.状态标记量</strong></p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlag</span><span class="params">()</span> &#123;</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">inited</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();  </span><br><span class="line">inited = <span class="literal">true</span>;            </span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>

<p>   <strong>2.double check</strong></p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="literal">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原文：<a href="https://www.cnblogs.com/dolphin0520/p/3920373.html">https://www.cnblogs.com/dolphin0520/p/3920373.html</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>ClassPathXmlApplicationContext设置配置文件路径流程</title>
    <url>/2021/05/11/spring/springcarding/AbstractRefreshableConfigApplicationContext-setConfigLocations/</url>
    <content><![CDATA[<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><div id="flowchart-0" class="flow-chart"></div>

<h3 id="流程说明"><a href="#流程说明" class="headerlink" title="流程说明"></a>流程说明</h3><ol>
<li><p>将路径加载到内存</p>
<ol>
<li><p>类</p>
<p>org.springframework.context.support.AbstractRefreshableConfigApplicationContext</p>
</li>
<li><p>说明</p>
<p>在AbstractRefreshableApplicationContext的基础上添加读取本地配置文件方法</p>
</li>
<li><p>方法</p>
<p>setConfigLocations(@Nullable String… locations)</p>
</li>
<li><p>说明</p>
<p>设置应用容器的本地配置路径，如果为空，则使用适当的默认值</p>
</li>
</ol>
</li>
</ol>
<h3 id="解析路径流程"><a href="#解析路径流程" class="headerlink" title="解析路径流程"></a>解析路径流程</h3><div id="flowchart-1" class="flow-chart"></div>

<h3 id="流程说明-1"><a href="#流程说明-1" class="headerlink" title="流程说明"></a>流程说明</h3><h3 id="获取运行环境流程"><a href="#获取运行环境流程" class="headerlink" title="获取运行环境流程"></a>获取运行环境流程</h3><div id="flowchart-2" class="flow-chart"></div>





<h3 id="流程说明-2"><a href="#流程说明-2" class="headerlink" title="流程说明"></a>流程说明</h3><h3 id="创建运行环境流程"><a href="#创建运行环境流程" class="headerlink" title="创建运行环境流程"></a>创建运行环境流程</h3><div id="flowchart-3" class="flow-chart"></div>



<h3 id="流程说明-3"><a href="#流程说明-3" class="headerlink" title="流程说明"></a>流程说明</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SpringProperties.setProperty(<span class="string">&quot;spring.getenv.ignore&quot;</span>, <span class="string">&quot;true&quot;</span>); <span class="comment">// 控制是否需要获取当前系统环境，默认获取，设置为true:不获取</span></span><br></pre></td></tr></table></figure>



<h3 id="解析配置路径流程"><a href="#解析配置路径流程" class="headerlink" title="解析配置路径流程"></a>解析配置路径流程</h3><div id="flowchart-4" class="flow-chart"></div>

<h3 id="流程说明-4"><a href="#流程说明-4" class="headerlink" title="流程说明"></a>流程说明</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">s=>start: 入口|:>/2021/05/11/springcarding/ClassPathXmlApplicationContext-main
e=>end: 返回|:>/2021/05/11/springcarding/ClassPathXmlApplicationContext-main
locations=>operation: 检查路径是否为空
resolvePath=>subroutine: 解析路径|:>#解析路径流程
s->locations->resolvePath->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><textarea id="flowchart-1-code" style="display: none">start=>start: 入口|:>#流程图
end=>end: 返回|:>#流程图
getEnvironment=>subroutine: 获取运行环境|:>#获取运行环境流程 
resolveRequiredPlaceholders=>subroutine: 解析配置路径|:>#解析配置路径流程
tirmSpace=>operation: 去除配置路径的无效空格
start->getEnvironment->resolveRequiredPlaceholders->tirmSpace->end</textarea><textarea id="flowchart-1-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-1", options);</script><textarea id="flowchart-2-code" style="display: none">start=>start: 入口|:>#解析路径流程
end=>end: 返回|:>#解析路径流程
envirmonentExists=>condition: 存在运行环境？
createEnvironment=>subroutine: 创建运行环境 |:> #创建运行环境流程
getEnvironment=>operation: 获取运行环境
start->envirmonentExists
envirmonentExists(yes)->getEnvironment
envirmonentExists(no)->createEnvironment
createEnvironment->getEnvironment
getEnvironment->end</textarea><textarea id="flowchart-2-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-2-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-2-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-2", options);</script><textarea id="flowchart-3-code" style="display: none">start=>start: 入口|:>#获取运行环境流程
end=>end: 返回|:>#获取运行环境流程
initDefaultProfiles=>operation: 初始化默认配置文件名集合
initPropertySources=>operation: 初始化多配置文件来源
initPropertyResolver=>operation: 初始化普通配置文件解析器
getSystemProperty=>operation: 获取当前系统属性信息
whichGetEnvironment=>condition: 获取当前系统环境信息?
getSystemEnvironment=>operation: 获取当前系统环境信息
start->initDefaultProfiles
initDefaultProfiles->initPropertySources
initPropertySources->initPropertyResolver
initPropertyResolver->getSystemProperty
getSystemProperty->whichGetEnvironment
whichGetEnvironment(yes)->getSystemEnvironment->end
whichGetEnvironment(no)->end</textarea><textarea id="flowchart-3-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-3-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-3-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-3", options);</script><textarea id="flowchart-4-code" style="display: none">start=>start: 入口|:>#解析路径流程
end=>end: 返回|:>#解析路径流程
helperExists=>condition: 解释器是否存在？
createHepler=>operation: 创建占位符解析器
getHelper=>operation: 获取占位符解析器
resolve=>operation: 解析本地路径
start->helperExists
helperExists(yes)->getHelper
helperExists(no)->createHepler
createHepler->getHelper
getHelper->resolve
resolve->end</textarea><textarea id="flowchart-4-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-4-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-4-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-4", options);</script>]]></content>
      <categories>
        <category>spring</category>
        <category>spring carding</category>
      </categories>
      <tags>
        <tag>spring流程梳理</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>ClassPathXmlApplicationContext创建容器流程</title>
    <url>/2021/05/11/spring/springcarding/AbstractXmlApplicationContext-new/</url>
    <content><![CDATA[<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><div id="flowchart-0" class="flow-chart"></div>


<h3 id="流程说明"><a href="#流程说明" class="headerlink" title="流程说明"></a>流程说明</h3><ol>
<li>获取资源解析器(解析本地配置文件等资源)<ol>
<li><p>类：org.springframework.context.support.AbstractApplicationContext、</p>
</li>
<li><p>说明</p>
</li>
<li><p>org.springframework.context.ApplicationContext接口的抽象实现。不要求用于配置的存储类型；<br>简单地实现通用上下文功能。使用模板方法设计模式，需要具体的子类来实现抽象方法。<br>和普通bean工厂相比较，ApplicationContext检测其内部bean工厂中定义的特殊bean并自动注册一下三个类中定义的bean</p>
<ol>
<li>org.springframework.beans.factory.config.BeanFactoryPostProcessor BeanFactoryPostProcessors</li>
<li>org.springframework.beans.factory.config.BeanPostProcessor BeanPostProcessors</li>
<li>org.springframework.context.ApplicationListener ApplicationListeners</li>
</ol>
<p>消息源类型，多播器类型也会作为bean自动注册</p>
</li>
<li><p>方法<br>AbstractApplicationContext()</p>
</li>
<li><p>说明<br>初始化容器</p>
</li>
</ol>
</li>
<li>设置父容器<ol>
<li>类<br>org.springframework.context.support.AbstractApplicationContext</li>
<li>说明<br>同上</li>
<li>方法<br>setParent(@Nullable ApplicationContext parent)</li>
<li>说明<br>设置父容器，当父容器存在时，获取父容器的运行环境<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">s=>start: 入口|:>/2021/05/11/springcarding/ClassPathXmlApplicationContext-main
e=>end: 返回|:>/2021/05/11/springcarding/ClassPathXmlApplicationContext-main
getResourceResolver=>operation: 获取资源解析器(解析本地配置文件等资源)|:>.
setParent=>operation: 设置父容器|:>.
s->getResourceResolver
getResourceResolver->setParent
setParent->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>spring</category>
        <category>spring carding</category>
      </categories>
      <tags>
        <tag>spring流程梳理</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>ClassPathXmlApplicationContext刷新容器流程</title>
    <url>/2021/05/11/spring/springcarding/AbstractApplicationContext-refresh/</url>
    <content><![CDATA[<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><div id="flowchart-0" class="flow-chart"></div>

<img  src=http://www.plantuml.com/plantuml/svg/SoWkIImgAStDuN9KqBLJSB9IA4ejB4qjBk5oKj052ZY218eBylEAKxaSKlDIW2e1>

<h3 id="流程说明"><a href="#流程说明" class="headerlink" title="流程说明"></a>流程说明</h3><h3 id="准备刷新"><a href="#准备刷新" class="headerlink" title="准备刷新"></a>准备刷新</h3><div id="flowchart-1" class="flow-chart"></div>

<h3 id="流程说明-1"><a href="#流程说明-1" class="headerlink" title="流程说明"></a>流程说明</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">s=>start: 入口|:>/2021/05/11/springcarding/ClassPathXmlApplicationContext-main
e=>end: 返回|:>/2021/05/11/springcarding/ClassPathXmlApplicationContext-main
prepare=>subroutine: 准备刷新|:>.
obtainFresh=>subroutine: 告知子类刷新内部bean工厂|:>.
prepareBeanFactory=>subroutine: 准备要使用的bean工厂|:>.
postProcessBeanFactory=>subroutine: 允许上下文子类对bean工厂进行后处理|:>.
invokeBeanFactoryPostProcessors=>subroutine: 调用在上下文中注册的bean工厂处理器|:>.
registerBeanPostProcessor=>subroutine: 注册拦截Bean创建的Bean处理器|:>.
initMessageSource=>subroutine: 初始化上下文的消息源|:>.
initApplicationEventMulticaster=>subroutine: 初始化多播器|:>.
onRefresh=>subroutine: 初始化特殊bean|:>.
registerListeners=>subroutine: 检查侦听器并注册|:>.
finishBeanFactory=>subroutine: 实例化所有非懒加载的单例bean|:>.
finishRefresh=>subroutine: 发布相应的事件|:>.
s->prepare
prepare->obtainFresh
obtainFresh->prepareBeanFactory
prepareBeanFactory->postProcessBeanFactory
postProcessBeanFactory->invokeBeanFactoryPostProcessors
invokeBeanFactoryPostProcessors->registerBeanPostProcessor
registerBeanPostProcessor->initMessageSource
initMessageSource->initApplicationEventMulticaster
initApplicationEventMulticaster->onRefresh
onRefresh->registerListeners
registerListeners->finishBeanFactory
finishBeanFactory->finishRefresh
finishRefresh->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><textarea id="flowchart-1-code" style="display: none">s=>start: 入口
startupDate=>operation: 设置启动时间
setClosedFlag=>operation: 设置关闭标志位
setActiveFlag=>operation: 设置活动标志位
writeLog=>operation: 记录日志
initPropertySources=>subroutine: 初始化占位符资源
validateProperties=>subroutine: 验证所有标记属性都是可解析的
earlyListenersExists=>condition: 早期监听器是否存在
setEarlyListeners=>operation: 设置早期监听器
cleanLinteners=>operation: 清空监听器
addListeners=>operation: 将早期监听器添加到监听器中
setEarlyEnents=>operation: 初始化事件收集器
e=>end: 返回
s->startupDate
startupDate->setClosedFlag
setClosedFlag->setActiveFlag
setActiveFlag->writeLog
writeLog->initPropertySources
initPropertySources->validateProperties
validateProperties->earlyListenersExists
earlyListenersExists(no,left)->setEarlyListeners
earlyListenersExists(yes)->cleanLinteners
cleanLinteners->addListeners
setEarlyListeners->setEarlyEnents
addListeners->setEarlyEnents
setEarlyEnents->e</textarea><textarea id="flowchart-1-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-1", options);</script>]]></content>
      <categories>
        <category>spring</category>
        <category>spring carding</category>
      </categories>
      <tags>
        <tag>spring流程梳理</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>ClassPathXmlApplicationContext初始化主流程</title>
    <url>/2021/05/11/spring/springcarding/ClassPathXmlApplicationContext-main/</url>
    <content><![CDATA[<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><div id="flowchart-0" class="flow-chart"></div>

<h3 id="流程说明"><a href="#流程说明" class="headerlink" title="流程说明"></a>流程说明</h3><ol>
<li>创建容器<ol>
<li>类：org.springframework.context.support.AbstractXmlApplicationContext</li>
<li>说明：org.springframework.context.ApplicationContext 接口的简单实现，通过org.springframework.beans.factory.xml.XmlBeanDefinitionReader 读取xml文件绘制配置图，子类只需要是实现 getConfigResources或者 getConfigLocations 方法。 此外，可以重写getResourceByPath 解释相对路径 或者使用 getResourcePatternResolver  扩展解析相对路径方法</li>
<li>方法：AbstractXmlApplicationContext(@Nullable ApplicationContext parent)</li>
<li>说明：根据给定的父容器生成实例</li>
</ol>
</li>
<li>设置配置文件路径<ol>
<li>类：org.springframework.context.support.AbstractRefreshableConfigApplicationContext</li>
<li>说明：<br>在AbstractRefreshableApplicationContext的基础上添加了公共读取本地配置文件的方法。用作基于XML的应用程序上下文实现的基类</li>
<li>方法：setConfigLocations(@Nullable String… locations)</li>
<li>方法说明：设置应用容器的本地配置路径，如果为空，则使用适当的默认值</li>
</ol>
</li>
<li>刷新容器，加载bean<ol>
<li>类：  org.springframework.context.support.AbstractApplicationContext</li>
<li>说明：</li>
<li>方法：refresh()</li>
<li>方法说明：  刷新容器，创建bean等</li>
</ol>
</li>
</ol>
<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Start
e=>end
create=>subroutine: 创建容器|:>/2021/05/11/springcarding/AbstractXmlApplicationContext-new
set_config_path=>subroutine: 设置配置文件路径|:>/2021/05/11/springcarding/AbstractRefreshableConfigApplicationContext-setConfigLocations
refresh_content=>subroutine: 刷新容器，加载bean|:>/2021/05/11/springcarding/AbstractApplicationContext-refresh
st(right)->create(right)->set_config_path(right)->refresh_content(right)->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script>]]></content>
      <categories>
        <category>spring</category>
        <category>spring carding</category>
      </categories>
      <tags>
        <tag>spring流程梳理</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Controller和RestController的区别</title>
    <url>/2021/05/11/spring/springboot/diff-with-controller-restcontroller/</url>
    <content><![CDATA[<h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><p>都是用来表示Spring某个类的是否可以接收HTTP请求</p>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><h4 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h4><p>在SpringMVC中，经常会使用注解 的方式来定义一个控制器。<br>最常用的控制器注解<code>@Controller</code>，可以在控制器类中写各种业务方法，然后返回数据。<br>一般数据的返回分成两大种，页面 和 json 格式数据</p>
<h5 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h5><ol>
<li>直接返回视图（页面）名称</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/index&quot;)</span></span><br><span class="line">String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>ModelAndView对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt;values= <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    values.put(<span class="string">&quot;id&quot;</span>,<span class="number">1L</span>);</span><br><span class="line">    values.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;user&quot;</span>, values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回页面和相应数据。一般配合 Thymeleaf 、 Velocity、FreeMarke使用。spring boot 官方推荐使用 Thymeleaf 。该方式类似早期的jsp页面，将数据渲染后的页面返回前台</p>
<h5 id="json"><a href="#json" class="headerlink" title="json"></a>json</h5><p>现在一般应用都是前后分离，所以返回json数据的方式使用更频繁。</p>
<p>我们有两种方式将返回的结果转化为json：</p>
<ol>
<li>使用 <code>@Controller</code>（修饰类） 和<code>@ResponseBody</code>（修饰方法） 两个注解，当然<code>@ResponseBody</code>还可以直接修饰类。</li>
<li>如果某个控制器类设计初衷就是返回json数据，那么该类可以使用简化方式 <code>@RestCotroller</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Controller</span>  <span class="comment">//控制器注解</span></span><br><span class="line"><span class="meta">@ResponseBody</span>   <span class="comment">//返回数据会被解析成json</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RestController &#123;</span><br><span class="line">    <span class="meta">@AliasFor(</span></span><br><span class="line"><span class="meta">        annotation = Controller.class</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的源码中可以清晰的看到<code>@RestController = @Controller + @ResponseBody</code></p>
<h5 id="如何抉择"><a href="#如何抉择" class="headerlink" title="如何抉择"></a>如何抉择</h5><p>使用<code>@Controller</code>修饰类，可以根据需要返回各种我们所需的数据（json,ModelAndView,静态页面），而使用<code>RestController</code>修饰类，最后返回结果都会被解析成json字符串，适合所有方法返回值都是json数据</p>
<p>参考：<a href="https://blog.csdn.net/yamadeee/article/details/80313068">https://blog.csdn.net/yamadeee/article/details/80313068</a></p>
]]></content>
      <categories>
        <category>spring</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo支持markdown语法化flowchart流程图</title>
    <url>/2021/05/11/hexo/hexo-support-flow-chart/</url>
    <content><![CDATA[<p>hexo默认不支持流程图，flowchart 简便易食，可以瞬间使 hexo 流程图无中生有。本文记录在hexo中添加Markdown flowchart流程图的方法。</p>
<p>添加支持</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-filter-flowchart</span><br></pre></td></tr></table></figure>

<h3 id="Flow语法结构"><a href="#Flow语法结构" class="headerlink" title="Flow语法结构"></a>Flow语法结构</h3><p>flow 语法其实是直截了当的，分为节点定义和节点连接两部分</p>
<h4 id="节点定义"><a href="#节点定义" class="headerlink" title="节点定义"></a>节点定义</h4><p>语法结构如下：X&#x3D;&gt;Y: Z<br>其中，X是变量名， Y是指操作模块名，冒号后面的Z是具体显示的文字内容。需要注意的是，冒号后要加空格才能识别，而X，Y与&#x3D;&gt;之间不允许有空格。<br>其中，变量名X和文字内容Z可以比较随意设置，但是Y是有固定的内容，主要有以下几种：</p>
<table>
<thead>
<tr>
<th align="center">操作模块名</th>
<th align="center">表示含义说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">start</td>
<td align="center">开始</td>
</tr>
<tr>
<td align="center">end</td>
<td align="center">结束</td>
</tr>
<tr>
<td align="center">operation</td>
<td align="center">普通操作模块</td>
</tr>
<tr>
<td align="center">subroutine</td>
<td align="center">子任务块</td>
</tr>
<tr>
<td align="center">condition</td>
<td align="center">判断快</td>
</tr>
<tr>
<td align="center">inputoutput</td>
<td align="center">输入输出块</td>
</tr>
</tbody></table>
<h4 id="节点连接"><a href="#节点连接" class="headerlink" title="节点连接"></a>节点连接</h4><p>定义语法节点后，需要理顺节点之间的关系，才能建立正确的流程图；<br>在flow中使用-&gt;符号连接两个前后的变量；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如： a-&gt;b-&gt;c，表示节点a转到b又到c节点；</span><br></pre></td></tr></table></figure>


<p>上述转接也可以写成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a-&gt;b</span><br><span class="line">b-&gt;c</span><br></pre></td></tr></table></figure>


<p>condition是判断，可以取yes和no两种结果，对于不同结果可以有不同走向。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cond(yes)-&gt;out表示condition成立时转向out执行；</span><br><span class="line">cond(no)-&gt;op表示condition不成立时转向op执行；</span><br></pre></td></tr></table></figure>

<h4 id="连接方向"><a href="#连接方向" class="headerlink" title="连接方向"></a>连接方向</h4><ul>
<li>连接线有上下左右四个方向，如果需要指定连接线连接到某一特定方向，在连接线开始的元素后面添加方向即可，方向包括：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(top)</span><br><span class="line">(bottom)</span><br><span class="line">(left)</span><br><span class="line">(right)</span><br></pre></td></tr></table></figure>

<ul>
<li>如果要设置条件框连接线方向，在括号中添加即可。条件框只有两个方向可供选择：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># yes向下，no向右（默认）</span><br><span class="line"># yes向右，no向下。</span><br><span class="line">cond(yes,right)</span><br><span class="line">cond(no,bottom)</span><br></pre></td></tr></table></figure>

<p>只需要指定其中一条分支的方向即可。</p>
<p>参考：<a href="https://blog.csdn.net/zywvvd/article/details/110150617">https://blog.csdn.net/zywvvd/article/details/110150617</a></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>在linux和docker上使用selenium</title>
    <url>/2021/05/10/python/use-selenium-on-linux/</url>
    <content><![CDATA[<ol>
<li><p>vim &#x2F;etc&#x2F;yum.repos.d&#x2F;google.repo<br># 把下面的内容复制进去</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[google]</span><br><span class="line">name=Google-x86_64</span><br><span class="line">baseurl=http://dl.google.com/linux/rpm/stable/x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">gpgkey=https://dl-ssl.google.com/linux/linux_signing_key.pub</span><br></pre></td></tr></table></figure>
</li>
<li><p>sudo yum makecache</p>
</li>
<li><p>sudo yum install google-chrome-stable -y</p>
</li>
<li><p>google-chrome –version</p>
</li>
<li><p>下载chromedriver</p>
<p><a href="http://npm.taobao.org/mirrors/chromedriver/">http://npm.taobao.org/mirrors/chromedriver/</a></p>
<p>把二进制文件放入到miniconda 的bin目录下<br>如果运行报错</p>
<p>尝试添加chrome_options.add_argument(‘–no-sandbox’)</p>
</li>
</ol>
<p>docker 使用selenium，启动容器时需要添加：–privileged</p>
<p>docker run -itd –privileged spider-executor &#x2F;bin&#x2F;bash </p>
]]></content>
      <categories>
        <category>selenium</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>linux selenium</tag>
        <tag>docker selenium</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown基础语法</title>
    <url>/2021/05/10/markdown/markdown-base-grammar/</url>
    <content><![CDATA[<p>Markdown是一种纯文本格式的标记语言。</p>
<p>通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>
<p>相比WYSIWYG编辑器</p>
<p><strong>优点：</strong></p>
<ol>
<li>因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。</li>
<li>操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>需要记一些语法（当然，是很简单。五分钟学会）。</li>
<li>有些平台不支持Markdown编辑模式。</li>
</ol>
<h1 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h1><p>在想要设置为标题的文字前面加#来表示</p>
<p>一个#是一级标题，</p>
<p>二个#是二级标题，以此类推。支持六级标题。</p>
<p><strong>注：标准语法一般在#后跟个空格再写文字。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><hr>
<h1 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h1><ul>
<li><p>加粗</p>
<ul>
<li>要加粗的文字左右分别用两个*号包起来</li>
</ul>
</li>
<li><p>斜体</p>
<ul>
<li>要倾斜的文字左右分别用一个*号包起来</li>
</ul>
</li>
<li><p>加粗斜体</p>
<ul>
<li>要倾斜和加粗的文字左右分别用三个*号包起来</li>
</ul>
</li>
<li><p>删除线</p>
<ul>
<li>要加删除线的文字左右分别用两个~~号包起来</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*`</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><strong>这是加粗的文字</strong></p>
<p><em>这是倾斜的文字</em></p>
<p><em><strong>这是斜体加粗的文字</strong></em></p>
<p><del>这是加删除线的文字</del></p>
</li>
</ul>
<h1 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h1><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure>

<p>效果如下</p>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
<blockquote>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h1 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h1><p>三个或者三个以上的 - 或者 * 都可以。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例</span><br><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>

<p>效果如下</p>
<hr>
<hr>
<hr>
<hr>
<h1 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：![图片alt](图片地址 &quot;图片title&quot;)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure>

<h1 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">[简书](http://jianshu.com)</span><br><span class="line">[百度](http://baidu.com)</span><br></pre></td></tr></table></figure>

<p>效果如下</p>
<p><a href="http://jianshu.com/">简书</a></p>
<p><a href="http://baidu.com/">百度</a></p>
<h1 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h1><ol>
<li>无序列表</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：无序列表用 - + * 任何一种都可以</span><br><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<ul>
<li>列表内容</li>
</ul>
<ul>
<li>列表内容</li>
</ul>
<ul>
<li>列表内容</li>
</ul>
<ol start="2">
<li>有序列表</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：数字加点</span><br><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<ol>
<li>列表内容</li>
<li>列表内容</li>
<li>列表内容</li>
</ol>
<p>列表嵌套</p>
<p><strong>上一级和下一级之间敲三个空格即可</strong></p>
<ul>
<li>一级无序列表内容<ul>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
</ul>
</li>
<li>一级无序列表内容<ol>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
</ol>
</li>
</ul>
<ol>
<li>一级有序列表内容<ul>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
</ul>
</li>
<li>一级有序列表内容<ol>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
</ol>
</li>
</ol>
<h1 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line">注：原生的语法两边都要用 | 包起来。此处省略</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">姓名|技能|排行</span><br><span class="line">--|:--:|--:</span><br><span class="line">刘备|哭|大哥</span><br><span class="line">关羽|打|二哥</span><br><span class="line">张飞|骂|三弟</span><br></pre></td></tr></table></figure>

<p>效果如下</p>
<table>
<thead>
<tr>
<th>姓名</th>
<th align="center">技能</th>
<th align="right">排行</th>
</tr>
</thead>
<tbody><tr>
<td>刘备</td>
<td align="center">哭</td>
<td align="right">大哥</td>
</tr>
<tr>
<td>关羽</td>
<td align="center">打</td>
<td align="right">二哥</td>
</tr>
<tr>
<td>张飞</td>
<td align="center">骂</td>
<td align="right">三弟</td>
</tr>
</tbody></table>
<h1 id="九、代码"><a href="#九、代码" class="headerlink" title="九、代码"></a>九、代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：单行代码：代码之间分别用一个反引号包起来</span><br><span class="line">`代码内容`</span><br><span class="line">代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</span><br><span class="line">​```</span><br><span class="line">代码...</span><br><span class="line">代码...</span><br><span class="line">代码...</span><br><span class="line">​```</span><br><span class="line">注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。</span><br><span class="line">示例：</span><br><span class="line">单行代码</span><br><span class="line">`create database hero;`</span><br><span class="line">代码块</span><br><span class="line">(```)</span><br><span class="line">function fun()&#123;</span><br><span class="line">echo &quot;这是一句非常牛逼的代码&quot;;</span><br><span class="line">&#125;</span><br><span class="line">fun();</span><br><span class="line">(```)</span><br><span class="line">效果如下：</span><br><span class="line">单行代码</span><br><span class="line">create database hero;</span><br><span class="line">代码块</span><br><span class="line">function fun()&#123;</span><br><span class="line">echo &quot;这是一句非常牛逼的代码&quot;;</span><br><span class="line">&#125;</span><br><span class="line">fun();</span><br></pre></td></tr></table></figure>

<h1 id="十、流程图"><a href="#十、流程图" class="headerlink" title="十、流程图"></a>十、流程图</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">元素定义语法：</span><br><span class="line">tag=&gt;type: content:&gt;url</span><br><span class="line">tag就是元素名字，</span><br><span class="line">type是这个元素的类型，有6中类型，分别为：</span><br><span class="line">  1. start # 开始</span><br><span class="line">  2. end # 结束</span><br><span class="line">  3. operation # 操作</span><br><span class="line">  4. subroutine # 子程序</span><br><span class="line">  5. condition # 条件</span><br><span class="line">  6. inputoutput # 输入或产出</span><br><span class="line">content就是在框框中要写的内容，注意type后的冒号与文本之间一定要有个空格。</span><br><span class="line">url是一个连接，与框框中的文本相绑定</span><br><span class="line">-&gt;: 连接元素，</span><br><span class="line">condition有两个分支，如下所示：</span><br><span class="line">c2(yes)-&gt;io-&gt;e </span><br><span class="line">c2(no)-&gt;op2-&gt;e</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p>flow<br>st&#x3D;&gt;start: Start|past:&gt;<a href="http://www.google.com[blank]">http://www.google.com[blank]</a><br>e&#x3D;&gt;end: End:&gt;<a href="http://www.google.com/">http://www.google.com</a><br>op1&#x3D;&gt;operation: get_hotel_ids|past<br>op2&#x3D;&gt;operation: get_proxy|current<br>sub1&#x3D;&gt;subroutine: get_proxy|current<br>op3&#x3D;&gt;operation: save_comment|current<br>op4&#x3D;&gt;operation: set_sentiment|current<br>op5&#x3D;&gt;operation: set_record|current</p>
<p>cond1&#x3D;&gt;condition: ids_remain空?<br>cond2&#x3D;&gt;condition: proxy_list空?<br>cond3&#x3D;&gt;condition: ids_got空?<br>cond4&#x3D;&gt;condition: 爬取成功??<br>cond5&#x3D;&gt;condition: ids_remain空?</p>
<p>io1&#x3D;&gt;inputoutput: ids-remain<br>io2&#x3D;&gt;inputoutput: proxy_list<br>io3&#x3D;&gt;inputoutput: ids-got</p>
<p>st-&gt;op1(right)-&gt;io1-&gt;cond1<br>cond1(yes)-&gt;sub1-&gt;io2-&gt;cond2<br>cond2(no)-&gt;op3<br>cond2(yes)-&gt;sub1<br>cond1(no)-&gt;op3-&gt;cond4<br>cond4(yes)-&gt;io3-&gt;cond3<br>cond4(no)-&gt;io1<br>cond3(no)-&gt;op4<br>cond3(yes, right)-&gt;cond5<br>cond5(yes)-&gt;op5<br>cond5(no)-&gt;cond3<br>op5-&gt;e</p>
<p>效果：</p>
<div id="flowchart-0" class="flow-chart"></div>

<p>参考：</p>
<p>流程图：<a href="https://www.jianshu.com/p/02a5a1bf1096">https://www.jianshu.com/p/02a5a1bf1096</a></p>
<p>其他：<a href="https://www.jianshu.com/p/191d1e21f7ed">https://www.jianshu.com/p/191d1e21f7ed</a><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Start|past:>http://www.google.com[blank]
e=>end: End:>http://www.google.com
op1=>operation: get_hotel_ids|past
op2=>operation: get_proxy|current
sub1=>subroutine: get_proxy|current
op3=>operation: save_comment|current
op4=>operation: set_sentiment|current
op5=>operation: set_record|current

cond1=>condition: ids_remain空?
cond2=>condition: proxy_list空?
cond3=>condition: ids_got空?
cond4=>condition: 爬取成功??
cond5=>condition: ids_remain空?

io1=>inputoutput: ids-remain
io2=>inputoutput: proxy_list
io3=>inputoutput: ids-got

st->op1(right)->io1->cond1
cond1(yes)->sub1->io2->cond2
cond2(no)->op3
cond2(yes)->sub1
cond1(no)->op3->cond4
cond4(yes)->io3->cond3
cond4(no)->io1
cond3(no)->op4
cond3(yes, right)->cond5
cond5(yes)->op5
cond5(no)->cond3
op5->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>python+opencv获取图片中指定颜色的部分</title>
    <url>/2021/05/10/python/python-opencv-get-coler-in-img/</url>
    <content><![CDATA[<ol>
<li>将图片的色彩空间转为HSV色彩空间</li>
<li>通过比照HSV的参考表，进行获取要提取颜色的相应范围</li>
<li>使用inRange函数进行提取</li>
<li>使用imShow显示</li>
</ol>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">src = cv2.imread(<span class="string">&quot;D:\\myCode\\picture\\cards.png&quot;</span>)</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;input&quot;</span>, cv2.WINDOW_AUTOSIZE)</span><br><span class="line">cv2.imshow(<span class="string">&quot;input&quot;</span>, src)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">提取图中的红色部分</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">hsv = cv2.cvtColor(src, cv2.COLOR_BGR2HSV)</span><br><span class="line">low_hsv = np.array([<span class="number">0</span>,<span class="number">43</span>,<span class="number">46</span>])</span><br><span class="line">high_hsv = np.array([<span class="number">10</span>,<span class="number">255</span>,<span class="number">255</span>])</span><br><span class="line">mask = cv2.inRange(hsv,lowerb=low_hsv,upperb=high_hsv)</span><br><span class="line">cv2.imshow(<span class="string">&quot;test&quot;</span>,mask)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"><span class="comment"># 这个例子为提取红色部分。通过观察下表，可以看到红色的hmin，smin，vmin分别为0，43，46； hmax，smax，vmax分别为10，255，255.</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/python-opencv-get-coler-in-img.png" alt="Image"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>opencv</tag>
        <tag>图像识别</tag>
      </tags>
  </entry>
  <entry>
    <title>spring @ComponentScan和@MapperScan区别</title>
    <url>/2021/05/10/spring/springboot/spring-diff-componentscan-mapperscan/</url>
    <content><![CDATA[<ul>
<li>@MapperScan:<ul>
<li>扫描mapper类的注解</li>
</ul>
</li>
<li>@ComponentScan:<ul>
<li>扫描使用 @Controller @Service @Repository 注解的类，默认扫描使用@ComponentScan的目录和子目录</li>
</ul>
</li>
</ul>
<p>在同一个项目中可以同时使用</p>
]]></content>
      <categories>
        <category>spring</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>maven常用命令</title>
    <url>/2021/05/08/java/utils/maven-cmd/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn package -DskipTests=true -P prod (跳过测试，并使用prod yml 配置文件)</span><br><span class="line">mvn test-compile 编译测试代码（有时候会跳过，原因暂未找到）</span><br><span class="line">mvn compile 编译代码</span><br><span class="line">mvn install:install-file -Dfile=&lt;path-to-file&gt; -DgroupId=&lt;group-id&gt; \</span><br><span class="line">    -DartifactId=&lt;artifact-id&gt; -Dversion=&lt;version&gt; -Dpackaging=&lt;packaging&gt; 生成本地库</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql,mongo数据迁移</title>
    <url>/2021/05/08/database/mysql-mongo-data-transfer/</url>
    <content><![CDATA[<p>mysql:</p>
<p>使用navicat工具：一条一条导入，性能较差 </p>
<p>详情：<a href="https://blog.csdn.net/xuanjiewu/article/details/86152633">https://blog.csdn.net/xuanjiewu/article/details/86152633</a></p>
<p>使用mysqldump导出导入数据</p>
<p>导出数据</p>
<p>eg: </p>
<p>导入数据</p>
<p>eg:</p>
<p>详情：<a href="https://dev.mysql.com/doc/refman/8.0/en/mysqldump.html#mysqldump-option-examples">https://dev.mysql.com/doc/refman/8.0/en/mysqldump.html#mysqldump-option-examples</a></p>
<p>使用workbench导入导出数据</p>
<p>详情：<a href="https://dev.mysql.com/doc/workbench/en/wb-admin-export-import-management.html">https://dev.mysql.com/doc/workbench/en/wb-admin-export-import-management.html</a></p>
<p>mongo:</p>
<p>mongo tools下载路径：<a href="https://docs.mongodb.com/database-tools/installation/installation/">https://docs.mongodb.com/database-tools/installation/installation/</a></p>
<p>使用mongodump备份数据</p>
<p>eg:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mongodump -h &lt;host:port&gt; -d &lt;db&gt; -c &lt;collection&gt; -u &lt;user&gt; -p &lt;password&gt; -o &lt;directory-path&gt;</span><br></pre></td></tr></table></figure>

<p>详情：<a href="https://docs.mongodb.com/database-tools/mongodump/">https://docs.mongodb.com/database-tools/mongodump/</a></p>
<p>使用mongorestore导入数据</p>
<p>eg:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mongorestore -h &lt;host:port&gt; -d &lt;db&gt; -c &lt;collection&gt; -u &lt;user&gt; -p &lt;password&gt; --drop &lt;input-path&gt;</span><br></pre></td></tr></table></figure>

<p>详情：<a href="https://docs.mongodb.com/database-tools/mongorestore/">https://docs.mongodb.com/database-tools/mongorestore/</a></p>
<p>注意：可能不包含索引（不知道是使用数据源不包含索引原因，还是使用这种方式不包含索引）</p>
]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>mongo</tag>
        <tag>数据迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>修改jar包中的配置文件</title>
    <url>/2021/05/08/java/utils/modify-jar-config/</url>
    <content><![CDATA[<p>有时候经常因为不同开发机器上的一部分配置不同，导致项目中的配置文件有些用户名密码等信息有差异，临时打包的时候经常忘记修改，可以重新打包，但是重新打包如果花费时间过长的时候这样做就太不划算了。因此专门百度了不同的方式，找了一种不需要安装其他工具的方式，综合他们的方法，我详细记录一下我的修改过程（以下过程按照顺序执行，可以跳过某些步骤）：</p>
<ol>
<li><p>列出jar文件清单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jar tf abc.jar</span><br></pre></td></tr></table></figure>
</li>
<li><p>将需要修改的文件解压出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jar xf abc.jar BOOT-INF/classes/application.properties</span><br></pre></td></tr></table></figure></li>
</ol>
<p>此时，会在当前jar包的同级目录下生成一个相对路径文件夹（所要修改的文件就在这里），然后修改文件中的内容</p>
<ol start="3">
<li><p>使用修改后的文件替换jar包中对应的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jar uf abc.jar BOOT-INF/classes/application.properties</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile 说明</title>
    <url>/2021/05/08/docker/dockerFile/</url>
    <content><![CDATA[<ul>
<li>FROM #基础镜像，一切从这里开始</li>
<li>MAINTAINER #镜像作者姓名、邮箱</li>
<li>RUN #镜像构建时需要运行的命令</li>
<li>ADD #步骤，tomcat镜像，这个tomcat压缩包，添加内容</li>
<li>WORKDIR #镜像工作的目录</li>
<li>VOLUME #挂载卷的目录</li>
<li>EXPOST #暴露端口位置</li>
<li>CMD #指定这个容器启动时要运行的命令，只有最后一个命令会生效，可被替代</li>
<li>ENTRYPOINT #指定这个容器启动时要运行的命令，可以追加命令</li>
<li>ONBUILD #当构建一个被继承 Dockerfile 这个时候就会运行 ONBUILD 的指令，触发指令</li>
<li>COPY #类似ADD，将我们文件拷贝到镜像中</li>
<li>ENV #构建时设置环境变量</li>
</ul>
<hr>
<p>ADD和COPY区别：</p>
<ul>
<li>ADD会解压文件，COPY不会</li>
<li>正常情况下建议使用COPY</li>
</ul>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>Dockerfile</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot使用Swagger2提示Unable to infer base url错误</title>
    <url>/2021/05/08/spring/springboot/swagger2-unable-to-infer-base-url-error/</url>
    <content><![CDATA[<p><strong>错误信息为：</strong></p>
<p>Unable to infer base url.<br>This is common when using dynamic servlet registration or when the API is behind an API Gateway.<br>The base url is the root of where all the swagger resources are served. For e.g. if the api is available at <a href="http://example.org/api/v2/api-docs">http://example.org/api/v2/api-docs</a> then the base url is <a href="http://example.org/api/">http://example.org/api/</a>.<br>Please enter the location manually:</p>
<p><img src="/images/swagger_error.png"></p>
<p><strong>解决方法：</strong></p>
<ul>
<li>在application启动类中未定义@EnableSwagger2注解</li>
</ul>
]]></content>
      <categories>
        <category>spring</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>docker安装</title>
    <url>/2021/05/07/docker/docker-install/</url>
    <content><![CDATA[<h3 id="1-安装依赖包"><a href="#1-安装依赖包" class="headerlink" title="1.安装依赖包"></a>1.安装依赖包</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>

<h3 id="2-设置阿里云镜像源"><a href="#2-设置阿里云镜像源" class="headerlink" title="2.设置阿里云镜像源"></a>2.设置阿里云镜像源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<h3 id="3-安装-Docker-CE"><a href="#3-安装-Docker-CE" class="headerlink" title="3.安装 Docker-CE"></a>3.安装 Docker-CE</h3><ul>
<li><p>重建 Yum 缓存。</p>
</li>
<li><p>安装 Docker-CE ，请执行一下命令进行安装：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce</span><br></pre></td></tr></table></figure>

<h3 id="4-启动-Docker-CE"><a href="#4-启动-Docker-CE" class="headerlink" title="4.启动 Docker-CE"></a>4.启动 Docker-CE</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable dockersudo systemctl start docker</span><br></pre></td></tr></table></figure>
<h3 id="5-可选-为-Docker-建立用户组"><a href="#5-可选-为-Docker-建立用户组" class="headerlink" title="5.[可选]为 Docker 建立用户组"></a>5.[可选]为 Docker 建立用户组</h3><p>docker 命令与 Docker 引擎通讯之间通过 UnixSocket ，但是能够有权限访问 UnixSocket 的用户只有 root 和 docker 用户组的用户才能够进行访问，所以我们需要建立一个 docker 用户组，并且将需要访问 docker 的用户添加到这一个用户组当中来。</p>
<ul>
<li>建立 Docker 用户组<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker</span><br></pre></td></tr></table></figure></li>
<li>添加当前用户到 docker 组<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure></li>
<li>刷新用户组<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo newgrp docker</span><br></pre></td></tr></table></figure></li>
</ul>
<p>参考：<a href="https://www.cnblogs.com/myzony/p/9071210.html">https://www.cnblogs.com/myzony/p/9071210.html</a></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>docker install</tag>
      </tags>
  </entry>
  <entry>
    <title>docker基础</title>
    <url>/2021/05/07/docker/docker-base/</url>
    <content><![CDATA[<ol>
<li><a href="../docker-install">docker install</a></li>
<li><a href="../../08/dockerFile">Dockerfile</a></li>
<li><a href="../docker-swarm">docker swarm</a></li>
</ol>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker三剑客之Docker Swarm</title>
    <url>/2021/05/07/docker/docker-swarm/</url>
    <content><![CDATA[<h2 id="一、什么是Docker-Swarm"><a href="#一、什么是Docker-Swarm" class="headerlink" title="一、什么是Docker Swarm"></a>一、什么是Docker Swarm</h2><p><img src="/images/docker-swarm/docker-swarm-1.png" alt="img"></p>
<p>　　Swarm是Docker公司推出的用来管理docker集群的平台，几乎全部用GO语言来完成的开发的，代码开源在<a href="https://github.com/docker/swarm%EF%BC%8C">https://github.com/docker/swarm，</a> 它是将一群Docker宿主机变成一个单一的虚拟主机，Swarm使用标准的Docker API接口作为其前端的访问入口，换言之，各种形式的Docker</p>
<p>Client(compose,docker-py等)均可以直接与Swarm通信，甚至Docker本身都可以很容易的与Swarm集成，这大大方便了用户将原本基于单节点的系统移植到Swarm上，同时Swarm内置了对Docker网络插件的支持，用户也很容易的部署跨主机的容器集群服务。</p>
<p>　　Docker Swarm 和 Docker Compose 一样，都是 Docker 官方容器编排项目，但不同的是，Docker Compose 是一个在单个服务器或主机上创建多个容器的工具，而 Docker Swarm 则可以在多个服务器或主机上创建容器集群服务，对于微服务的部署，显然 Docker Swarm 会更加适合。</p>
<p>从 Docker 1.12.0 版本开始，Docker Swarm 已经包含在 Docker 引擎中（docker swarm），并且已经内置了服务发现工具，我们就不需要像之前一样，再配置 Etcd 或者 Consul 来进行服务发现配置了。</p>
<p>　　Swarm deamon只是一个调度器(Scheduler)加路由器(router),Swarm自己不运行容器，它只是接受Docker客户端发来的请求，调度适合的节点来运行容器，这就意味着，即使Swarm由于某些原因挂掉了，集群中的节点也会照常运行，放Swarm重新恢复运行之后，他会收集重建集群信息。</p>
<h2 id="二、Docker-Swarm-基本结构图"><a href="#二、Docker-Swarm-基本结构图" class="headerlink" title="二、Docker Swarm 基本结构图"></a>二、Docker Swarm 基本结构图</h2><p><img src="/images/docker-swarm/docker-swarm-2.png" alt="img"></p>
<p>在结构图可以看出 Docker Client使用Swarm对 集群(Cluster)进行调度使用。</p>
<p>上图可以看出，Swarm是典型的master-slave结构，通过发现服务来选举manager。manager是中心管理节点，各个node上运行agent接受manager的统一管理，集群会自动通过Raft协议分布式选举出manager节点，无需额外的发现服务支持，避免了单点的瓶颈问题，同时也内置了DNS的负载均衡和对外部负载均衡机制的集成支持</p>
<h2 id="三-Swarm的几个关键概念"><a href="#三-Swarm的几个关键概念" class="headerlink" title="三.Swarm的几个关键概念"></a>三.Swarm的几个关键概念</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.Swarm</span><br><span class="line">集群的管理和编排是使用嵌入docker引擎的SwarmKit，可以在docker初始化时启动swarm模式或者加入已存在的swarm</span><br><span class="line"> </span><br><span class="line">2.Node</span><br><span class="line">一个节点是docker引擎集群的一个实例。您还可以将其视为Docker节点。您可以在单个物理计算机或云服务器上运行一个或多个节点，但生产群集部署通常包括分布在多个物理和云计算机上的Docker节点。</span><br><span class="line">要将应用程序部署到swarm，请将服务定义提交给 管理器节点。管理器节点将称为任务的工作单元分派 给工作节点。</span><br><span class="line">Manager节点还执行维护所需群集状态所需的编排和集群管理功能。Manager节点选择单个领导者来执行编排任务。</span><br><span class="line">工作节点接收并执行从管理器节点分派的任务。默认情况下，管理器节点还将服务作为工作节点运行，但您可以将它们配置为仅运行管理器任务并且是仅管理器节点。代理程序在每个工作程序节点上运行，并报告分配给它的任务。工作节点向管理器节点通知其分配的任务的当前状态，以便管理器可以维持每个工作者的期望状态。</span><br><span class="line"> </span><br><span class="line">3.Service</span><br><span class="line">一个服务是任务的定义，管理机或工作节点上执行。它是群体系统的中心结构，是用户与群体交互的主要根源。创建服务时，你需要指定要使用的容器镜像。</span><br><span class="line"> </span><br><span class="line">4.Task</span><br><span class="line">任务是在docekr容器中执行的命令，Manager节点根据指定数量的任务副本分配任务给worker节点</span><br><span class="line"> </span><br><span class="line">------------------------------------------使用方法-------------------------------------</span><br><span class="line">docker swarm：集群管理，子命令有init, join, leave, update。（docker swarm --help查看帮助）</span><br><span class="line">docker service：服务创建，子命令有create, inspect, update, remove, tasks。（docker service--help查看帮助）</span><br><span class="line">docker node：节点管理，子命令有accept, promote, demote, inspect, update, tasks, ls, rm。（docker node --help查看帮助）</span><br><span class="line">   </span><br><span class="line">node是加入到swarm集群中的一个docker引擎实体，可以在一台物理机上运行多个node，node分为：</span><br><span class="line">manager nodes，也就是管理节点</span><br><span class="line">worker nodes，也就是工作节点</span><br><span class="line"> </span><br><span class="line">1）manager node管理节点：执行集群的管理功能，维护集群的状态，选举一个leader节点去执行调度任务。</span><br><span class="line">2）worker node工作节点：接收和执行任务。参与容器集群负载调度，仅用于承载task。</span><br><span class="line">3）service服务：一个服务是工作节点上执行任务的定义。创建一个服务，指定了容器所使用的镜像和容器运行的命令。</span><br><span class="line">   service是运行在worker nodes上的task的描述，service的描述包括使用哪个docker 镜像，以及在使用该镜像的容器中执行什么命令。</span><br><span class="line">4）task任务：一个任务包含了一个容器及其运行的命令。task是service的执行实体，task启动docker容器并在容器中执行任务。</span><br></pre></td></tr></table></figure>

<h2 id="四、Swarm的工作模式"><a href="#四、Swarm的工作模式" class="headerlink" title="四、Swarm的工作模式"></a>四、Swarm的工作模式</h2><ol>
<li>Node</li>
</ol>
<p><img src="/images/docker-swarm/docker-swarm-3.png" alt="img"></p>
<ol start="2">
<li>Service</li>
</ol>
<p><img src="/images/docker-swarm/docker-swarm-4.png" alt="img"></p>
<ol start="3">
<li>任务与调度</li>
</ol>
<p><img src="/images/docker-swarm/docker-swarm-5.png" alt="img"></p>
<ol start="4">
<li>服务副本与全局服务</li>
</ol>
<p><img src="/images/docker-swarm/docker-swarm-6.png" alt="img"></p>
<h2 id="五、Swarm的调度策略"><a href="#五、Swarm的调度策略" class="headerlink" title="五、Swarm的调度策略"></a>五、Swarm的调度策略</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Swarm在调度(scheduler)节点（leader节点）运行容器的时候，会根据指定的策略来计算最适合运行容器的节点，目前支持的策略有：spread, binpack, random.</span><br><span class="line">1）Random</span><br><span class="line">顾名思义，就是随机选择一个Node来运行容器，一般用作调试用，spread和binpack策略会根据各个节点的可用的CPU, RAM以及正在运</span><br><span class="line">行的容器的数量来计算应该运行容器的节点。</span><br><span class="line">  </span><br><span class="line">2）Spread</span><br><span class="line">在同等条件下，Spread策略会选择运行容器最少的那台节点来运行新的容器，binpack策略会选择运行容器最集中的那台机器来运行新的节点。</span><br><span class="line">使用Spread策略会使得容器会均衡的分布在集群中的各个节点上运行，一旦一个节点挂掉了只会损失少部分的容器。</span><br><span class="line">  </span><br><span class="line">3）Binpack</span><br><span class="line">Binpack策略最大化的避免容器碎片化，就是说binpack策略尽可能的把还未使用的节点留给需要更大空间的容器运行，尽可能的把容器运行在</span><br><span class="line">一个节点上面。</span><br></pre></td></tr></table></figure>

<h2 id="六、Swarm-Cluster模式特性"><a href="#六、Swarm-Cluster模式特性" class="headerlink" title="六、Swarm Cluster模式特性"></a>六、Swarm Cluster模式特性</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1）批量创建服务</span><br><span class="line">建立容器之前先创建一个overlay的网络，用来保证在不同主机上的容器网络互通的网络模式</span><br><span class="line">   </span><br><span class="line">2）强大的集群的容错性</span><br><span class="line">当容器副本中的其中某一个或某几个节点宕机后，cluster会根据自己的服务注册发现机制，以及之前设定的值--replicas n，</span><br><span class="line">在集群中剩余的空闲节点上，重新拉起容器副本。整个副本迁移的过程无需人工干预，迁移后原本的集群的load balance依旧好使！</span><br><span class="line">不难看出，docker service其实不仅仅是批量启动服务这么简单，而是在集群中定义了一种状态。Cluster会持续检测服务的健康状态</span><br><span class="line">并维护集群的高可用性。</span><br><span class="line">   </span><br><span class="line">3）服务节点的可扩展性</span><br><span class="line">Swarm Cluster不光只是提供了优秀的高可用性，同时也提供了节点弹性扩展或缩减的功能。当容器组想动态扩展时，只需通过scale</span><br><span class="line">参数即可复制出新的副本出来。</span><br><span class="line">   </span><br><span class="line">仔细观察的话，可以发现所有扩展出来的容器副本都run在原先的节点下面，如果有需求想在每台节点上都run一个相同的副本，方法</span><br><span class="line">其实很简单，只需要在命令中将&quot;--replicas n&quot;更换成&quot;--mode=global&quot;即可！</span><br><span class="line">  </span><br><span class="line">复制服务（--replicas n）</span><br><span class="line">将一系列复制任务分发至各节点当中，具体取决于您所需要的设置状态，例如“--replicas 3”。</span><br><span class="line">  </span><br><span class="line">全局服务（--mode=global）</span><br><span class="line">适用于集群内全部可用节点上的服务任务，例如“--mode global”。如果大家在 Swarm 集群中设有 7 台 Docker 节点，则全部节点之上都将存在对应容器。</span><br><span class="line">   </span><br><span class="line">4. 调度机制</span><br><span class="line">所谓的调度其主要功能是cluster的server端去选择在哪个服务器节点上创建并启动一个容器实例的动作。它是由一个装箱算法和过滤器</span><br><span class="line">组合而成。每次通过过滤器（constraint）启动容器的时候，swarm cluster 都会调用调度机制筛选出匹配约束条件的服务器，并在这上面运行容器。</span><br><span class="line">   </span><br><span class="line">------------------Swarm cluster的创建过程包含以下三个步骤----------------------</span><br><span class="line">1）发现Docker集群中的各个节点，收集节点状态、角色信息，并监视节点状态的变化</span><br><span class="line">2）初始化内部调度（scheduler）模块</span><br><span class="line">3）创建并启动API监听服务模块</span><br><span class="line">   </span><br><span class="line">一旦创建好这个cluster，就可以用命令docker service批量对集群内的容器进行操作，非常方便！</span><br><span class="line">   </span><br><span class="line">在启动容器后，docker 会根据当前每个swarm节点的负载判断，在负载最优的节点运行这个task任务，用&quot;docker service ls&quot; 和&quot;docker service ps + taskID&quot;</span><br><span class="line">可以看到任务运行在哪个节点上。容器启动后，有时需要等待一段时间才能完成容器创建。</span><br></pre></td></tr></table></figure>

<h2 id="七、Dcoker-Swarm-集群部署"><a href="#七、Dcoker-Swarm-集群部署" class="headerlink" title="七、Dcoker Swarm 集群部署"></a>七、Dcoker Swarm 集群部署</h2><p>温馨提示：</p>
<p>机器环境(三台机器，centos系统)</p>
<p>IP：192.168.31.43 主机名：manager43 担任角色：swarm manager</p>
<p>IP：192.168.31.188 主机名：node188 担任角色：swarm node</p>
<p>IP：192.168.31.139 主机名：node139 担任角色：swarm node</p>
<p>1、准备工作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) 修改主机名</span><br><span class="line"># 192.168.31.43  主机上执行</span><br><span class="line">[root@manager43 ~]# hostnamectl set-hostname manager43</span><br><span class="line"> </span><br><span class="line"># 192.168.31.188 主机上执行</span><br><span class="line">[root@node188 ~]# hostnamectl set-hostname node188</span><br><span class="line"> </span><br><span class="line"># 192.168.31.139 主机上执行</span><br><span class="line">[root@node139 ~]# hostnamectl set-hostname node139</span><br><span class="line"> </span><br><span class="line">2)配置hosts文件(可配置可不配置)</span><br><span class="line">[root@manager43 ~]# cat /etc/hosts</span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line"> </span><br><span class="line">192.168.31.43 manager43</span><br><span class="line">192.168.31.188 node188</span><br><span class="line">192.168.31.139 node139</span><br><span class="line"> </span><br><span class="line"># 使用scp复制到node主机</span><br><span class="line">[root@manager43 ~]# scp /etc/hosts root@192.168.31.188:/etc/hosts</span><br><span class="line">[root@manager43 ~]# scp /etc/hosts root@192.168.31.139:/etc/hosts</span><br><span class="line"> </span><br><span class="line">3) 设置防火墙</span><br><span class="line">关闭三台机器上的防火墙。如果开启防火墙，则需要在所有节点的防火墙上依次放行2377/tcp（管理端口）、7946/udp（节点间通信端口）、4789/udp（overlay 网络端口）端口。</span><br><span class="line">[root@manager43 ~]# systemctl disable firewalld.service</span><br><span class="line">[root@manager43 ~]# systemctl stop firewalld.service</span><br><span class="line"> </span><br><span class="line">4) 安装docker并配置加速器(在三台主机都要安装哟...)</span><br><span class="line">[root@manager43 ~]# yum -y install docker</span><br><span class="line">[root@node188 ~]# yum -y install docker</span><br><span class="line">[root@node139 ~]# yum -y install docker</span><br></pre></td></tr></table></figure>

<p>也可以安装最新版docker，可查考：<a href="https://www.cnblogs.com/zhujingzhi/p/9656298.html">docker安装教程</a></p>
<p>加速器配置，可查考:<a href="https://www.cnblogs.com/brianzhu/p/8565411.html">docker加速器配置教程</a></p>
<p>2、创建Swarm并添加节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) 创建Swarm集群</span><br><span class="line">[root@manager43 ~]# docker swarm init --advertise-addr 192.168.31.43</span><br><span class="line">Swarm initialized: current node (z2n633mty5py7u9wyl423qnq0) is now a manager.</span><br><span class="line"> </span><br><span class="line">To add a worker to this swarm, run the following command:</span><br><span class="line"> </span><br><span class="line">    # 这就是添加节点的方式(要保存初始化后token，因为在节点加入时要使用token作为通讯的密钥)</span><br><span class="line">    docker swarm join --token SWMTKN-1-2lefzq18zohy9yr1vskutf1sfb2a590xz9d0mjj2m15zu9eprw-2938j5f50t35ycut0vbj2sx0s 192.168.31.43:2377  </span><br><span class="line"> </span><br><span class="line">To add a manager to this swarm, run &#x27;docker swarm join-token manager&#x27; and follow the instructions.</span><br><span class="line"> </span><br><span class="line">上面命令执行后，该机器自动加入到swarm集群。这个会创建一个集群token，获取全球唯一的 token，作为集群唯一标识。后续将其他节点加入集群都会用到这个token值。</span><br><span class="line">其中，--advertise-addr参数表示其它swarm中的worker节点使用此ip地址与manager联系。命令的输出包含了其它节点如何加入集群的命令。</span><br><span class="line"> </span><br><span class="line">这里无意中遇到了一个小小的问题：</span><br><span class="line"># 在次执行上面的命令，回报下面的错误</span><br><span class="line">[root@manager43 ~]# docker swarm init --advertise-addr 192.168.31.43</span><br><span class="line">Error response from daemon: This node is already part of a swarm. Use &quot;docker swarm leave&quot; to leave this swarm and join another one.</span><br><span class="line"># 解决方法</span><br><span class="line">[root@manager43 ~]# docker swarm leave -f</span><br><span class="line">这里的leave就是在集群中删除节点，-f参数强制删除，执行完在重新执行OK</span><br><span class="line"> </span><br><span class="line">2) 查看集群的相关信息</span><br><span class="line">[root@manager43 ~]# docker info</span><br><span class="line">上面的命令执行后 找到Swarm的关键字，就可以看到相关信息了</span><br><span class="line"> </span><br><span class="line">[root@manager43 ~]# docker node ls</span><br><span class="line">ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION</span><br><span class="line">3jcmnzjh0e99ipgshk1ykuovd *   manager43           Ready               Active              Leader              18.06.0-ce</span><br><span class="line">上面的命令是查看集群中的机器(注意上面node ID旁边那个*号表示现在连接到这个节点上)</span><br><span class="line"> </span><br><span class="line">3) 添加节点主机到Swarm集群</span><br><span class="line">上面我们在创建Swarm集群的时候就已经给出了添加节点的方法</span><br><span class="line"> </span><br><span class="line"># 192.168.31.188 主机上执行</span><br><span class="line">[root@node188 ~]# docker swarm join --token SWMTKN-1-2lefzq18zohy9yr1vskutf1sfb2a590xz9d0mjj2m15zu9eprw-2938j5f50t35ycut0vbj2sx0s 192.168.31.43:2377</span><br><span class="line">This node joined a swarm as a worker.</span><br><span class="line"> </span><br><span class="line"># 192.168.31.139 主机上执行</span><br><span class="line">[root@node139 ~]# docker swarm join --token SWMTKN-1-2lefzq18zohy9yr1vskutf1sfb2a590xz9d0mjj2m15zu9eprw-2938j5f50t35ycut0vbj2sx0s 192.168.31.43:2377</span><br><span class="line">This node joined a swarm as a worker.</span><br><span class="line"> </span><br><span class="line">如果想要将其他更多的节点添加到这个swarm集群中，添加方法如上一致</span><br><span class="line"> </span><br><span class="line">在manager43主机上我们可以看一下集群中的机器及状态</span><br><span class="line">[root@manager43 ~]# docker node ls</span><br><span class="line">ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION</span><br><span class="line">3jcmnzjh0e99ipgshk1ykuovd *   manager43           Ready               Active              Leader              18.06.0-ce</span><br><span class="line">vww7ue2xprzg46bjx7afo4h04     node139             Ready               Active                                  18.06.1-ce</span><br><span class="line">c5klw5ns4adcvumzgiv66xpyj     node188             Ready               Active                                  18.06.1-ce</span><br><span class="line"> </span><br><span class="line">--------------------------------------------------------------------------------------------------------------------</span><br><span class="line">温馨提示：更改节点的availablity状态</span><br><span class="line">swarm集群中node的availability状态可以为 active或者drain，其中：</span><br><span class="line">active状态下，node可以接受来自manager节点的任务分派；</span><br><span class="line">drain状态下，node节点会结束task，且不再接受来自manager节点的任务分派（也就是下线节点）</span><br><span class="line">[root@manager43 ~]# docker node update --availability drain node139               # 将node139节点下线。如果要删除node139节点，命令是&quot;docker node rm --force node139&quot;</span><br><span class="line">node139</span><br><span class="line">[root@manager43 ~]# docker node ls</span><br><span class="line">ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION</span><br><span class="line">3jcmnzjh0e99ipgshk1ykuovd *   manager43           Ready               Active              Leader              18.06.0-ce</span><br><span class="line">vww7ue2xprzg46bjx7afo4h04     node139             Ready               Drain                                   18.06.1-ce</span><br><span class="line">c5klw5ns4adcvumzgiv66xpyj     node188             Ready               Active                                  18.06.1-ce</span><br><span class="line"> </span><br><span class="line">如上，当node1的状态改为drain后，那么该节点就不会接受task任务分发，就算之前已经接受的任务也会转移到别的节点上。</span><br><span class="line">再次修改为active状态（及将下线的节点再次上线）</span><br><span class="line">[root@manager43 ~]# docker node update --availability active node139</span><br><span class="line">node139</span><br><span class="line">[root@manager43 ~]# docker node ls</span><br><span class="line">ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION</span><br><span class="line">3jcmnzjh0e99ipgshk1ykuovd *   manager43           Ready               Active              Leader              18.06.0-ce</span><br><span class="line">vww7ue2xprzg46bjx7afo4h04     node139             Ready               Active                                  18.06.1-ce</span><br><span class="line">c5klw5ns4adcvumzgiv66xpyj     node188             Ready               Active                                  18.06.1-ce</span><br></pre></td></tr></table></figure>

<p>3、在Swarm中部署服务(nginx为例)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Docker 1.12版本提供服务的Scaling、health check、滚动升级等功能，并提供了内置的dns、vip机制，实现service的服务发现和负载均衡能力</span><br><span class="line">1) 创建网络在部署服务</span><br><span class="line"># 创建网络</span><br><span class="line">[root@manager43 ~]# docker network create -d overlay nginx_net</span><br><span class="line">a52jy33asc5o0ts0rq823bf0m</span><br><span class="line">[root@manager43 ~]# docker network ls | grep nginx_net</span><br><span class="line">a52jy33asc5o        nginx_net           overlay             swarm</span><br><span class="line"> </span><br><span class="line"># 部署服务</span><br><span class="line">[root@manager43 ~]# docker service create --replicas 1 --network nginx_net --name my_nginx -p 80:80 nginx    # 就创建了一个具有一个副本（--replicas 1 ）的nginx服务，使用镜像nginx</span><br><span class="line">olexfmtdf94sxyeetkchwhehg</span><br><span class="line">overall progress: 1 out of 1 tasks</span><br><span class="line">1/1: running   [==================================================&gt;]</span><br><span class="line">verify: Service converged</span><br><span class="line">在manager-node节点上使用上面这个覆盖网络创建nginx服务：</span><br><span class="line">其中，--replicas 参数指定服务由几个实例组成。</span><br><span class="line">注意：不需要提前在节点上下载nginx镜像，这个命令执行后会自动下载这个容器镜像（比如此处创建tomcat容器，就将下面命令中的镜像改为tomcat镜像）。</span><br><span class="line"> </span><br><span class="line"># 使用 docker service ls 查看正在运行服务的列表</span><br><span class="line">[root@manager43 ~]# docker service ls</span><br><span class="line">ID                  NAME                MODE                REPLICAS            IMAGE               PORTS</span><br><span class="line">olexfmtdf94s        my_nginx            replicated          1/1                 nginx:latest        *:80-&gt;80/tcp</span><br><span class="line"> </span><br><span class="line">2) 查询Swarm中服务的信息</span><br><span class="line">-pretty 使命令输出格式化为可读的格式，不加 --pretty 可以输出更详细的信息：</span><br><span class="line">[root@manager43 ~]# docker service inspect --pretty my_nginx</span><br><span class="line">ID:             zs7fw4ereo5w7ohd4n9ii06nt</span><br><span class="line">Name:           my_nginx</span><br><span class="line">Service Mode:   Replicated</span><br><span class="line"> Replicas:      1</span><br><span class="line">Placement:</span><br><span class="line">UpdateConfig:</span><br><span class="line"> Parallelism:   1</span><br><span class="line"> On failure:    pause</span><br><span class="line"> Monitoring Period: 5s</span><br><span class="line"> Max failure ratio: 0</span><br><span class="line"> Update order:      stop-first</span><br><span class="line">RollbackConfig:</span><br><span class="line"> Parallelism:   1</span><br><span class="line"> On failure:    pause</span><br><span class="line"> Monitoring Period: 5s</span><br><span class="line"> Max failure ratio: 0</span><br><span class="line"> Rollback order:    stop-first</span><br><span class="line">ContainerSpec:</span><br><span class="line"> Image:         nginx:latest@sha256:b73f527d86e3461fd652f62cf47e7b375196063bbbd503e853af5be16597cb2e</span><br><span class="line"> Init:          false</span><br><span class="line">Resources:</span><br><span class="line">Networks: nginx_net</span><br><span class="line">Endpoint Mode:  vip</span><br><span class="line">Ports:</span><br><span class="line"> PublishedPort = 80</span><br><span class="line">  Protocol = tcp</span><br><span class="line">  TargetPort = 80</span><br><span class="line">  PublishMode = ingress</span><br><span class="line"> </span><br><span class="line"># 查询到哪个节点正在运行该服务。如下该容器被调度到manager-node节点上启动了，然后访问http://192.168.31.43即可访问这个容器应用（如果调度到其他节点，访问也是如此）</span><br><span class="line">[root@manager43 ~]# docker service ps my_nginx</span><br><span class="line">ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE               ERROR               PORTS</span><br><span class="line">yzonph0zu7km        my_nginx.1          nginx:latest        manager43           Running             Running about an hour ago                      </span><br><span class="line">温馨提示：如果上面命令执行后，上面的 STATE 字段中刚开始的服务状态为 Preparing，需要等一会才能变为 Running 状态，其中最费时间的应该是下载镜像的过程</span><br><span class="line"> </span><br><span class="line">有上面命令可知，该服务在manager-node节点上运行。登陆该节点，可以查看到nginx容器在运行中</span><br><span class="line">[root@manager43 ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">0dc7103f8030        nginx:latest        &quot;nginx -g &#x27;daemon of…&quot;   About an hour ago   Up About an hour    80/tcp              my_nginx.1.yzonph0zu7km0211uj0ro5brj</span><br><span class="line"> </span><br><span class="line">3) 在Swarm中动态扩展服务(scale)</span><br><span class="line">当然，如果只是通过service启动容器，swarm也算不上什么新鲜东西了。Service还提供了复制（类似kubernetes里的副本）功能。可以通过 docker service scale 命令来设置服务中容器的副本数</span><br><span class="line">比如将上面的my_nginx容器动态扩展到4个</span><br><span class="line">[root@manager43 ~]# docker service scale my_nginx=4</span><br><span class="line">my_nginx scaled to 4</span><br><span class="line">overall progress: 4 out of 4 tasks</span><br><span class="line">1/4: running   [==================================================&gt;]</span><br><span class="line">2/4: running   [==================================================&gt;]</span><br><span class="line">3/4: running   [==================================================&gt;]</span><br><span class="line">4/4: running   [==================================================&gt;]</span><br><span class="line">verify: Service converged</span><br><span class="line"> </span><br><span class="line">和创建服务一样，增加scale数之后，将会创建新的容器，这些新启动的容器也会经历从准备到运行的过程，过一分钟左右，服务应该就会启动完成，这时候可以再来看一下 nginx 服务中的容器</span><br><span class="line">[root@manager43 ~]# docker service ps my_nginx</span><br><span class="line">ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE               ERROR               PORTS</span><br><span class="line">yzonph0zu7km        my_nginx.1          nginx:latest        manager43           Running             Running about an hour ago                      </span><br><span class="line">mlprstt9ds5x        my_nginx.2          nginx:latest        node139             Running             Running 52 seconds ago                         </span><br><span class="line">y09lk90tdzdp        my_nginx.3          nginx:latest        node139             Running             Running 52 seconds ago                         </span><br><span class="line">clolfl3zlvj0        my_nginx.4          nginx:latest        node188             Running             Running 2 minutes ago  </span><br><span class="line"> </span><br><span class="line">可以看到，之前my_nginx容器只在manager-node节点上有一个实例，而现在又增加了3个实例。</span><br><span class="line">这4个副本的my_nginx容器分别运行在这三个节点上，登陆这三个节点，就会发现已经存在运行着的my_nginx容器</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">4) 模拟宕机node节点</span><br><span class="line">特别需要清楚的一点：</span><br><span class="line">如果一个节点宕机了（即该节点就会从swarm集群中被踢出），则Docker应该会将在该节点运行的容器，调度到其他节点，以满足指定数量的副本保持运行状态。</span><br><span class="line">    </span><br><span class="line">比如：</span><br><span class="line">将node139宕机后或将node139的docker服务关闭，那么它上面的task实例就会转移到别的节点上。当node139节点恢复后，它转移出去的task实例不会主动转移回来，</span><br><span class="line">只能等别的节点出现故障后转移task实例到它的上面。使用命令&quot;docker node ls&quot;，发现node139节点已不在swarm集群中了(状态为：Down)。</span><br><span class="line">[root@node139 ~]# systemctl stop docker</span><br><span class="line">[root@manager43 ~]# docker node ls</span><br><span class="line">ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION</span><br><span class="line">ppk7q0bjond8a58xja7in1qid *   manager43           Ready               Active              Leader              18.06.0-ce</span><br><span class="line">mums8azgbrffnecp3q8fz70pl     node139             Down                Active                                  18.06.1-ce</span><br><span class="line">z3n36maf03yjg7odghikuv574     node188             Ready               Active                                  18.06.1-ce</span><br><span class="line">    </span><br><span class="line">然后过一会查询服务的状态列表</span><br><span class="line">[root@manager43 ~]# docker service ps my_nginx</span><br><span class="line">ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE                ERROR               PORTS</span><br><span class="line">yzonph0zu7km        my_nginx.1          nginx:latest        manager43           Running             Running about an hour ago                       </span><br><span class="line">wb1cpk9k22rl        my_nginx.2          nginx:latest        node188             Running             Running about a minute ago                      </span><br><span class="line">mlprstt9ds5x         \_ my_nginx.2      nginx:latest        node139             Shutdown            Running 4 minutes ago                           </span><br><span class="line">rhbj4bcr4t2c        my_nginx.3          nginx:latest        manager43           Running             Running about a minute ago                      </span><br><span class="line">y09lk90tdzdp         \_ my_nginx.3      nginx:latest        node139             Shutdown            Running 4 minutes ago                           </span><br><span class="line">clolfl3zlvj0        my_nginx.4          nginx:latest        node188             Running             Running 6 minutes ago</span><br><span class="line"> </span><br><span class="line">上面我们可以发现node139故障后，它上面之前的两个task任务已经转移到node188和manager43节点上了</span><br><span class="line"> </span><br><span class="line">登陆到node188和manager43节点上，可以看到这两个运行的task任务。当访问192.168.31.188和192.168.31.43节点的80端口，swarm的负载均衡会把请求路由到一个任意节点的可用的容器上</span><br><span class="line">[root@manager43 ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">ae4c5c2e6f3f        nginx:latest        &quot;nginx -g &#x27;daemon of…&quot;   4 minutes ago       Up 4 minutes        80/tcp              my_nginx.3.rhbj4bcr4t2c3y2f8vyfmbi21</span><br><span class="line">0dc7103f8030        nginx:latest        &quot;nginx -g &#x27;daemon of…&quot;   About an hour ago   Up About an hour    80/tcp              my_nginx.1.yzonph0zu7km0211uj0ro5brj</span><br><span class="line"> </span><br><span class="line">[root@node188 ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">a63ef253f7dd        nginx:latest        &quot;nginx -g &#x27;daemon of…&quot;   3 minutes ago       Up 3 minutes        80/tcp              my_nginx.2.wb1cpk9k22rl1ydab7aozl2b5</span><br><span class="line">74a1a1db81d4        nginx:latest        &quot;nginx -g &#x27;daemon of…&quot;   8 minutes ago       Up 8 minutes        80/tcp              my_nginx.4.clolfl3zlvj0ewmh85c2ljnza</span><br><span class="line"> </span><br><span class="line">再次在node188和manager43节点上将从node139上转移过来的两个task关闭</span><br><span class="line">[root@manager43 ~]# docker stop my_nginx.3.rhbj4bcr4t2c3y2f8vyfmbi21</span><br><span class="line">my_nginx.3.rhbj4bcr4t2c3y2f8vyfmbi21</span><br><span class="line"> </span><br><span class="line">[root@node188 ~]# docker stop my_nginx.2.wb1cpk9k22rl1ydab7aozl2b5</span><br><span class="line">my_nginx.2.wb1cpk9k22rl1ydab7aozl2b5</span><br><span class="line"> </span><br><span class="line">再次查询服务的状态列表，发现这两个task又转移到node139上了</span><br><span class="line">[root@manager43 ~]# docker service ps my_nginx</span><br><span class="line">ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE             ERROR               PORTS</span><br><span class="line">yzonph0zu7km        my_nginx.1          nginx:latest        manager43           Running             Running 2 hours ago                          </span><br><span class="line">j2q61f8jtzba        my_nginx.2          nginx:latest        node188             Running             Running 24 seconds ago                       </span><br><span class="line">wb1cpk9k22rl         \_ my_nginx.2      nginx:latest        node188             Shutdown            Complete 29 seconds ago                      </span><br><span class="line">mlprstt9ds5x         \_ my_nginx.2      nginx:latest        node139             Shutdown            Running 11 minutes ago                       </span><br><span class="line">oz9wyjuldw1t        my_nginx.3          nginx:latest        manager43           Running             Running 40 seconds ago                       </span><br><span class="line">rhbj4bcr4t2c         \_ my_nginx.3      nginx:latest        manager43           Shutdown            Complete 45 seconds ago                      </span><br><span class="line">y09lk90tdzdp         \_ my_nginx.3      nginx:latest        node139             Shutdown            Running 11 minutes ago                       </span><br><span class="line">clolfl3zlvj0        my_nginx.4          nginx:latest        node188             Running             Running 12 minutes ago    </span><br><span class="line">结论：即在swarm cluster集群中启动的容器，在worker node节点上删除或停用后，该容器会自动转移到其他的worker node节点上</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">5) Swarm 动态缩容服务(scale)</span><br><span class="line">同理，swarm还可以缩容，同样是使用scale命令</span><br><span class="line">如下，将my_nginx容器变为1个</span><br><span class="line">[root@manager43 ~]# docker service scale my_nginx=1</span><br><span class="line">my_nginx scaled to 1</span><br><span class="line">overall progress: 1 out of 1 tasks</span><br><span class="line">1/1:  </span><br><span class="line">verify: Service converged</span><br><span class="line"> </span><br><span class="line">[root@manager43 ~]# docker service ls</span><br><span class="line">ID                  NAME                MODE                REPLICAS            IMAGE               PORTS</span><br><span class="line">zs7fw4ereo5w        my_nginx            replicated          1/1                 nginx:latest        *:80-&gt;80/tcp</span><br><span class="line"> </span><br><span class="line">[root@manager43 ~]# docker service ps my_nginx</span><br><span class="line">ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE             ERROR               PORTS</span><br><span class="line">yzonph0zu7km        my_nginx.1          nginx:latest        manager43           Running             Running 11 hours ago                         </span><br><span class="line">wb1cpk9k22rl        my_nginx.2          nginx:latest        node188             Shutdown            Complete 9 hours ago                         </span><br><span class="line">mlprstt9ds5x         \_ my_nginx.2      nginx:latest        node139             Shutdown            Shutdown 29 seconds ago                      </span><br><span class="line">rhbj4bcr4t2c        my_nginx.3          nginx:latest        manager43           Shutdown            Complete 9 hours ago                         </span><br><span class="line">y09lk90tdzdp         \_ my_nginx.3      nginx:latest        node139             Shutdown            Shutdown 29 seconds ago      </span><br><span class="line"> </span><br><span class="line">通过docker service ps my_nginx 可以看到node节点上已经为Shutdown状态了</span><br><span class="line"> </span><br><span class="line">在登录到node节点主机上查看</span><br><span class="line">[root@node188 ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMES</span><br><span class="line">f93c0a27374a        nginx:latest        &quot;nginx -g &#x27;daemon of…&quot;   9 hours ago         Exited (0) 44 seconds ago                       my_nginx.2.j2q61f8jtzba9kb3unupkhl25</span><br><span class="line">a63ef253f7dd        nginx:latest        &quot;nginx -g &#x27;daemon of…&quot;   9 hours ago         Exited (0) 9 hours ago                          my_nginx.2.wb1cpk9k22rl1ydab7aozl2b5</span><br><span class="line">[root@node139 ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                   PORTS               NAMES</span><br><span class="line">e8ac2e44f5c4        nginx:latest        &quot;nginx -g &#x27;daemon of…&quot;   9 hours ago         Exited (0) 9 hours ago                       my_nginx.2.mlprstt9ds5xi48u1rzscgfdk</span><br><span class="line">5b031aa5a2cc        nginx:latest        &quot;nginx -g &#x27;daemon of…&quot;   9 hours ago         Exited (0) 9 hours ago                       my_nginx.3.y09lk90tdzdp8cwj6mm5oyr3f</span><br><span class="line">登录node节点，使用docker ps -a 查看，会发现容器被stop而非rm</span><br><span class="line"> </span><br><span class="line">6) 除了上面使用scale进行容器的扩容或缩容之外，还可以使用docker service update 命令。 可对 服务的启动 参数 进行 更新/修改。</span><br><span class="line">[root@manager43 ~]# docker service update --replicas 3 my_nginx</span><br><span class="line">my_nginx</span><br><span class="line">overall progress: 3 out of 3 tasks</span><br><span class="line">1/3: running   [==================================================&gt;]</span><br><span class="line">2/3: running   [==================================================&gt;]</span><br><span class="line">3/3: running   [==================================================&gt;]</span><br><span class="line">verify: Service converged</span><br><span class="line"> </span><br><span class="line">[root@manager43 ~]# docker service ls</span><br><span class="line">ID                  NAME                MODE                REPLICAS            IMAGE               PORTS</span><br><span class="line">zs7fw4ereo5w        my_nginx            replicated          3/3                 nginx:latest        *:80-&gt;80/tcp</span><br><span class="line"> </span><br><span class="line">[root@manager43 ~]# docker service ps my_nginx</span><br><span class="line">ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE            ERROR               PORTS</span><br><span class="line">yzonph0zu7km        my_nginx.1          nginx:latest        manager43           Running             Running 11 hours ago                        </span><br><span class="line">j3hduzd9pret        my_nginx.2          nginx:latest        node188             Running             Running 18 seconds ago                      </span><br><span class="line">wb1cpk9k22rl         \_ my_nginx.2      nginx:latest        node188             Shutdown            Complete 9 hours ago                        </span><br><span class="line">mlprstt9ds5x         \_ my_nginx.2      nginx:latest        node139             Shutdown            Shutdown 4 minutes ago                      </span><br><span class="line">gng96vc5vqpv        my_nginx.3          nginx:latest        node139             Running             Running 18 seconds ago                      </span><br><span class="line">rhbj4bcr4t2c         \_ my_nginx.3      nginx:latest        manager43           Shutdown            Complete 9 hours ago                        </span><br><span class="line">y09lk90tdzdp         \_ my_nginx.3      nginx:latest        node139             Shutdown            Shutdown 4 minutes ago    </span><br><span class="line"> </span><br><span class="line">docker service update 命令，也可用于直接 升级 镜像等</span><br><span class="line">[root@manager43 ~]# docker service update --image nginx:new my_nginx</span><br><span class="line"> </span><br><span class="line">[root@manager43 ~]# docker service ls</span><br><span class="line">ID                  NAME                MODE                REPLICAS            IMAGE               PORTS</span><br><span class="line">zs7fw4ereo5w        my_nginx            replicated          3/3                 nginx:new           *:80-&gt;80/tcp</span><br><span class="line">注意IMAGE列 变成了nginx:new</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">7) 为了下面的直观显示，我这里把my_nginx服务直接删除了</span><br><span class="line">[root@manager43 ~]# docker service rm my_nginx</span><br><span class="line"> </span><br><span class="line">这样就会把所有节点上的所有容器（task任务实例）全部删除了</span><br></pre></td></tr></table></figure>

<p>4、Swarm中使用Volume(挂在目录，mount命令)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) 查看volume的帮助信息</span><br><span class="line">[root@manager43 ~]# docker volume --help</span><br><span class="line"> </span><br><span class="line">Usage:  docker volume COMMAND</span><br><span class="line"> </span><br><span class="line">Manage volumes</span><br><span class="line"> </span><br><span class="line">Commands:</span><br><span class="line">  create      Create a volume</span><br><span class="line">  inspect     Display detailed information on one or more volumes</span><br><span class="line">  ls          List volumes</span><br><span class="line">  prune       Remove all unused local volumes</span><br><span class="line">  rm          Remove one or more volumes</span><br><span class="line"> </span><br><span class="line">Run &#x27;docker volume COMMAND --help&#x27; for more information on a command.</span><br><span class="line"> </span><br><span class="line">2) 创建一个volume</span><br><span class="line">[root@manager43 ~]# docker volume create --name testvolume</span><br><span class="line">testvolume</span><br><span class="line"> </span><br><span class="line"># 查看创建的volume</span><br><span class="line">[root@manager43 ~]# docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               testvolume</span><br><span class="line"> </span><br><span class="line"># 查看volume详情</span><br><span class="line">[root@manager43 ~]# docker volume inspect testvolume</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2018-10-21T10:50:02+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/testvolume/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;testvolume&quot;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">3) 创建新的服务并挂载testvolume(nginx为例)</span><br><span class="line">[root@manager43 ~]# docker service create --replicas 3 --mount type=volume,src=testvolume,dst=/zjz --name test_nginx nginx</span><br><span class="line">sh7wc8yzcvr0xaedo4tnraj7l</span><br><span class="line">overall progress: 3 out of 3 tasks</span><br><span class="line">1/3: running   [==================================================&gt;]</span><br><span class="line">2/3: running   [==================================================&gt;]</span><br><span class="line">3/3: running   [==================================================&gt;]</span><br><span class="line">verify: Service converged</span><br><span class="line"> </span><br><span class="line">温馨提示：</span><br><span class="line">参数src写成source也可以；dst表示容器内的路径，也可以写成target</span><br><span class="line"> </span><br><span class="line"># 查看创建服务</span><br><span class="line">[root@manager43 ~]# docker service ls</span><br><span class="line">ID                  NAME                MODE                REPLICAS            IMAGE               PORTS</span><br><span class="line">sh7wc8yzcvr0        test_nginx          replicated          3/3                 nginx:latest       </span><br><span class="line">[root@manager43 ~]# docker service ps test_nginx</span><br><span class="line">ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE            ERROR               PORTS</span><br><span class="line">m7m41kwt4q6w        test_nginx.1        nginx:latest        node188             Running             Running 56 seconds ago                      </span><br><span class="line">kayh81q1o1kx        test_nginx.2        nginx:latest        node139             Running             Running 56 seconds ago                      </span><br><span class="line">eq11v0rcwy38        test_nginx.3        nginx:latest        manager43           Running             Running 56 seconds ago           </span><br><span class="line"> </span><br><span class="line"># 查看有没有挂载成功(登录各个节点的容器看看有没有指定的目录并创建文件测试)</span><br><span class="line"># 容器中操作</span><br><span class="line">[root@manager43 ~]# docker exec -it 63451219cb4e /bin/bash</span><br><span class="line">root@63451219cb4e:/# cd /zjz/</span><br><span class="line">root@63451219cb4e:/zjz# ls</span><br><span class="line">root@63451219cb4e:/zjz# echo &quot;gen wo xue docker&quot; &gt; docker.txt</span><br><span class="line">root@63451219cb4e:/zjz# ls</span><br><span class="line">docker.txt</span><br><span class="line"> </span><br><span class="line">执行docker volume inspect testvolume 可以看到本地的路径(上面已经执行过了)</span><br><span class="line">本地路径：/var/lib/docker/volumes/testvolume/_data</span><br><span class="line">[root@manager43 ~]# cd /var/lib/docker/volumes/testvolume/_data</span><br><span class="line">[root@manager43 _data]# ls</span><br><span class="line">docker.txt</span><br><span class="line">[root@manager43 _data]# cat docker.txt</span><br><span class="line">gen wo xue docker</span><br><span class="line"> </span><br><span class="line">还可以将node节点机上的volume数据目录做成软链接</span><br><span class="line">[root@manager43 _data]# ln -s /var/lib/docker/volumes/testvolume/_data /zjz</span><br><span class="line">[root@manager43 _data]# cd /zjz/</span><br><span class="line">[root@manager43 zjz]# ls</span><br><span class="line">docker.txt</span><br><span class="line">[root@manager43 zjz]# echo &quot;123&quot; &gt; 1.txt  </span><br><span class="line">[root@manager43 zjz]# ll</span><br><span class="line">总用量 8</span><br><span class="line">-rw-r--r-- 1 root root  4 10月 21 11:04 1.txt</span><br><span class="line">-rw-r--r-- 1 root root 18 10月 21 11:00 docker.txt</span><br><span class="line"> </span><br><span class="line"># 容器中查看</span><br><span class="line">[root@manager43 zjz]# docker exec -it 63451219cb4e /bin/bash</span><br><span class="line">root@63451219cb4e:/# cd /zjz/</span><br><span class="line">root@63451219cb4e:/zjz# ls</span><br><span class="line">1.txt  docker.txt</span><br><span class="line">root@63451219cb4e:/zjz# cat 1.txt</span><br><span class="line">123</span><br><span class="line">root@63451219cb4e:/zjz# cat docker.txt</span><br><span class="line">gen wo xue docker</span><br><span class="line"> </span><br><span class="line"># 还有一种挂载方式简单说一下吧，上面的会了下面的肯定简单</span><br><span class="line">命令格式：</span><br><span class="line">docker service create --mount type=bind,target=/container_data/,source=/host_data/</span><br><span class="line">其中，参数target表示容器里面的路径，source表示本地硬盘路径</span><br><span class="line"> </span><br><span class="line"># 示例创建并挂载并使用网络</span><br><span class="line">[root@manager43 ~]# docker service create --replicas 1 --mount type=bind,target=/usr/share/nginx/html/,source=/opt/web/ --network nginx_net --name zjz_nginx -p 8880:80 nginx</span><br></pre></td></tr></table></figure>

<p>5、多服务Swarm集群部署</p>
<p>问：上面我们只是对单独的一个nginx服务进行的集群部署，那如果要统一编排多个服务呢？<br>答：docker 三剑客中有个compose 这个就是对单机进行统一编排的，它的实现是通过docker-compose.yml的文件，这里我们就可以结合compose和swarm进行多服务的编排(<a href="https://www.cnblogs.com/zhujingzhi/p/9786622.html">docker compose教程</a>)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">温馨提示：</span><br><span class="line">我们这里要部署的服务有三个(nginx服务，visualizer服务，portainer服务) 都是集群 GUI 管理服务</span><br><span class="line">docker service部署的是单个服务，我们可以使用docker stack进行多服务编排部署</span><br><span class="line"> </span><br><span class="line">1) 编写docker-compose.yml文件</span><br><span class="line">[root@manager43 ~]# mkdir testswarm</span><br><span class="line">[root@manager43 ~]# cd testswarm/</span><br><span class="line">[root@manager43 testswarm]# cat docker-compose.yml</span><br><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  nginx:</span><br><span class="line">    image: nginx</span><br><span class="line">    ports:</span><br><span class="line">      - 8888:80</span><br><span class="line">    deploy:</span><br><span class="line">      mode: replicated</span><br><span class="line">      replocas: 3</span><br><span class="line"> </span><br><span class="line">  visualizer:</span><br><span class="line">    image: dockersamples/visualizer</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 1</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line"> </span><br><span class="line">  portainer:</span><br><span class="line">    image: portainer/portainer</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;9000:9000&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 1</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line"> </span><br><span class="line">2) 通过这个yml文件部署服务</span><br><span class="line">[root@manager43 testswarm]# docker stack deploy -c docker-compose.yml deploy_deamon</span><br><span class="line">Creating network deploy_deamon_default</span><br><span class="line">Creating service deploy_deamon_portainer</span><br><span class="line">Creating service deploy_deamon_nginx</span><br><span class="line">Creating service deploy_deamon_visualizer</span><br><span class="line"> </span><br><span class="line">通过上面的执行过程可以看出这样创建会默认创建一个网络并使用它，名字都是我们给的名字的前缀加上服务名</span><br><span class="line"> </span><br><span class="line"># 查看创建服务</span><br><span class="line">[root@manager43 testswarm]# docker service ls</span><br><span class="line">ID                  NAME                       MODE                REPLICAS            IMAGE                             PORTS</span><br><span class="line">xj2f1t5ax3nm        deploy_deamon_nginx        replicated          3/3                 nginx:latest                      *:8888-&gt;80/tcp</span><br><span class="line">ky9qpldr5abb        deploy_deamon_portainer    replicated          1/1                 portainer/portainer:latest        *:9000-&gt;9000/tcp</span><br><span class="line">r47ff177x1ir        deploy_deamon_visualizer   replicated          1/1                 dockersamples/visualizer:latest   *:8080-&gt;8080/tcp</span><br><span class="line"> </span><br><span class="line">[root@manager43 testswarm]# docker service ps deploy_deamon_nginx</span><br><span class="line">ID                  NAME                    IMAGE               NODE                DESIRED STATE       CURRENT STATE                ERROR               PORTS</span><br><span class="line">z3v4uc1ujsnq        deploy_deamon_nginx.1   nginx:latest        node139             Running             Running about a minute ago                      </span><br><span class="line">jhg3ups0cko5        deploy_deamon_nginx.2   nginx:latest        manager43           Running             Running about a minute ago                      </span><br><span class="line">3e6guv791x21        deploy_deamon_nginx.3   nginx:latest        node188             Running             Running about a minute ago        </span><br><span class="line"> </span><br><span class="line">[root@manager43 testswarm]# docker service ps deploy_deamon_portainer</span><br><span class="line">ID                  NAME                        IMAGE                        NODE                DESIRED STATE       CURRENT STATE                ERROR               PORTS</span><br><span class="line">whyuvy82cvvw        deploy_deamon_portainer.1   portainer/portainer:latest   manager43           Running             Running about a minute ago                      </span><br><span class="line"> </span><br><span class="line">[root@manager43 testswarm]# docker service ps deploy_deamon_visualizer</span><br><span class="line">ID                  NAME                         IMAGE                             NODE                DESIRED STATE       CURRENT STATE            ERROR               PORTS</span><br><span class="line">wge5w1eqykg3        deploy_deamon_visualizer.1   dockersamples/visualizer:latest   manager43           Running             Starting 7 seconds ago                     </span><br></pre></td></tr></table></figure>

<p>测试</p>
<p><img src="/images/docker-swarm/docker-swarm-7.png" alt="img"></p>
<p><img src="/images/docker-swarm/docker-swarm-8.png" alt="img"></p>
<p><img src="/images/docker-swarm/docker-swarm-9.png" alt="img"></p>
<p><img src="/images/docker-swarm/docker-swarm-10.png" alt="img"></p>
<p><img src="/images/docker-swarm/docker-swarm-11.png" alt="img"></p>
<h2 id="八、Docker-Swarm-容器网络"><a href="#八、Docker-Swarm-容器网络" class="headerlink" title="八、Docker Swarm 容器网络"></a>八、Docker Swarm 容器网络</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在Docker版本1.12之后swarm模式原生支持覆盖网络(overlay networks)，可以先创建一个覆盖网络，然后启动容器的时候启用这个覆盖网络，</span><br><span class="line">这样只要是这个覆盖网络内的容器，不管在不在同一个宿主机上都能相互通信，即跨主机通信！不同覆盖网络内的容器组之间是相互隔离的（相互ping不通）。</span><br><span class="line">   </span><br><span class="line">swarm模式的覆盖网络包括以下功能：</span><br><span class="line">1）可以附加多个服务到同一个网络。</span><br><span class="line">2）默认情况下，service discovery为每个swarm服务分配一个虚拟IP地址(vip)和DNS名称，使得在同一个网络中容器之间可以使用服务名称为互相连接。</span><br><span class="line">3）可以配置使用DNS轮循而不使用VIP</span><br><span class="line">4）为了可以使用swarm的覆盖网络，在启用swarm模式之间你需要在swarm节点之间开放以下端口：</span><br><span class="line">5）TCP/UDP端口7946 – 用于容器网络发现</span><br><span class="line">6）UDP端口4789 – 用于容器覆盖网络</span><br><span class="line">   </span><br><span class="line">实例如下：</span><br><span class="line">-----------在Swarm集群中创建overlay网络------------</span><br><span class="line">[root@manager-node ~]# docker network create --driver overlay --opt encrypted --subnet 10.10.19.0/24 ngx_net</span><br><span class="line">   </span><br><span class="line">参数解释：</span><br><span class="line">–opt encrypted  默认情况下swarm中的节点通信是加密的。在不同节点的容器之间，可选的–opt encrypted参数能在它们的vxlan流量启用附加的加密层。</span><br><span class="line">--subnet 命令行参数指定overlay网络使用的子网网段。当不指定一个子网时，swarm管理器自动选择一个子网并分配给网络。</span><br><span class="line">   </span><br><span class="line">[root@manager-node ~]# docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">d7aa48d3e485        bridge              bridge              local            </span><br><span class="line">9e637a97a3b9        docker_gwbridge     bridge              local            </span><br><span class="line">b5a41c8c71e7        host                host                local            </span><br><span class="line">7f4fx3jf4dbr        ingress             overlay             swarm            </span><br><span class="line">3x2wgugr6zmn        ngx_net             overlay             swarm            </span><br><span class="line">0808a5c72a0a        none                null                local</span><br><span class="line">   </span><br><span class="line">由上可知，Swarm当中拥有2套覆盖网络。其中&quot;ngx_net&quot;网络正是我们在部署容器时所创建的成果。而&quot;ingress&quot;覆盖网络则为默认提供。</span><br><span class="line">Swarm 管理节点会利用 ingress 负载均衡以将服务公布至集群之外。</span><br><span class="line">在将服务连接到这个创建的网络之前，网络覆盖到manager节点。上面输出的SCOPE为 swarm 表示将服务部署到Swarm时可以使用此网络。</span><br><span class="line">在将服务连接到这个网络后，Swarm只将该网络扩展到特定的worker节点，这个worker节点被swarm调度器分配了运行服务的任务。</span><br><span class="line">在那些没有运行该服务任务的worker节点上，网络并不扩展到该节点。</span><br><span class="line">   </span><br><span class="line">------------------将服务连接到overlay网络-------------------</span><br><span class="line">[root@manager-node ~]# docker service create --replicas 5 --network ngx_net --name my-test -p 80:80 nginx</span><br><span class="line">   </span><br><span class="line">上面名为&quot;my-test&quot;的服务启动了3个task，用于运行每个任务的容器都可以彼此通过overlay网络进行通信。Swarm集群将网络扩展到所有任务处于Running状态的节点上。</span><br><span class="line">[root@manager-node ~]# docker service ls</span><br><span class="line">ID            NAME     REPLICAS  IMAGE  COMMAND</span><br><span class="line">dsaxs6v463g9  my-test  5/5       nginx</span><br><span class="line">   </span><br><span class="line">在manager-node节点上，通过下面的命令查看哪些节点有处于running状态的任务：</span><br><span class="line">[root@manager-node ~]# docker service ps my-test</span><br><span class="line">ID                         NAME       IMAGE  NODE          DESIRED STATE  CURRENT STATE          ERROR</span><br><span class="line">8433fuiy7vpu0p80arl7vggfe  my-test.1  nginx  node2         Running        Running 2 minutes ago</span><br><span class="line">f1h7a0vtojv18zrsiw8j0rzaw  my-test.2  nginx  node1         Running        Running 2 minutes ago</span><br><span class="line">ex73ifk3jvzw8ukurl8yu7fyq  my-test.3  nginx  node1         Running        Running 2 minutes ago</span><br><span class="line">cyu73jd8psupfhken23vvmpud  my-test.4  nginx  manager-node  Running        Running 2 minutes ago</span><br><span class="line">btorxekfix4hcqh4v83dr0tzw  my-test.5  nginx  manager-node  Running        Running 2 minutes ago</span><br><span class="line">   </span><br><span class="line">可见三个节点都有处于running状态的任务，所以my-network网络扩展到三个节点上。</span><br><span class="line">   </span><br><span class="line">可以查询某个节点上关于my-network的详细信息：</span><br><span class="line">[root@manager-node ~]# docker network inspect ngx_net</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;ngx_net&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;3x2wgugr6zmn1mcyf9k1du27p&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;swarm&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;overlay&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: null,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;10.10.19.0/24&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;10.10.19.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;00f47e38deea76269eb03ba13695ec0b0c740601c85019546d6a9a17fd434663&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;my-test.5.btorxekfix4hcqh4v83dr0tzw&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;ea962d07eee150b263ae631b8a7f8c1950337c11ef2c3d488a7c3717defd8601&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:0a:0a:13:03&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;10.10.19.3/24&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;957620c6f7abb44ad8dd2d842d333f5e5c1655034dc43e49abbbd680de3a5341&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;my-test.4.cyu73jd8psupfhken23vvmpud&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;f33a6e9ddf1dd01bcfc43ffefd19e19514658f001cdf9b2fbe23bc3fdf56a42a&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:0a:0a:13:07&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;10.10.19.7/24&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;</span><br><span class="line">            &quot;com.docker.network.driver.overlay.vxlanid_list&quot;: &quot;257&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">   </span><br><span class="line">从上面的信息可以看出在manager-node节点上，名为my-test的服务有一个名为my-test.5.btorxekfix4hcqh4v83dr0tzw和</span><br><span class="line">my-test.4.cyu73jd8psupfhken23vvmpud的task连接到名为ngx_net的网络上（另外两个节点node1和node2同样可以用上面命令查看）</span><br><span class="line">[root@node1 ~]# docker network inspect ngx_net</span><br><span class="line">.......</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;7d9986fad5a7d834676ba76ae75aff2258f840953f1dc633c3ef3c0efd2b2501&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;my-test.3.ex73ifk3jvzw8ukurl8yu7fyq&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;957ca19f3d5480762dbd14fd9a6a1cd01a8deac3e8e35b23d1350f480a7b2f37&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:0a:0a:13:06&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;10.10.19.6/24&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;9e50fceada1d7c653a886ca29d2bf2606debafe8c8a97f2d79104faf3ecf8a46&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;my-test.2.f1h7a0vtojv18zrsiw8j0rzaw&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;b1c209c7b68634e88e0bf5e100fe03435b3096054da6555c61e6c207ac651ac2&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:0a:0a:13:05&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;10.10.19.5/24&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">.........</span><br><span class="line">  </span><br><span class="line">[root@node2 web]# docker network inspect ngx_net</span><br><span class="line">........</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;4bdcce0ee63edc08d943cf4a049eac027719ff2dc14b7c3aa85fdddc5d1da968&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;my-test.1.8433fuiy7vpu0p80arl7vggfe&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;df58de85b0a0e4d128bf332fc783f6528d1f179b0f9f3b7aa70ebc832640d3bc&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:0a:0a:13:04&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;10.10.19.4/24&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">   </span><br><span class="line">可以通过查询服务来获得服务的虚拟IP地址，如下：</span><br><span class="line">[root@manager-node ~]# docker service inspect --format=&#x27;&#123;&#123;json .Endpoint.VirtualIPs&#125;&#125;&#x27; my-test</span><br><span class="line">[&#123;&quot;NetworkID&quot;:&quot;7f4fx3jf4dbrp97aioc05pul4&quot;,&quot;Addr&quot;:&quot;10.255.0.6/16&quot;&#125;,&#123;&quot;NetworkID&quot;:&quot;3x2wgugr6zmn1mcyf9k1du27p&quot;,&quot;Addr&quot;:&quot;10.10.19.2/24&quot;&#125;]</span><br><span class="line">   </span><br><span class="line">由上结果可知，10.10.19.2其实就是swarm集群内部的vip，整个网络结构如下图所示：</span><br></pre></td></tr></table></figure>

<p>　<img src="/images/docker-swarm/docker-swarm-12.png" alt="img"></p>
<p>加入ngx_net网络的容器彼此之间可以通过IP地址通信，也可以通过名称通信。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@node2 ~]# docker ps</span><br><span class="line">CONTAINER ID    IMAGE           COMMAND                  CREATED         STATUS             PORTS    NAMES</span><br><span class="line">4bdcce0ee63e    nginx:latest    &quot;nginx -g &#x27;daemon off&quot;   22 minutes ago  Up 22 minutes      80/tcp   my-test.1.8433fuiy7vpu0p80arl7vggfe</span><br><span class="line">  </span><br><span class="line">[root@node2 ~]# docker exec -ti 4bdcce0ee63e /bin/bash</span><br><span class="line">root@4bdcce0ee63e:/# ip addr                                                                                          </span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">1786: eth0@if1787: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP group default</span><br><span class="line">    link/ether 02:42:0a:ff:00:08 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 10.255.0.8/16 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet 10.255.0.6/32 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:aff:feff:8/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">1788: eth1@if1789: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether 02:42:ac:12:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line">    inet 172.18.0.3/16 scope global eth1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:acff:fe12:3/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">1791: eth2@if1792: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP group default</span><br><span class="line">    link/ether 02:42:0a:0a:13:04 brd ff:ff:ff:ff:ff:ff link-netnsid 2</span><br><span class="line">    inet 10.10.19.4/24 scope global eth2</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet 10.10.19.2/32 scope global eth2</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:aff:fe0a:1304/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">  </span><br><span class="line">root@4bdcce0ee63e:/# ping 10.10.19.3</span><br><span class="line">PING 10.10.19.3 (10.10.19.3): 56 data bytes</span><br><span class="line">64 bytes from 10.10.19.3: icmp_seq=0 ttl=64 time=0.890 ms</span><br><span class="line">64 bytes from 10.10.19.3: icmp_seq=1 ttl=64 time=0.622 ms</span><br><span class="line">.....-</span><br><span class="line">2 packets transmitted, 2 packets received, 0% packet loss</span><br><span class="line">round-trip min/avg/max/stddev = 0.622/0.756/0.890/0.134 ms</span><br><span class="line">  </span><br><span class="line">root@4bdcce0ee63e:/# ping 10.10.19.6</span><br><span class="line">PING 10.10.19.6 (10.10.19.6): 56 data bytes</span><br><span class="line">64 bytes from 10.10.19.6: icmp_seq=0 ttl=64 time=0.939 ms</span><br><span class="line">64 bytes from 10.10.19.6: icmp_seq=1 ttl=64 time=0.590 ms</span><br><span class="line">  </span><br><span class="line">----------------------------使用swarm模式的服务发现--------------------------</span><br><span class="line">默认情况下，当创建了一个服务并连接到某个网络后，swarm会为该服务分配一个VIP。此VIP根据服务名映射到DNS。在网络上的容器共享该服务的DNS映射，</span><br><span class="line">所以网络上的任意容器可以通过服务名访问服务。</span><br><span class="line">  </span><br><span class="line">在同一overlay网络中，不用通过端口映射来使某个服务可以被其它服务访问。Swarm内部的负载均衡器自动将请求发送到服务的VIP上，然后分发到所有的</span><br><span class="line">active的task上。</span><br><span class="line">  </span><br><span class="line">如下示例：</span><br><span class="line">在同一个网络中添加了一个centos服务，此服务可以通过名称my-test访问前面创建的nginx服务：</span><br><span class="line">[root@manager-node ~]# docker service create --name my-centos --network ngx_net centos       </span><br><span class="line">  </span><br><span class="line">查询centos运行在哪个节点上（上面创建命令执行后，需要一段时间才能完成这个centos服务的创建）</span><br><span class="line">[root@manager-node ~]# docker service ps my-centos</span><br><span class="line">ID                         NAME             IMAGE   NODE   DESIRED STATE  CURRENT STATE            ERROR</span><br><span class="line">e03pqgkjs3l1qizc6v4aqaune  my-centos.1      centos  node2  Running        Preparing 4 seconds ago</span><br><span class="line">  </span><br><span class="line">登录centos运行的节点（由上可知是node2节点），打开centos的交互shell：</span><br><span class="line">[root@node2 ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE                    COMMAND                  CREATED             STATUS            NAMES</span><br><span class="line">e4554490d891        centos:latest            &quot;/bin/bash&quot;             About an hour ago   Up About an hour   my-centos.1.9yk5ie28gwk9mw1h1jovb68ki</span><br><span class="line">  </span><br><span class="line">[root@node2 ~]# docker exec -ti my-centos.1.9yk5ie28gwk9mw1h1jovb68ki /bin/bash</span><br><span class="line">root@4bdcce0ee63e:/# nslookup my-test</span><br><span class="line">Server: 127.0.0.11</span><br><span class="line">Address 1: 127.0.0.11</span><br><span class="line">  </span><br><span class="line">Name: my-test</span><br><span class="line">Address 1: 10.10.19.2 10.10.19.2</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">从centos容器内部，使用特殊查询 查询DNS，来找到my-test服务的所有容器的IP地址：</span><br><span class="line">root@4bdcce0ee63e:/# nslookup tasks.my-test</span><br><span class="line">Server: 127.0.0.11</span><br><span class="line">Address 1: 127.0.0.11</span><br><span class="line">  </span><br><span class="line">Name: tasks.my-test</span><br><span class="line">Address 1: 10.10.19.4 my-test.1.8433fuiy7vpu0p80arl7vggfe</span><br><span class="line">Address 2: 10.10.19.5 my-test.2.f1h7a0vtojv18zrsiw8j0rzaw</span><br><span class="line">Address 3: 10.10.19.6 my-test.3.ex73ifk3jvzw8ukurl8yu7fyq</span><br><span class="line">Address 2: 10.10.19.7 my-test.4.cyu73jd8psupfhken23vvmpud</span><br><span class="line">Address 3: 10.10.19.3 my-test.5.btorxekfix4hcqh4v83dr0tzw</span><br><span class="line">  </span><br><span class="line">从centos容器内部，通过wget来访问my-test服务中运行的nginx网页服务器</span><br><span class="line">root@4bdcce0ee63e:/# wget -O- my-test     </span><br><span class="line">Connecting to my-test (10.10.19.2:80)</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line">Swarm的负载均衡器自动将HTTP请求路由到VIP上，然后到一个active的task容器上。它根据round-robin选择算法将后续的请求分发到另一个active的task上。</span><br><span class="line">  </span><br><span class="line">-----------------------------------为服务使用DNS round-robin-----------------------------</span><br><span class="line">在创建服务时，可以配置服务直接使用DNS round-robin而无需使用VIP。这是通过在创建服务时指定 --endpoint-mode dnsrr 命令行参数实现的。</span><br><span class="line">当你想要使用自己的负载均衡器时可以使用这种方式。</span><br><span class="line">  </span><br><span class="line">如下示例（注意：使用DNS round-robin方式创建服务，不能直接在命令里使用-p指定端口）</span><br><span class="line">[root@manager-node ~]# docker service create --replicas 3 --name my-dnsrr-nginx --network ngx_net --endpoint-mode dnsrr nginx</span><br><span class="line">  </span><br><span class="line">[root@manager-node ~]# docker service ps my-dnsrr-nginx</span><br><span class="line">ID                         NAME              IMAGE  NODE          DESIRED STATE  CURRENT STATE          ERROR</span><br><span class="line">65li2zbhxvvoaesndmwjokouj  my-dnsrr-nginx.1  nginx  node1         Running        Running 2 minutes ago</span><br><span class="line">5hjw7wm4xr877879m0ewjciuj  my-dnsrr-nginx.2  nginx  manager-node  Running        Running 2 minutes ago</span><br><span class="line">afo7acduge2qfy60e87liz557  my-dnsrr-nginx.3  nginx  manager-node  Running        Running 2 minutes ago</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">当通过服务名称查询DNS时，DNS服务返回所有任务容器的IP地址：</span><br><span class="line">root@4bdcce0ee63e:/# nslookup my-dnsrr-nginx</span><br><span class="line">Server:    127.0.0.11</span><br><span class="line">Address 1: 127.0.0.11</span><br><span class="line">  </span><br><span class="line">Name:      my-dnsrr-nginx</span><br><span class="line">Address 1: 10.10.19.10 my-dnsrr-nginx.3.0sm1n9o8hygzarv5t5eq46okn.my-network</span><br><span class="line">Address 2: 10.10.19.9  my-dnsrr-nginx.2.b3o1uoa8m003b2kk0ytl9lawh.my-network</span><br><span class="line">Address 3: 10.10.19.8  my-dnsrr-nginx.1.55za4c83jq9846rle6eigiq15.my-network</span><br><span class="line">  </span><br><span class="line">需要注意的是：一定要确认VIP的连通性</span><br><span class="line">通常Docker官方推荐使用dig，nslookup或其它DNS查询工具来查询通过DNS对服务名的访问。因为VIP是逻辑IP，ping并不是确认VIP连通性的正确的工具。</span><br></pre></td></tr></table></figure>



<p>来源：<a href="https://www.cnblogs.com/zhujingzhi/p/9792432.html">https://www.cnblogs.com/zhujingzhi/p/9792432.html</a></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>docker swarm</tag>
        <tag>docker 集群</tag>
      </tags>
  </entry>
  <entry>
    <title>git ssh 生成</title>
    <url>/2021/05/07/git/git-ssh-generate/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -o</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (directory/id_rsa):</span><br><span class="line">Created directory &#x27;directory&#x27;.</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in directory/id_rsa.</span><br><span class="line">Your public key has been saved in directory/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">xxx</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>git 远程仓库使用</title>
    <url>/2021/05/07/git/git-remote/</url>
    <content><![CDATA[<h2 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h2><p>为了能在任意 Git 项目上协作，你需要知道如何管理自己的远程仓库。 远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。 管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。 在本节中，我们将介绍一部分远程管理的技能。</p>
<p><strong>Node:</strong></p>
<p><strong>远程仓库可以在你的本地主机上你完全可以在一个“远程”仓库上工作，而实际上它在你本地的主机上。 词语“远程”未必表示仓库在网络或互联网上的其它位置，而只是表示它在别处。 在这样的远程仓库上工作，仍然需要和其它远程仓库上一样的标准推送、拉取和抓取操作。</strong></p>
<h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><p>如果想查看你已经配置的远程仓库服务器，可以运行 <code>git remote</code> 命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin ——这是 Git 给你克隆的仓库服务器的默认名字：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/schacon/ticgit</span></span><br><span class="line">Cloning into &#x27;ticgit&#x27;...</span><br><span class="line">remote: Reusing existing pack: 1857, done.</span><br><span class="line">remote: Total 1857 (delta 0), reused 0 (delta 0)</span><br><span class="line">Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (772/772), done.</span><br><span class="line">Checking connectivity... done.</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ticgit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br></pre></td></tr></table></figure>

<p>你也可以指定选项 <code>-v</code>，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">origin	https://github.com/schacon/ticgit (fetch)</span><br><span class="line">origin	https://github.com/schacon/ticgit (push)</span><br></pre></td></tr></table></figure>

<p>如果你的远程仓库不止一个，该命令会将它们全部列出。 例如，与几个协作者合作的，拥有多个远程仓库的仓库看起来像下面这样：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> grit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">bakkdoor  https://github.com/bakkdoor/grit (fetch)</span><br><span class="line">bakkdoor  https://github.com/bakkdoor/grit (push)</span><br><span class="line">cho45     https://github.com/cho45/grit (fetch)</span><br><span class="line">cho45     https://github.com/cho45/grit (push)</span><br><span class="line">defunkt   https://github.com/defunkt/grit (fetch)</span><br><span class="line">defunkt   https://github.com/defunkt/grit (push)</span><br><span class="line">koke      git://github.com/koke/grit.git (fetch)</span><br><span class="line">koke      git://github.com/koke/grit.git (push)</span><br><span class="line">origin    git@github.com:mojombo/grit.git (fetch)</span><br><span class="line">origin    git@github.com:mojombo/grit.git (push)</span><br></pre></td></tr></table></figure>

<p>这表示我们能非常方便地拉取其它用户的贡献。我们还可以拥有向他们推送的权限，这里暂不详述。</p>
<p>注意这些远程仓库使用了不同的协议。我们将会在 <a href="https://git-scm.com/book/zh/v2/ch00/_getting_git_on_a_server">在服务器上搭建 Git</a> 中了解关于它们的更多信息。</p>
<h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>我们在之前的章节中已经提到并展示了 <code>git clone</code> 命令是如何自行添加远程仓库的， 不过这里将告诉你如何自己来添加它。 运行 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加一个新的远程 Git 仓库，同时指定一个方便使用的简写：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add pb https://github.com/paulboone/ticgit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">origin	https://github.com/schacon/ticgit (fetch)</span><br><span class="line">origin	https://github.com/schacon/ticgit (push)</span><br><span class="line">pb	https://github.com/paulboone/ticgit (fetch)</span><br><span class="line">pb	https://github.com/paulboone/ticgit (push)</span><br></pre></td></tr></table></figure>

<p>现在你可以在命令行中使用字符串 <code>pb</code> 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 <code>git fetch pb</code>：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch pb</span></span><br><span class="line">remote: Counting objects: 43, done.</span><br><span class="line">remote: Compressing objects: 100% (36/36), done.</span><br><span class="line">remote: Total 43 (delta 10), reused 31 (delta 5)</span><br><span class="line">Unpacking objects: 100% (43/43), done.</span><br><span class="line">From https://github.com/paulboone/ticgit</span><br><span class="line"> * [new branch]      master     -&gt; pb/master</span><br><span class="line"> * [new branch]      ticgit     -&gt; pb/ticgit</span><br></pre></td></tr></table></figure>

<p>现在 Paul 的 master 分支可以在本地通过 <code>pb/master</code> 访问到——你可以将它合并到自己的某个分支中， 或者如果你想要查看它的话，可以检出一个指向该点的本地分支。 （我们将会在 <a href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching">Git 分支</a> 中详细介绍什么是分支以及如何使用分支。）</p>
<h3 id="从远程仓库中抓取与拉取"><a href="#从远程仓库中抓取与拉取" class="headerlink" title="从远程仓库中抓取与拉取"></a>从远程仓库中抓取与拉取</h3><p>就如刚才所见，从远程仓库中获得数据，可以执行：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch &lt;remote&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p>
<p>如果你使用 <code>clone</code> 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，<code>git fetch origin</code> 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 <code>git fetch</code> 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。</p>
<p>如果你的当前分支设置了跟踪远程分支（阅读下一节和 <a href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching">Git 分支</a> 了解更多信息）， 那么可以用 <code>git pull</code> 命令来自动抓取后合并该远程分支到当前分支。 这或许是个更加简单舒服的工作流程。默认情况下，<code>git clone</code> 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 <code>master</code> 分支（或其它名字的默认分支）。 运行 <code>git pull</code> 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p>
<h3 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h3><p>当你想分享你的项目时，必须将其推送到上游。 这个命令很简单：<code>git push &lt;remote&gt; &lt;branch&gt;</code>。 当你想要将 <code>master</code> 分支推送到 <code>origin</code> 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字）， 那么运行这个命令就可以将你所做的备份到服务器：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin master</span></span><br></pre></td></tr></table></figure>

<p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取他们的工作并将其合并进你的工作后才能推送。 阅读 <a href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching">Git 分支</a> 了解如何推送到远程仓库服务器的详细信息。</p>
<h3 id="查看某个远程仓库"><a href="#查看某个远程仓库" class="headerlink" title="查看某个远程仓库"></a>查看某个远程仓库</h3><p>如果想要查看某一个远程仓库的更多信息，可以使用 <code>git remote show &lt;remote&gt;</code> 命令。 如果想以一个特定的缩写名运行这个命令，例如 <code>origin</code>，会得到像下面类似的信息：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote show origin</span></span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: https://github.com/schacon/ticgit</span><br><span class="line">  Push  URL: https://github.com/schacon/ticgit</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    master                               tracked</span><br><span class="line">    dev-branch                           tracked</span><br><span class="line">  Local branch configured for &#x27;git pull&#x27;:</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local ref configured for &#x27;git push&#x27;:</span><br><span class="line">    master pushes to master (up to date)</span><br></pre></td></tr></table></figure>

<p>它同样会列出远程仓库的 URL 与跟踪分支的信息。 这些信息非常有用，它告诉你正处于 <code>master</code> 分支，并且如果运行 <code>git pull</code>， 就会抓取所有的远程引用，然后将远程 <code>master</code> 分支合并到本地 <code>master</code> 分支。 它也会列出拉取到的所有远程引用。</p>
<p>这是一个经常遇到的简单例子。 如果你是 Git 的重度使用者，那么还可以通过 <code>git remote show</code> 看到更多的信息。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote show origin</span></span><br><span class="line">* remote origin</span><br><span class="line">  URL: https://github.com/my-org/complex-project</span><br><span class="line">  Fetch URL: https://github.com/my-org/complex-project</span><br><span class="line">  Push  URL: https://github.com/my-org/complex-project</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    master                           tracked</span><br><span class="line">    dev-branch                       tracked</span><br><span class="line">    markdown-strip                   tracked</span><br><span class="line">    issue-43                         new (next fetch will store in remotes/origin)</span><br><span class="line">    issue-45                         new (next fetch will store in remotes/origin)</span><br><span class="line">    refs/remotes/origin/issue-11     stale (use &#x27;git remote prune&#x27; to remove)</span><br><span class="line">  Local branches configured for &#x27;git pull&#x27;:</span><br><span class="line">    dev-branch merges with remote dev-branch</span><br><span class="line">    master     merges with remote master</span><br><span class="line">  Local refs configured for &#x27;git push&#x27;:</span><br><span class="line">    dev-branch                     pushes to dev-branch                     (up to date)</span><br><span class="line">    markdown-strip                 pushes to markdown-strip                 (up to date)</span><br><span class="line">    master                         pushes to master                         (up to date)</span><br></pre></td></tr></table></figure>

<p>这个命令列出了当你在特定的分支上执行 <code>git push</code> 会自动地推送到哪一个远程分支。 它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了， 还有当你执行 <code>git pull</code> 时哪些本地分支可以与它跟踪的远程分支自动合并。</p>
<h3 id="远程仓库的重命名与移除"><a href="#远程仓库的重命名与移除" class="headerlink" title="远程仓库的重命名与移除"></a>远程仓库的重命名与移除</h3><p>你可以运行 <code>git remote rename</code> 来修改一个远程仓库的简写名。 例如，想要将 <code>pb</code> 重命名为 <code>paul</code>，可以用 <code>git remote rename</code> 这样做：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote rename pb paul</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure>

<p>值得注意的是这同样也会修改你所有远程跟踪的分支名字。 那些过去引用 <code>pb/master</code> 的现在会引用 <code>paul/master</code>。</p>
<p>如果因为一些原因想要移除一个远程仓库——你已经从服务器上搬走了或不再想使用某一个特定的镜像了， 又或者某一个贡献者不再贡献了——可以使用 <code>git remote remove</code> 或 <code>git remote rm</code> ：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote remove paul</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br></pre></td></tr></table></figure>

<p>一旦你使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。</p>
<p>参考：</p>
<p><a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8">Git 基础 - 远程仓库的使用</a></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git 在不删除.git目录的情况下删除提交历史</title>
    <url>/2021/05/07/git/git-delete-history-log/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Check out to a temporary branch:</span><br><span class="line">git checkout --orphan TEMP_BRANCH</span><br><span class="line"></span><br><span class="line"># Add all the files:</span><br><span class="line">git add -A</span><br><span class="line"></span><br><span class="line"># Commit the changes:</span><br><span class="line">git commit -am &quot;Initial commit&quot;</span><br><span class="line"></span><br><span class="line"># Delete the old branch:</span><br><span class="line">git branch -D master</span><br><span class="line"></span><br><span class="line"># Rename the temporary branch to master:</span><br><span class="line">git branch -m master</span><br><span class="line"></span><br><span class="line"># Finally, force update to our repository:</span><br><span class="line">git push -f origin master</span><br></pre></td></tr></table></figure>

<p>若上述方法失败，则删除 .git 文件夹，并重新生成 .git </p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>雪花算法</title>
    <url>/2021/04/30/java/functions/snowflake-algorithm/</url>
    <content><![CDATA[<p>使用一个 64 bit 的 long 型的数字作为全局唯一 id。在分布式系统中的应用十分广泛，且ID 引入了时间戳，基本上保持自增的，后面的代码中有详细的注解。</p>
<p>这 64 个 bit 中，其中 1 个 bit 是不用的，然后用其中的 41 bit 作为毫秒数，用 10 bit 作为工作机器 id，12 bit 作为序列号。</p>
<p> <img src="/images/snowflake-algorithm.png" alt="image"></p>
<p>雪花算法简单描述：</p>
<ul>
<li>最高位是符号位，始终为0，不可用。</li>
<li>41位的时间序列，精确到毫秒级，41位的长度可以使用69年。时间位还有一个很重要的作用是可以根据时间进行排序。</li>
<li>10位的机器标识，10位的长度最多支持部署1024个节点。</li>
<li>12位的计数序列号，序列号即一系列的自增id，可以支持同一节点同一毫秒生成多个ID序号，12位的计数序列号支持每个节点每毫秒产生4096个ID序号。</li>
</ul>
<p>看的出来，这个算法很简洁也很简单，但依旧是一个很好的ID生成策略。其中，10位器标识符一般是5位IDC+5位machine编号，唯一确定一台机器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SnowFlakeGenerator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 每一部分占用位数的默认值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">DEFAULT_MACHINE_BIT_NUM</span> <span class="operator">=</span> <span class="number">5</span>;   <span class="comment">//机器标识占用的位数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">DEFAULT_IDC_BIT_NUM</span> <span class="operator">=</span> <span class="number">5</span>;<span class="comment">//数据中心占用的位数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> machineBitNum;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> idcBitNum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Factory</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.idcBitNum = DEFAULT_IDC_BIT_NUM;</span><br><span class="line">            <span class="built_in">this</span>.machineBitNum = DEFAULT_MACHINE_BIT_NUM;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Factory</span><span class="params">(<span class="type">int</span> machineBitNum, <span class="type">int</span> idcBitNum)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.idcBitNum = idcBitNum;</span><br><span class="line">            <span class="built_in">this</span>.machineBitNum = machineBitNum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> SnowFlakeGenerator <span class="title function_">create</span><span class="params">(<span class="type">long</span> idcId, <span class="type">long</span> machineId)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SnowFlakeGenerator</span>(<span class="built_in">this</span>.idcBitNum, <span class="built_in">this</span>.machineBitNum, idcId, machineId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 起始的时间戳</span></span><br><span class="line"><span class="comment">     * 作者写代码时的时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">START_STAMP</span> <span class="operator">=</span> <span class="number">1508143349995L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可分配的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">REMAIN_BIT_NUM</span> <span class="operator">=</span> <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * idc编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> idcId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 机器编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> machineId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前序列号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">sequence</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上次最新时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastStamp</span> <span class="operator">=</span> -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * idc偏移量：一次计算出，避免重复计算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> idcBitLeftOffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 机器id偏移量：一次计算出，避免重复计算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> machineBitLeftOffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间戳偏移量：一次计算出，避免重复计算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> timestampBitLeftOffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大序列值：一次计算出，避免重复计算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSequenceValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SnowFlakeGenerator</span><span class="params">(<span class="type">int</span> idcBitNum, <span class="type">int</span> machineBitNum, <span class="type">long</span> idcId, <span class="type">long</span> machineId)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sequenceBitNum</span> <span class="operator">=</span> REMAIN_BIT_NUM - idcBitNum - machineBitNum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (idcBitNum &lt;= <span class="number">0</span> || machineBitNum &lt;= <span class="number">0</span> || sequenceBitNum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;error bit number&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.maxSequenceValue = ~(-<span class="number">1</span> &lt;&lt; sequenceBitNum);</span><br><span class="line"></span><br><span class="line">        machineBitLeftOffset = sequenceBitNum;</span><br><span class="line">        idcBitLeftOffset = idcBitNum + sequenceBitNum;</span><br><span class="line">        timestampBitLeftOffset = idcBitNum + machineBitNum + sequenceBitNum;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.idcId = idcId;</span><br><span class="line">        <span class="built_in">this</span>.machineId = machineId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产生下一个ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">currentStamp</span> <span class="operator">=</span> getTimeMill();</span><br><span class="line">        <span class="keyword">if</span> (currentStamp &lt; lastStamp) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(String.format(<span class="string">&quot;Clock moved backwards. Refusing to generate id for %d milliseconds&quot;</span>, lastStamp - currentStamp));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新的毫秒，序列从0开始，否则序列自增</span></span><br><span class="line">        <span class="keyword">if</span> (currentStamp == lastStamp) &#123;</span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; <span class="built_in">this</span>.maxSequenceValue;</span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0L</span>) &#123;</span><br><span class="line">                <span class="comment">//Twitter源代码中的逻辑是循环，直到下一个毫秒</span></span><br><span class="line">                lastStamp = tilNextMillis();</span><br><span class="line"><span class="comment">//                throw new IllegalStateException(&quot;sequence over flow&quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastStamp = currentStamp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (currentStamp - START_STAMP) &lt;&lt; timestampBitLeftOffset | idcId &lt;&lt; idcBitLeftOffset | machineId &lt;&lt; machineBitLeftOffset | sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">getTimeMill</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">tilNextMillis</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> getTimeMill();</span><br><span class="line">        <span class="keyword">while</span> (timestamp &lt;= lastStamp) &#123;</span><br><span class="line">            timestamp = getTimeMill();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>参考：</p>
<p><a href="https://blog.csdn.net/u011499747/article/details/78254990">雪花算法(snowflake)</a><br><a href="https://blog.csdn.net/lq18050010830/article/details/89845790">雪花算法的原理和实现Java</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot 配置文件 server.context-path 路径</title>
    <url>/2021/04/30/spring/springboot/spring-boot-path/</url>
    <content><![CDATA[<ul>
<li>springboot v1.x 配置： server.context-path&#x3D;&#x2F;path</li>
<li>springboot v2.x 配置： server.servelt.context-path&#x3D;&#x2F;path</li>
</ul>
]]></content>
      <categories>
        <category>spring</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>path</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql锁概述</title>
    <url>/2021/04/28/database/mysql/mysql-lock-overview/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><img src="/images/mysql-lock/mysql-lock.png" alt="image" title="锁说明"></p>
<h1 id="1-锁？"><a href="#1-锁？" class="headerlink" title="1.锁？"></a>1.锁？</h1><h2 id="1-1何为锁"><a href="#1-1何为锁" class="headerlink" title="1.1何为锁"></a>1.1何为锁</h2><p>锁在现实中的意义为:封闭的器物，以钥匙或暗码开启。在计算机中的锁一般用来管理对共享资源的并发访问，比如我们java同学熟悉的Lock,synchronized等都是我们常见的锁。当然在我们的数据库中也有锁用来控制资源的并发访问，这也是数据库和文件系统的区别之一。</p>
<h2 id="1-2为什么要懂数据库锁"><a href="#1-2为什么要懂数据库锁" class="headerlink" title="1.2为什么要懂数据库锁?"></a>1.2为什么要懂数据库锁?</h2><p>通常来说对于一般的开发人员，在使用数据库的时候一般懂点DQL(select),DML(insert,update,delete)就够了。</p>
<p>小明是一个刚刚毕业在互联网公司工作的Java开发工程师，平常的工作就是完成PM的需求，当然在完成需求的同时肯定逃脱不了spring,springmvc,mybatis的那一套框架，所以一般来说sql还是自己手写，遇到比较复杂的sql会从网上去百度一下。对于一些比较重要操作，比如交易啊这些，小明会用spring的事务来对数据库的事务进行管理，由于数据量比较小目前还涉及不了分布式事务。</p>
<p>前几个月小明过得都还风调雨顺,知道有一天，小明接了一个需求，商家有个配置项，叫优惠配置项，可以配置买一送一，买一送二等等规则，当然这些配置是批量传输给后端的，这样就有个问题每个规则都得去匹配他到底是删除还是添加还是修改，这样后端逻辑就比较麻烦，聪明的小明想到了一个办法，直接删除这个商家的配置，然后全部添加进去。小明马上开发完毕，成功上线。</p>
<p>开始上线没什么毛病，但是日志经常会出现一些mysql-insert-deadlock异常。由于小明经验比较浅，对于这类型的问题第一次遇见，于是去问了他们组的老司机-大红，大红一看见这个问题，然后看了他的代码之后，输出了几个命令看了几个日志，马上定位了问题，告诉了小明：这是因为delete的时候会加间隙锁，但是间隙锁之间却可以兼容，但是插入新的数据的时候就会因为插入意向锁会被间隙锁阻塞，导致双方被资源被互占，导致死锁。小明听了之后似懂非懂，由于大红的事情比较多，不方便一直麻烦大红，所以决定自己下来自己想。下班过后，小明回想大红说的话，什么是间隙锁，什么是插入意向锁，看来作为开发者对数据库不应该只会写SQL啊，不然遇到一些疑难杂症完全没法解决啊。想完，于是小明就踏上了学习Mysql锁这条不归之路。</p>
<h1 id="2-InnoDB"><a href="#2-InnoDB" class="headerlink" title="2.InnoDB"></a>2.InnoDB</h1><h2 id="2-1mysql体系架构"><a href="#2-1mysql体系架构" class="headerlink" title="2.1mysql体系架构"></a>2.1mysql体系架构</h2><p>小明没有着急去了解锁这方面的知识，他首先先了解了下Mysql体系架构:</p>
<p> <img src="/images/mysql-lock/mysql-lock-1.webp" alt="图片"> </p>
<p>可以发现Mysql由连接池组件、管理服务和工具组件、sql接口组件、查询分析器组件、优化器组件、 缓冲组件、插件式存储引擎、物理文件组成。</p>
<p>小明发现在mysql中存储引擎是以插件的方式提供的，在Mysql中有多种存储引擎，每个存储引擎都有自己的特点。随后小明在命令行中打出了:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show engines \G;</span><br></pre></td></tr></table></figure>

<p>一看原来有这么多种引擎。</p>
<p>又打出了下面的命令，查看当前数据库默认的引擎:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%storage_engine%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/images/mysql-lock/mysql-lock-2.webp" alt="图片">小明恍然大悟:原来自己的数据库是使用的InnoDB,依稀记得自己在上学的时候好像听说过有个引擎叫MyIsAM,小明想这两个有啥不同呢?马上查找了一下资料:</p>
<table>
<thead>
<tr>
<th align="left">对比项</th>
<th align="left">InnoDB</th>
<th align="left">MyIsAM</th>
</tr>
</thead>
<tbody><tr>
<td align="left">事务</td>
<td align="left">支持</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left">锁</td>
<td align="left">支持MVCC行锁</td>
<td align="left">表锁</td>
</tr>
<tr>
<td align="left">外键</td>
<td align="left">支持</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left">存储空间</td>
<td align="left">存储空间由于需要高速缓存，较大</td>
<td align="left">可压缩</td>
</tr>
<tr>
<td align="left">适用场景</td>
<td align="left">有一定量的update和Insert</td>
<td align="left">大量的select</td>
</tr>
</tbody></table>
<p>小明大概了解了一下InnoDB和MyIsAM的区别，由于使用的是InnoDB，小明就没有过多的纠结这一块。</p>
<h2 id="2-2事务的隔离性"><a href="#2-2事务的隔离性" class="headerlink" title="2.2事务的隔离性"></a>2.2事务的隔离性</h2><p>小明在研究锁之前，又回想到之前上学的时候教过的数据库事务隔离性，其实锁在数据库中其功能之一也是用来实现事务隔离性。而事务的隔离性其实是用来解决，脏读，不可重复读，幻读几类问题。</p>
<h3 id="2-2-1-脏读"><a href="#2-2-1-脏读" class="headerlink" title="2.2.1 脏读"></a>2.2.1 脏读</h3><p>一个事务读取到另一个事务未提交的更新数据。 什么意思呢?</p>
<table>
<thead>
<tr>
<th align="left">时间点</th>
<th align="left">事务A</th>
<th align="left">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">begin;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">select * from user where id &#x3D; 1;</td>
<td align="left">begin;</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"></td>
<td align="left">update user set namm &#x3D; ‘test’ where id &#x3D; 1;</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">select * from user where id &#x3D; 1;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">commit;</td>
<td align="left">commit;</td>
</tr>
</tbody></table>
<p>在事务A，B中，事务A在时间点2，4分别对user表中id&#x3D;1的数据进行了查询了，但是事务B在时间点3进行了修改，导致了事务A在4中的查询出的结果其实是事务B修改后的。破坏了数据库中的隔离性。</p>
<h3 id="2-2-2-不可重复读"><a href="#2-2-2-不可重复读" class="headerlink" title="2.2.2 不可重复读"></a>2.2.2 不可重复读</h3><p>在同一个事务中，多次读取同一数据返回的结果不同，和脏读不同的是这里读取的是已经提交过后的。</p>
<table>
<thead>
<tr>
<th align="left">时间点</th>
<th align="left">事务A</th>
<th align="left">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">begin;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">select * from user where id &#x3D; 1;</td>
<td align="left">begin;</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"></td>
<td align="left">update user set namm &#x3D; ‘test’ where id &#x3D; 1;</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"></td>
<td align="left">commit;</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">select * from user where id &#x3D; 1;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">commit;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>在事务B中提交的操作在事务A第二次查询之前，但是依然读到了事务B的更新结果，也破坏了事务的隔离性。</p>
<h3 id="2-2-3-幻读"><a href="#2-2-3-幻读" class="headerlink" title="2.2.3 幻读"></a>2.2.3 幻读</h3><p>一个事务读到另一个事务已提交的insert数据。</p>
<table>
<thead>
<tr>
<th align="left">时间点</th>
<th align="left">事务A</th>
<th align="left">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">begin;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">select * from user where id &gt; 1;</td>
<td align="left">begin;</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"></td>
<td align="left">insert user select 2;</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"></td>
<td align="left">commit;</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">select * from user where id &gt; 1;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">commit;</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>在事务A中查询了两次id大于1的，在第一次id大于1查询结果中没有数据，但是由于事务B插入了一条Id&#x3D;2的数据，导致事务A第二次查询时能查到事务B中插入的数据。</p>
<p>事务中的隔离性:</p>
<table>
<thead>
<tr>
<th align="left">隔离级别</th>
<th align="left">脏读</th>
<th align="left">不可重复读</th>
<th align="left">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="left">未提交读(RUC)</td>
<td align="left">NO</td>
<td align="left">NO</td>
<td align="left">NO</td>
</tr>
<tr>
<td align="left">已提交读(RC)</td>
<td align="left">YES</td>
<td align="left">NO</td>
<td align="left">NO</td>
</tr>
<tr>
<td align="left">可重复读(RR)</td>
<td align="left">YES</td>
<td align="left">YES</td>
<td align="left">NO</td>
</tr>
<tr>
<td align="left">可串行化</td>
<td align="left">YES</td>
<td align="left">YES</td>
<td align="left">YES</td>
</tr>
</tbody></table>
<p>小明注意到在收集资料的过程中，有资料写到InnoDB和其他数据库有点不同，InnoDB的可重复读其实就能解决幻读了，小明心想:这InnoDB还挺牛逼的，我得好好看看到底是怎么个原理。</p>
<h2 id="2-3-InnoDB锁类型"><a href="#2-3-InnoDB锁类型" class="headerlink" title="2.3 InnoDB锁类型"></a>2.3 InnoDB锁类型</h2><p>小明首先了解一下Mysql中常见的锁类型有哪些:</p>
<h3 id="2-3-1-S-or-X"><a href="#2-3-1-S-or-X" class="headerlink" title="2.3.1 S or X"></a>2.3.1 S or X</h3><p>在InnoDb中实现了两个标准的行级锁，可以简单的看为两个读写锁:</p>
<ul>
<li>S-共享锁：又叫读锁，其他事务可以继续加共享锁，但是不能继续加排他锁。</li>
<li>X-排他锁: 又叫写锁，一旦加了写锁之后，其他事务就不能加锁了。</li>
</ul>
<blockquote>
<p>兼容性:是指事务A获得一个某行某种锁之后，事务B同样的在这个行上尝试获取某种锁，如果能立即获取，则称锁兼容，反之叫冲突。</p>
</blockquote>
<p>纵轴是代表已有的锁，横轴是代表尝试获取的锁。</p>
<table>
<thead>
<tr>
<th align="left">.</th>
<th align="left">X</th>
<th align="left">S</th>
</tr>
</thead>
<tbody><tr>
<td align="left">X</td>
<td align="left">冲突</td>
<td align="left">冲突</td>
</tr>
<tr>
<td align="left">S</td>
<td align="left">冲突</td>
<td align="left">兼容</td>
</tr>
</tbody></table>
<h3 id="2-3-2-意向锁"><a href="#2-3-2-意向锁" class="headerlink" title="2.3.2 意向锁"></a>2.3.2 意向锁</h3><p>意向锁在InnoDB中是表级锁,和他的名字一样他是用来表达一个事务想要获取什么。意向锁分为:</p>
<ul>
<li>意向共享锁:表达一个事务想要获取一张表中某几行的共享锁。</li>
<li>意向排他锁:表达一个事务想要获取一张表中某几行的排他锁。</li>
</ul>
<p>这个锁有什么用呢？为什么需要这个锁呢？ 首先说一下如果没有这个锁，如果要给这个表加上表锁，一般的做法是去遍历每一行看看他是否有行锁，这样的话效率太低，而我们有意向锁，只需要判断是否有意向锁即可，不需要再去一行行的去扫描。</p>
<p>在InnoDB中由于支持的是行级的锁，因此InnboDB锁的兼容性可以扩展如下：</p>
<table>
<thead>
<tr>
<th align="left">.</th>
<th align="left">IX</th>
<th align="left">IS</th>
<th align="left">X</th>
<th align="left">S</th>
</tr>
</thead>
<tbody><tr>
<td align="left">IX</td>
<td align="left">兼容</td>
<td align="left">兼容</td>
<td align="left">冲突</td>
<td align="left">冲突</td>
</tr>
<tr>
<td align="left">IS</td>
<td align="left">兼容</td>
<td align="left">兼容</td>
<td align="left">冲突</td>
<td align="left">兼容</td>
</tr>
<tr>
<td align="left">X</td>
<td align="left">冲突</td>
<td align="left">冲突</td>
<td align="left">冲突</td>
<td align="left">冲突</td>
</tr>
<tr>
<td align="left">S</td>
<td align="left">冲突</td>
<td align="left">兼容</td>
<td align="left">冲突</td>
<td align="left">兼容</td>
</tr>
</tbody></table>
<h3 id="2-3-3-自增长锁"><a href="#2-3-3-自增长锁" class="headerlink" title="2.3.3 自增长锁"></a>2.3.3 自增长锁</h3><p>自增长锁是一种特殊的表锁机制，提升并发插入性能。对于这个锁有几个特点:</p>
<ul>
<li>在sql执行完就释放锁，并不是事务执行完。</li>
<li>对于Insert…select大数据量插入会影响插入性能，因为会阻塞另外一个事务执行。</li>
<li>自增算法可以配置。</li>
</ul>
<p>在MySQL5.1.2版本之后，有了很多优化，可以根据不同的模式来进行调整自增加锁的方式。小明看到了这里打开了自己的MySQL发现是5.7之后，于是便输入了下面的语句,获取到当前锁的模式:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_autoinc_lock_mode&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name            <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_autoinc_lock_mode <span class="operator">|</span> <span class="number">2</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>在MySQL中innodbautoinclock_mode有3种配置模式：0、1、2，分别对应”传统模式”, “连续模式”, “交错模式”。</p>
<ol>
<li>传统模式:也就是我们最上面的使用表锁。</li>
<li>连续模式:对于插入的时候可以确定行数的使用互斥量，对于不能确定行数的使用表锁的模式。</li>
<li>交错模式:所有的都使用互斥量，为什么叫交错模式呢，有可能在批量插入时自增值不是连续的，当然一般来说如果不看重自增值连续一般选择这个模式，性能是最好的。</li>
</ol>
<h2 id="2-4InnoDB锁算法"><a href="#2-4InnoDB锁算法" class="headerlink" title="2.4InnoDB锁算法"></a>2.4InnoDB锁算法</h2><p>小明已经了解到了在InnoDB中有哪些锁类型，但是如何去使用这些锁，还是得靠锁算法。</p>
<h3 id="2-4-1-记录锁-Record-Lock"><a href="#2-4-1-记录锁-Record-Lock" class="headerlink" title="2.4.1 记录锁(Record-Lock)"></a>2.4.1 记录锁(Record-Lock)</h3><p>记录锁是锁住记录的，这里要说明的是这里锁住的是索引记录，而不是我们真正的数据记录。</p>
<ul>
<li>如果锁的是非主键索引，会在自己的索引上面加锁之后然后再去主键上面加锁锁住.</li>
<li>如果没有表上没有索引(包括没有主键)，则会使用隐藏的主键索引进行加锁。</li>
<li>如果要锁的列没有索引，则会进行全表记录加锁。</li>
</ul>
<h3 id="2-4-2-间隙锁"><a href="#2-4-2-间隙锁" class="headerlink" title="2.4.2 间隙锁"></a>2.4.2 间隙锁</h3><p>间隙锁顾名思义锁间隙，不锁记录。锁间隙的意思就是锁定某一个范围，间隙锁又叫gap锁，其不会阻塞其他的gap锁，但是会阻塞插入间隙锁，这也是用来防止幻读的关键。</p>
<p><img src="/images/mysql-lock/mysql-lock-3.webp" alt="图片"></p>
<h3 id="2-4-3-next-key锁"><a href="#2-4-3-next-key锁" class="headerlink" title="2.4.3 next-key锁"></a>2.4.3 next-key锁</h3><p>这个锁本质是记录锁加上gap锁。在RR隔离级别下(InnoDB默认)，Innodb对于行的扫描锁定都是使用此算法，但是如果查询扫描中有唯一索引会退化成只使用记录锁。为什么呢? 因为唯一索引能确定行数，而其他索引不能确定行数，有可能在其他事务中会再次添加这个索引的数据会造成幻读。</p>
<blockquote>
<p>这里也说明了为什么Mysql可以在RR级别下解决幻读。</p>
</blockquote>
<h3 id="2-4-4-插入意向锁"><a href="#2-4-4-插入意向锁" class="headerlink" title="2.4.4 插入意向锁"></a>2.4.4 插入意向锁</h3><p>插入意向锁Mysql官方对其的解释:</p>
<blockquote>
<p>An insert intention lock is a type of gap lock set by INSERT operations prior to row insertion. This lock signals the intent to insert in such a way that multiple transactions inserting into the same index gap need not wait for each other if they are not inserting at the same position within the gap. Suppose that there are index records with values of 4 and 7. Separate transactions that attempt to insert values of 5 and 6, respectively, each lock the gap between 4 and 7 with insert intention locks prior to obtaining the exclusive lock on the inserted row, but do not block each other because the rows are nonconflicting.</p>
</blockquote>
<p>可以看出插入意向锁是在插入的时候产生的,在多个事务同时写入不同数据至同一索引间隙的时候，并不需要等待其他事务完成，不会发生锁等待。假设有一个记录索引包含键值4和7，不同的事务分别插入5和6，每个事务都会产生一个加在4-7之间的插入意向锁，获取在插入行上的排它锁，但是不会被互相锁住，因为数据行并不冲突。</p>
<blockquote>
<p>这里要说明的是如果有间隙锁了，插入意向锁会被阻塞。</p>
</blockquote>
<h2 id="2-5-MVCC"><a href="#2-5-MVCC" class="headerlink" title="2.5 MVCC"></a>2.5 MVCC</h2><p>MVCC，多版本并发控制技术。在InnoDB中，在每一行记录的后面增加两个隐藏列，记录创建版本号和删除版本号。通过版本号和行锁，从而提高数据库系统并发性能。</p>
<p>在MVCC中，对于读操作可以分为两种读:</p>
<ul>
<li>快照读:读取的历史数据，简单的select语句，不加锁，MVCC实现可重复读，使用的是MVCC机制读取undo中的已经提交的数据。所以它的读取是非阻塞的。</li>
<li>当前读:需要加锁的语句,update,insert,delete,select…for update等等都是当前读。</li>
</ul>
<p>在RR隔离级别下的快照读，不是以begin事务开始的时间点作为snapshot建立时间点，而是以第一条select语句的时间点作为snapshot建立的时间点。以后的select都会读取当前时间点的快照值。</p>
<p>在RC隔离级别下每次快照读均会创建新的快照。</p>
<blockquote>
<p>具体的原理是通过每行会有两个隐藏的字段一个是用来记录当前事务，一个是用来记录回滚的指向Undolog。利用undolog就可以读取到之前的快照，不需要单独开辟空间记录。</p>
</blockquote>
<h1 id="3-加锁分析"><a href="#3-加锁分析" class="headerlink" title="3.加锁分析"></a>3.加锁分析</h1><p>小明到这里，已经学习很多mysql锁有关的基础知识，所以决定自己创建一个表搞下实验。首先创建了一个简单的用户表:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">`id` <span class="type">int</span>(<span class="number">11</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`name` <span class="type">varchar</span>(<span class="number">11</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`comment` <span class="type">varchar</span>(<span class="number">11</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`),  </span><br><span class="line">KEY `index_name` (`name`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">0</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_bin;</span><br></pre></td></tr></table></figure>

<p>然后插入了几条实验数据:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">user</span> <span class="keyword">select</span> <span class="number">20</span>,<span class="number">333</span>,<span class="number">333</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">user</span> <span class="keyword">select</span> <span class="number">25</span>,<span class="number">555</span>,<span class="number">555</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">user</span> <span class="keyword">select</span> <span class="number">20</span>,<span class="number">999</span>,<span class="number">999</span>;</span><br></pre></td></tr></table></figure>

<p>数据库事务隔离选择了RR</p>
<h2 id="3-1-实验1"><a href="#3-1-实验1" class="headerlink" title="3.1 实验1"></a>3.1 实验1</h2><p>小明开启了两个事务，进行实验1.</p>
<table>
<thead>
<tr>
<th align="left">时间点</th>
<th align="left">事务A</th>
<th align="left">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">begin;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">select * from user where name &#x3D; ‘555’ for update;</td>
<td align="left">begin;</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"></td>
<td align="left">insert user select 31,’556’,’556’;</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"></td>
<td align="left">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</td>
</tr>
</tbody></table>
<p>小明开启了两个事务并输入了上面的语句，发现事务B居然出现了超时，小明看了一下自己明明是对name &#x3D; 555这一行进行的加锁，为什么我想插入name&#x3D;556给我阻塞了。于是小明打开命令行输入:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.INNODB_LOCKS</span><br></pre></td></tr></table></figure>

<p>发现在事务A中给555加了Next-key锁，事务B插入的时候会首先进行插入意向锁的插入，于是得出下面结论: <img src="/images/mysql-lock/mysql-lock-4.jpg" alt="图片">可以看见事务B由于间隙锁和插入意向锁的冲突，导致了阻塞。</p>
<h2 id="3-2-实验2"><a href="#3-2-实验2" class="headerlink" title="3.2 实验2"></a>3.2 实验2</h2><p>小明发现上面查询条件用的是普通的非唯一索引，于是小明就试了一下主键索引:</p>
<table>
<thead>
<tr>
<th align="left">时间点</th>
<th align="left">事务A</th>
<th align="left">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">begin;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">select * from user where id &#x3D; 25 for update;</td>
<td align="left">begin;</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"></td>
<td align="left">insert user select 26,’666’,’666’;</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"></td>
<td align="left">Query OK, 1 row affected (0.00 sec)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>Records: 1 Duplicates: 0 Warnings: 0</p>
<p>居然发现事务B并没有发生阻塞，哎这个是咋回事呢，小明有点疑惑，按照实验1的套路应该会被阻塞啊，因为25-30之间会有间隙锁。于是小明又祭出了命令行，发现只加了X记录锁。原来是因为唯一索引会降级记录锁，这么做的理由是:非唯一索引加next-key锁由于不能确定明确的行数有可能其他事务在你查询的过程中，再次添加这个索引的数据，导致隔离性遭到破坏，也就是幻读。唯一索引由于明确了唯一的数据行，所以不需要添加间隙锁解决幻读。</p>
<p><img src="/images/mysql-lock/mysql-lock-5.webp" alt="图片"></p>
<h2 id="3-3-实验3"><a href="#3-3-实验3" class="headerlink" title="3.3 实验3"></a>3.3 实验3</h2><p>上面测试了主键索引，非唯一索引，这里还有个字段是没有索引，如果对其加锁会出现什么呢？</p>
<table>
<thead>
<tr>
<th align="left">时间点</th>
<th align="left">事务A</th>
<th align="left">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">begin;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">select * from user where comment &#x3D; ‘555’ for update;</td>
<td align="left">begin;</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"></td>
<td align="left">insert user select 26,’666’,’666’;</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"></td>
<td align="left">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"></td>
<td align="left">insert user select 31,’3131’,’3131’;</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"></td>
<td align="left">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"></td>
<td align="left">insert user select 10,’100’,’100’;</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"></td>
<td align="left">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>小明一看哎哟我去，这个咋回事呢，咋不管是用实验1非间隙锁范围的数据，还是用间隙锁里面的数据都不行，难道是加了表锁吗？</p>
<p>的确，如果用没有索引的数据，其会对所有聚簇索引上都加上next-key锁。</p>
<p><img src="/images/mysql-lock/mysql-lock-6.webp" alt="图片"></p>
<p>所以大家平常开发的时候如果对查询条件没有索引的，一定进行一致性读，也就是加锁读，会导致全表加上索引，会导致其他事务全部阻塞，数据库基本会处于不可用状态。</p>
<h1 id="4-回到事故"><a href="#4-回到事故" class="headerlink" title="4.回到事故"></a>4.回到事故</h1><h2 id="4-1-死锁"><a href="#4-1-死锁" class="headerlink" title="4.1 死锁"></a>4.1 死锁</h2><p>小明做完实验之后总算是了解清楚了加锁的一些基本套路，但是之前线上出现的死锁又是什么东西呢？</p>
<p>死锁:是指两个或两个以上的事务在执行过程中，因争夺资源而造成的一种互相等待的现象。说明有等待才会有死锁，解决死锁可以通过去掉等待，比如回滚事务。</p>
<p>解决死锁的两个办法:</p>
<ol>
<li>等待超时:当某一个事务等待超时之后回滚该事务，另外一个事务就可以执行了，但是这样做效率较低，会出现等待时间，还有个问题是如果这个事务所占的权重较大，已经更新了很多数据了，但是被回滚了，就会导致资源浪费。</li>
<li>等待图(wait-for-graph): 等待图用来描述事务之间的等待关系，当这个图如果出现回路如下:</li>
</ol>
<p><img src="/images/mysql-lock/mysql-lock-7.webp" alt="图片"> 就出现回滚，通常来说InnoDB会选择回滚权重较小的事务，也就是undo较小的事务。</p>
<h2 id="4-2-线上问题"><a href="#4-2-线上问题" class="headerlink" title="4.2 线上问题"></a>4.2 线上问题</h2><p>小明到这里，基本需要的基本功都有了，于是在自己的本地表中开始复现这个问题:</p>
<table>
<thead>
<tr>
<th align="left">时间点</th>
<th align="left">事务A</th>
<th align="left">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">begin;</td>
<td align="left">begin;</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">delete from user where name &#x3D; ‘777’;</td>
<td align="left">delete from user where name &#x3D; ‘666’;</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">insert user select 27,’777’,’777’;</td>
<td align="left">insert user select 26,’666’,’666’;</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</td>
<td align="left">Query OK, 1 row affected (14.32 sec) Records: 1 Duplicates: 0 Warnings: 0</td>
</tr>
</tbody></table>
<p>可以看见事务A出现被回滚了，而事务B成功执行。 具体每个时间点发生了什么呢?</p>
<p>时间点2:事务A删除name &#x3D; ‘777’的数据，需要对777这个索引加上next-Key锁，但是其不存在，所以只对555-999之间加间隙锁，同理事务B也对555-999之间加间隙锁。间隙锁之间是兼容的。</p>
<p>时间点3:事务A，执行Insert操作，首先插入意向锁，但是555-999之间有间隙锁，由于插入意向锁和间隙锁冲突，事务A阻塞，等待事务B释放间隙锁。事务B同理，等待事务A释放间隙锁。于是出现了A-&gt;B,B-&gt;A回路等待。</p>
<p>时间点4:事务管理器选择回滚事务A，事务B插入操作执行成功。</p>
<p><img src="/images/mysql-lock/mysql-lock-8.jpg" alt="图片"></p>
<h2 id="4-3-修复BUG"><a href="#4-3-修复BUG" class="headerlink" title="4.3 修复BUG"></a>4.3 修复BUG</h2><p>这个问题总算是被小明找到了，就是因为间隙锁，现在需要解决这个问题，这个问题的原因是出现了间隙锁，那就来去掉他吧:</p>
<ul>
<li>方案一:隔离级别降级为RC，在RC级别下不会加入间隙锁，所以就不会出现毛病了，但是在RC级别下会出现幻读，可提交读都破坏隔离性的毛病，所以这个方案不行。</li>
<li>方案二:隔离级别升级为可序列化，小明经过测试后发现不会出现这个问题，但是在可序列化级别下，性能会较低，会出现较多的锁等待，同样的也不考虑。</li>
<li>方案三:修改代码逻辑，不要直接删，改成每个数据由业务逻辑去判断哪些是更新，哪些是删除，那些是添加，这个工作量稍大，小明写这个直接删除的逻辑就是为了不做这些复杂的事的，所以这个方案先不考虑。</li>
<li>方案四:较少的修改代码逻辑，在删除之前，可以通过快照查询(不加锁)，如果查询没有结果，则直接插入，如果有通过主键进行删除，在之前第三节实验2中，通过唯一索引会降级为记录锁，所以不存在间隙锁。</li>
</ul>
<p>经过考虑小明选择了第四种，马上进行了修复，然后上线观察验证，发现现在已经不会出现这个Bug了，这下小明总算能睡个安稳觉了。</p>
<h2 id="4-4-如何防止死锁"><a href="#4-4-如何防止死锁" class="headerlink" title="4.4 如何防止死锁"></a>4.4 如何防止死锁</h2><p>小明通过基础的学习和平常的经验总结了如下几点:</p>
<ul>
<li>以固定的顺序访问表和行。交叉访问更容易造成事务等待回路。</li>
<li>尽量避免大事务，占有的资源锁越多，越容易出现死锁。建议拆成小事务。</li>
<li>降低隔离级别。如果业务允许(上面4.3也分析了，某些业务并不能允许)，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。</li>
<li>为表添加合理的索引。防止没有索引出现表锁，出现的死锁的概率会突增。</li>
</ul>
<p>参考：</p>
<p><a href="https://learnku.com/articles/39212">https://learnku.com/articles/39212</a></p>
<p><a href="https://mp.weixin.qq.com/s/yzXbbutzVJ1hIZgVszIBgw">https://mp.weixin.qq.com/s/yzXbbutzVJ1hIZgVszIBgw</a></p>
]]></content>
      <categories>
        <category>database</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql面试题目</title>
    <url>/2021/04/28/database/mysql/mysql-Interview-questions/</url>
    <content><![CDATA[<h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><ol>
<li><h3 id="多表查询连接方式有哪些？"><a href="#多表查询连接方式有哪些？" class="headerlink" title="多表查询连接方式有哪些？"></a>多表查询连接方式有哪些？</h3>​		内连接、左外连接、右外连接、外连接</li>
<li><h3 id="解释-MySQL-外连接、内连接、左外，右外连接区别"><a href="#解释-MySQL-外连接、内连接、左外，右外连接区别" class="headerlink" title="解释 MySQL 外连接、内连接、左外，右外连接区别"></a>解释 MySQL 外连接、内连接、左外，右外连接区别</h3>​		内连接 则是只有条件的交叉连接，根据某个条件筛选出符合条件的记录，不符合条件的记录不会出现在结果集中，即内连接只连接匹配的行。<br>​		外连接 其结果集中不仅包含符合连接条件的行，而且还会包括左表、右表或两个表中的所有数据行，这三种情况依次称之为左外连接，右外连接，和全外连接。<br>​		左外连接，也称左连接，左表为主表，左表中的所有记录都会出现在结果集中，对于那些在右表中并没有匹配的记录，仍然要显示，右边对应的那些字段值以NULL 来填充。右外连接，也称右连接，右表为主表，右表中的所有记录都会出现在结果集中。左连接和右连接可以互换，MySQL 目前还不支持全外连接。</li>
</ol>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ol>
<li><h3 id="通用SQL函数有哪些？"><a href="#通用SQL函数有哪些？" class="headerlink" title="通用SQL函数有哪些？"></a>通用SQL函数有哪些？</h3><ol>
<li>CONCAT(A, B) – 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合并为一个字段。</li>
<li>FORMAT(X, D)- 格式化数字 X 到 D 有效数字。</li>
<li>CURRDATE(), CURRTIME()- 返回当前日期或时间。</li>
<li>NOW（） – 将当前日期和时间作为一个值返回。</li>
<li>MONTH（），DAY（），YEAR（），WEEK（），WEEKDAY（） – 从日期值中提取给定数据。</li>
<li>HOUR（），MINUTE（），SECOND（） – 从时间值中提取给定数据。</li>
<li>DATEDIFF（A，B） – 确定两个日期之间的差异，通常用于计算年龄</li>
<li>SUBTIMES（A，B） – 确定两次之间的差异。</li>
<li>FROMDAYS（INT） – 将整数天数转换为日期值。</li>
</ol>
</li>
</ol>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><ol>
<li><h3 id="数据库中的事务是什么"><a href="#数据库中的事务是什么" class="headerlink" title="数据库中的事务是什么?"></a>数据库中的事务是什么?</h3><p>​		事务（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。</p>
<p>​		或者这样理解：事务就是被绑定在一起作为一个逻辑工作单元的 SQL 语句分组，如果任何一个语句操作失败那么整个操作就被失败，以后操作就会回滚到操作前状态，或者是上有个节点。为了确保要么执行，要么不执行，就可以使用事务。要将有组语句作为事务考虑，就需要通过 ACID 测试，即原子性，一致性，隔离性和持久性。</p>
<p>事务特性：</p>
<ol>
<li>原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。</li>
<li>一致性或可串性。事务的执行使得数据库从一种正确状态转换成另一种正确状态。</li>
<li>隔离性。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务。</li>
<li>持久性。事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。</li>
</ol>
</li>
</ol>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><ol>
<li><h3 id="简述在-MySQL-数据库中-MyISAM-和-InnoDB-索引方式的区别"><a href="#简述在-MySQL-数据库中-MyISAM-和-InnoDB-索引方式的区别" class="headerlink" title="简述在 MySQL 数据库中 MyISAM 和 InnoDB 索引方式的区别"></a>简述在 MySQL 数据库中 MyISAM 和 InnoDB 索引方式的区别</h3><ol>
<li><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><ol>
<li>不支持事务，但是每次查询都是原子的；</li>
<li>支持表级锁，即每次操作是对整个表加锁；</li>
<li>存储表的总行数；</li>
<li>一个 MYISAM 表有三个文件：索引文件、表结构文件、数据文件；</li>
<li>采用菲聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。</li>
</ol>
</li>
<li><h4 id="InnoDb："><a href="#InnoDb：" class="headerlink" title="InnoDb："></a>InnoDb：</h4><ol>
<li>支持 ACID 的事务，支持事务的四种隔离级别；</li>
<li>支持行级锁及外键约束：因此可以支持写并发；</li>
<li>不存储总行数：</li>
<li>一个 InnoDb 引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为 2G），受操作系统文件大小的限制；</li>
<li>主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时，为维持 B+树结构，文件的大调整。</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="索引种类"><a href="#索引种类" class="headerlink" title="索引种类"></a>索引种类</h3><ol>
<li>普通索引：仅加速查询</li>
<li>唯一索引：加速查询 + 列值唯一（可以有null）</li>
<li>主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</li>
<li>全文索引：对文本的内容进行分词，进行搜索</li>
</ol>
</li>
<li><h3 id="主键、外键和索引的区别？"><a href="#主键、外键和索引的区别？" class="headerlink" title="主键、外键和索引的区别？"></a>主键、外键和索引的区别？</h3><ol>
<li><strong>定义：</strong><br>主键——唯一标识一条记录，不能有重复的，不允许为空<br>外键——表的外键是另一表的主键, 外键可以有重复的, 可以是空值<br>索引——该字段没有重复值，但可以有一个空值</li>
<li><strong>作用：</strong><br>主键——用来保证数据完整性<br>外键——用来和其他表建立联系用的<br>索引——是提高查询排序的速度</li>
<li><strong>个数：</strong><br>主键—— 主键只能有一个<br>外键—— 一个表可以有多个外键<br>索引—— 一个表可以有多个唯一索引</li>
</ol>
</li>
<li><h3 id="用什么语句可以看到为表格定义的所有索引？"><a href="#用什么语句可以看到为表格定义的所有索引？" class="headerlink" title="用什么语句可以看到为表格定义的所有索引？"></a>用什么语句可以看到为表格定义的所有索引？</h3><ol>
<li>SHOW INDEX FROM <tablename>;</li>
</ol>
</li>
<li><h3 id="对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题："><a href="#对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题：" class="headerlink" title="对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题："></a>对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题：</h3><ol>
<li><h4 id="索引的目的是什么？"><a href="#索引的目的是什么？" class="headerlink" title="索引的目的是什么？"></a>索引的目的是什么？</h4>快速访问数据表中的特定信息，提高检索速度<br>创建唯一性索引，保证数据库表中每一行数据的唯一性。<br>加速表和表之间的连接<br>使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间</li>
<li><h4 id="索引对数据库系统的负面影响是什么？"><a href="#索引对数据库系统的负面影响是什么？" class="headerlink" title="索引对数据库系统的负面影响是什么？"></a>索引对数据库系统的负面影响是什么？</h4>负面影响：创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。</li>
<li><h4 id="为数据表建立索引的原则有哪些"><a href="#为数据表建立索引的原则有哪些" class="headerlink" title="为数据表建立索引的原则有哪些?"></a>为数据表建立索引的原则有哪些?</h4>在最频繁使用的、用以缩小查询范围的字段上建立索引。<br>在频繁使用的、需要排序的字段上建立索引</li>
<li><h4 id="什么情况下不宜建立索引？"><a href="#什么情况下不宜建立索引？" class="headerlink" title="什么情况下不宜建立索引？"></a>什么情况下不宜建立索引？</h4>对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引。<br>对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等</li>
</ol>
</li>
<li><h3 id="简单描述-MySQL-中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）"><a href="#简单描述-MySQL-中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）" class="headerlink" title="简单描述 MySQL 中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）"></a>简单描述 MySQL 中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）</h3><ol>
<li>索引是一种特殊的文件(InnoDB 数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</li>
<li>普通索引(由关键字 KEY 或 INDEX 定义的索引)的唯一任务是加快对数据的访问速度。</li>
<li>普通索引允许被索引的数据列包含重复的值。如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字 UNIQUE 把它定义为一个唯一索引。也就是说，唯一索引可以保证数据记录的唯一性。</li>
<li>主键，是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。</li>
<li>索引可以覆盖多个数据列，如像 INDEX(columnA, columnB)索引，这就是联合索引。</li>
<li>索引可以极大的提高数据的查询速度，但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件。</li>
</ol>
</li>
<li><h3 id="索引的底层实现原理和优化"><a href="#索引的底层实现原理和优化" class="headerlink" title="索引的底层实现原理和优化"></a>索引的底层实现原理和优化</h3><ol>
<li>B+树，经过优化的 B+树</li>
<li>主要是在所有的叶子结点中增加了指向下一个叶子节点的指针，因此 InnoDB 建议为大部分表使用默认自增的主键作为主索引。</li>
</ol>
</li>
<li><h3 id="什么情况下设置了索引但无法使用"><a href="#什么情况下设置了索引但无法使用" class="headerlink" title="什么情况下设置了索引但无法使用"></a>什么情况下设置了索引但无法使用</h3><ol>
<li>以“%”开头的 LIKE 语句，模糊匹配</li>
<li>OR 语句前后没有同时使用索引</li>
<li>数据类型出现隐式转化（如 varchar 不加单引号的话可能会自动转换为 int 型）</li>
</ol>
</li>
<li><h3 id="LIKE-声明中的％和-是什么意思？"><a href="#LIKE-声明中的％和-是什么意思？" class="headerlink" title="LIKE 声明中的％和_是什么意思？"></a>LIKE 声明中的％和_是什么意思？</h3><ol>
<li>％对应于 0 个或更多字符，_只是 LIKE 语句中的一个字符。</li>
</ol>
</li>
</ol>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><ol>
<li><h3 id="什么是锁？"><a href="#什么是锁？" class="headerlink" title="什么是锁？"></a>什么是锁？</h3>数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。<br>加锁是实现数据库并发控制的一个非常重要的技术。当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。</li>
<li><h3 id="MySQL-中有哪几种锁？"><a href="#MySQL-中有哪几种锁？" class="headerlink" title="MySQL 中有哪几种锁？"></a>MySQL 中有哪几种锁？</h3><ol>
<li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最 高，并发度最低。</li>
<li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最 低，并发度也最高。</li>
<li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表 锁和行锁之间，并发度一般。</li>
</ol>
</li>
</ol>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><ol>
<li><h3 id="说说对-SQL-语句优化有哪些方法？"><a href="#说说对-SQL-语句优化有哪些方法？" class="headerlink" title="说说对 SQL 语句优化有哪些方法？"></a>说说对 SQL 语句优化有哪些方法？</h3><ol>
<li>Where 子句中：where 表之间的连接必须写在其他 Where 条件之前，那些可以过滤掉最大数量记录的条件必须写在 Where 子句的末尾.HAVING 最后。</li>
<li>用 EXISTS 替代 IN、用 NOT EXISTS 替代 NOT IN。</li>
<li>避免在索引列上使用计算</li>
<li>避免在索引列上使用 IS NULL 和 IS NOT NULL</li>
<li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li>
<li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</li>
<li>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描</li>
</ol>
</li>
<li><h3 id="优化数据库的方法"><a href="#优化数据库的方法" class="headerlink" title="优化数据库的方法"></a>优化数据库的方法</h3><ol>
<li>选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置 NOTNULL，例如’省份’、’性别’最好适用 ENUM</li>
<li>使用连接(JOIN)来代替子查询</li>
<li>适用联合(UNION)来代替手动创建的临时表</li>
<li>事务处理</li>
<li>锁定表、优化事务处理</li>
<li>适用外键，优化锁定表</li>
<li>建立索引</li>
<li>优化查询语句</li>
</ol>
</li>
</ol>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><ol>
<li><h3 id="试述视图的优点？"><a href="#试述视图的优点？" class="headerlink" title="试述视图的优点？"></a>试述视图的优点？</h3><ol>
<li>视图能够简化用户的操作</li>
<li>视图使用户能以多种角度看待同一数据；</li>
<li>视图为数据库提供了一定程度的逻辑独立性；</li>
<li>视图能够对机密数据提供安全保护。</li>
</ol>
</li>
</ol>
<h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><ol>
<li><h3 id="如何通俗地理解三个范式？"><a href="#如何通俗地理解三个范式？" class="headerlink" title="如何通俗地理解三个范式？"></a>如何通俗地理解三个范式？</h3><ol>
<li>第一范式：1NF 是对属性的原子性约束，要求属性具有原子性，不可再分解；</li>
<li>第二范式：2NF 是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；</li>
<li>第三范式：3NF 是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。。</li>
</ol>
</li>
<li><h3 id="范式化设计优缺点"><a href="#范式化设计优缺点" class="headerlink" title="范式化设计优缺点:"></a>范式化设计优缺点:</h3><ol>
<li>优点:可以尽量得减少数据冗余，使得更新快，体积小</li>
<li>缺点:对于查询需要多个表进行关联，减少写得效率增加读得效率，更难进行索引优化</li>
</ol>
</li>
<li><h4 id="反范式化"><a href="#反范式化" class="headerlink" title="反范式化:"></a>反范式化:</h4><ol>
<li>优点:可以减少表得关联，可以更好得进行索引优化</li>
<li>缺点:数据冗余以及数据异常，数据得修改需要更多的成本</li>
</ol>
</li>
</ol>
<h1 id="编程方面"><a href="#编程方面" class="headerlink" title="编程方面"></a>编程方面</h1><ol>
<li><h3 id="SQL-注入漏洞产生的原因？如何防止？"><a href="#SQL-注入漏洞产生的原因？如何防止？" class="headerlink" title="SQL 注入漏洞产生的原因？如何防止？"></a>SQL 注入漏洞产生的原因？如何防止？</h3><p>SQL 注入产生的原因：程序开发过程中不注意规范书写 sql 语句和对特殊字符进行过滤，导致客户端可以通过全局变量 POST 和 GET 提交一些 sql 语句正常执行。<br>防止 SQL 注入的方式：</p>
<ol>
<li>开启配置文件中的 magic_quotes_gpc 和 magic_quotes_runtime 设置</li>
<li>执行 sql 语句时使用 addslashes 进行 sql 语句转换</li>
<li>Sql 语句书写尽量不要省略双引号和单引号。</li>
<li>过滤掉 sql 语句中的一些关键词：update、insert、delete、select、 * 。</li>
<li>提高数据库表和字段的命名技巧，对一些重要的字段根据程序的特点命名，取不易被猜到的。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>database</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
</search>
